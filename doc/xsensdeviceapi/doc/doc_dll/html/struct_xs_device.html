<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsDevicePtr Struct Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="struct_xs_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsDevicePtr Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> object.  
 <a href="struct_xs_device.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5b80595b05a1d32ff2ce465f6869dba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5b80595b05a1d32ff2ce465f6869dba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa5b80595b05a1d32ff2ce465f6869dba">addRef</a> (void)</td></tr>
<tr class="memdesc:aa5b80595b05a1d32ff2ce465f6869dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference count of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> pointer <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> pointers stay alive while reference counter is not zero Also increases the reference count of each child device with 1. <br /></td></tr>
<tr class="separator:aa5b80595b05a1d32ff2ce465f6869dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd62e7bef270670a169b248d40f01c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7cd62e7bef270670a169b248d40f01c1">removeRef</a> (void)</td></tr>
<tr class="memdesc:a7cd62e7bef270670a169b248d40f01c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1.  <a href="#a7cd62e7bef270670a169b248d40f01c1">More...</a><br /></td></tr>
<tr class="separator:a7cd62e7bef270670a169b248d40f01c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751099844b8177fe2072d4ec8766bd5a"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a751099844b8177fe2072d4ec8766bd5a">refCounter</a> (void) const </td></tr>
<tr class="memdesc:a751099844b8177fe2072d4ec8766bd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current reference counter.  <a href="#a751099844b8177fe2072d4ec8766bd5a">More...</a><br /></td></tr>
<tr class="separator:a751099844b8177fe2072d4ec8766bd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f15fd07a05892389a89799e41ad46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a22f15fd07a05892389a89799e41ad46b">master</a> (void) const </td></tr>
<tr class="memdesc:a22f15fd07a05892389a89799e41ad46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the master device of this device.  <a href="#a22f15fd07a05892389a89799e41ad46b">More...</a><br /></td></tr>
<tr class="separator:a22f15fd07a05892389a89799e41ad46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aad6fe5d2f33fbf8ba32a299cd47e56b8">findDevice</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid)</td></tr>
<tr class="memdesc:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.  <a href="#aad6fe5d2f33fbf8ba32a299cd47e56b8">More...</a><br /></td></tr>
<tr class="separator:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3327b3ab9c38e6d7146268cbb5f5074f">findDeviceConst</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid) const </td></tr>
<tr class="memdesc:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.  <a href="#a3327b3ab9c38e6d7146268cbb5f5074f">More...</a><br /></td></tr>
<tr class="separator:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d48fb574f706adf5976cf94e110efe9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8d48fb574f706adf5976cf94e110efe9">busId</a> (void) const </td></tr>
<tr class="memdesc:a8d48fb574f706adf5976cf94e110efe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus ID for this device.  <a href="#a8d48fb574f706adf5976cf94e110efe9">More...</a><br /></td></tr>
<tr class="separator:a8d48fb574f706adf5976cf94e110efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae739c221e20e36b22c12a2bf2d4836df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a> (void) const </td></tr>
<tr class="memdesc:ae739c221e20e36b22c12a2bf2d4836df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device ID of the device.  <a href="#ae739c221e20e36b22c12a2bf2d4836df">More...</a><br /></td></tr>
<tr class="separator:ae739c221e20e36b22c12a2bf2d4836df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700a14fc473ac6b6cf89e85bdece0f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a700a14fc473ac6b6cf89e85bdece0f0a">firmwareVersion</a> (void) const </td></tr>
<tr class="memdesc:a700a14fc473ac6b6cf89e85bdece0f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the firmware version.  <a href="#a700a14fc473ac6b6cf89e85bdece0f0a">More...</a><br /></td></tr>
<tr class="separator:a700a14fc473ac6b6cf89e85bdece0f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9431efa3b5247f59d7978637cae8c008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9431efa3b5247f59d7978637cae8c008">isMasterDevice</a> (void) const </td></tr>
<tr class="memdesc:a9431efa3b5247f59d7978637cae8c008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the master device (not a child of another device)  <a href="#a9431efa3b5247f59d7978637cae8c008">More...</a><br /></td></tr>
<tr class="separator:a9431efa3b5247f59d7978637cae8c008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a71199e0ac73a6e3633087d7212211"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a40a71199e0ac73a6e3633087d7212211">isContainerDevice</a> (void) const </td></tr>
<tr class="memdesc:a40a71199e0ac73a6e3633087d7212211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this device can have child devices.  <a href="#a40a71199e0ac73a6e3633087d7212211">More...</a><br /></td></tr>
<tr class="separator:a40a71199e0ac73a6e3633087d7212211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245785b875173391a1ec45606076700c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a245785b875173391a1ec45606076700c">isInitialized</a> (void) const </td></tr>
<tr class="memdesc:a245785b875173391a1ec45606076700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the device is initialized.  <a href="#a245785b875173391a1ec45606076700c">More...</a><br /></td></tr>
<tr class="separator:a245785b875173391a1ec45606076700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080a75bb6fbea533c0f031e69f5e0651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a080a75bb6fbea533c0f031e69f5e0651">isStandaloneDevice</a> (void) const </td></tr>
<tr class="memdesc:a080a75bb6fbea533c0f031e69f5e0651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a standalone device (not a child of another device and not a container device)  <a href="#a080a75bb6fbea533c0f031e69f5e0651">More...</a><br /></td></tr>
<tr class="separator:a080a75bb6fbea533c0f031e69f5e0651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6d6e422d8ccf6316a33f29be3259ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aac6d6e422d8ccf6316a33f29be3259ed">deviceAtBusIdConst</a> (int busid) const </td></tr>
<tr class="memdesc:aac6d6e422d8ccf6316a33f29be3259ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#aac6d6e422d8ccf6316a33f29be3259ed">More...</a><br /></td></tr>
<tr class="separator:aac6d6e422d8ccf6316a33f29be3259ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5252f1f85a52eeef4ac2c5af789c24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af5252f1f85a52eeef4ac2c5af789c24e">deviceAtBusId</a> (int busid)</td></tr>
<tr class="memdesc:af5252f1f85a52eeef4ac2c5af789c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#af5252f1f85a52eeef4ac2c5af789c24e">More...</a><br /></td></tr>
<tr class="separator:af5252f1f85a52eeef4ac2c5af789c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ee16fe5af46d170902369671fa23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aac0ee16fe5af46d170902369671fa23f">setGotoConfigOnClose</a> (bool gotoConfigOnClose)</td></tr>
<tr class="memdesc:aac0ee16fe5af46d170902369671fa23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">On closePort the device will go to config by default, with this function it is possible to prevent that.  <a href="#aac0ee16fe5af46d170902369671fa23f">More...</a><br /></td></tr>
<tr class="separator:aac0ee16fe5af46d170902369671fa23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4">createLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a log file for logging.  <a href="#a8afe4b27a5df14e02c8a1c6a7dfcb3c4">More...</a><br /></td></tr>
<tr class="separator:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517288ec25530fc1ef25c1688bab7bcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a517288ec25530fc1ef25c1688bab7bcf">closeLogFile</a> (void)</td></tr>
<tr class="memdesc:a517288ec25530fc1ef25c1688bab7bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="#a517288ec25530fc1ef25c1688bab7bcf">More...</a><br /></td></tr>
<tr class="separator:a517288ec25530fc1ef25c1688bab7bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c17d9aed6fcf3913b386c289652ae2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5c17d9aed6fcf3913b386c289652ae2a">isMeasuring</a> (void) const </td></tr>
<tr class="memdesc:a5c17d9aed6fcf3913b386c289652ae2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a measuring state.  <a href="#a5c17d9aed6fcf3913b386c289652ae2a">More...</a><br /></td></tr>
<tr class="separator:a5c17d9aed6fcf3913b386c289652ae2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc553090db95a478977300c52ffd9ca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acc553090db95a478977300c52ffd9ca6">isRecording</a> (void) const </td></tr>
<tr class="memdesc:acc553090db95a478977300c52ffd9ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a recording state.  <a href="#acc553090db95a478977300c52ffd9ca6">More...</a><br /></td></tr>
<tr class="separator:acc553090db95a478977300c52ffd9ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783311f6552d50a106275256aa6679e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8783311f6552d50a106275256aa6679e">isReadingFromFile</a> (void) const </td></tr>
<tr class="memdesc:a8783311f6552d50a106275256aa6679e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is reading from a file.  <a href="#a8783311f6552d50a106275256aa6679e">More...</a><br /></td></tr>
<tr class="separator:a8783311f6552d50a106275256aa6679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabab17fb12468ce5680ef685b60f0ef7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabab17fb12468ce5680ef685b60f0ef7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aabab17fb12468ce5680ef685b60f0ef7">restartFilter</a> (void)</td></tr>
<tr class="memdesc:aabab17fb12468ce5680ef685b60f0ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the software filter used by this device. <br /></td></tr>
<tr class="separator:aabab17fb12468ce5680ef685b60f0ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a9d1ef957c1937220f541e66d97c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a099a9d1ef957c1937220f541e66d97c8">lastResult</a> (void) const </td></tr>
<tr class="memdesc:a099a9d1ef957c1937220f541e66d97c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="#a099a9d1ef957c1937220f541e66d97c8">More...</a><br /></td></tr>
<tr class="separator:a099a9d1ef957c1937220f541e66d97c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5f61cb5abb68e1177ec25339513d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afb5f61cb5abb68e1177ec25339513d45">lastResultText</a> (void) const </td></tr>
<tr class="memdesc:afb5f61cb5abb68e1177ec25339513d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_xs_device.html#a099a9d1ef957c1937220f541e66d97c8" title="Get the result value of the last operation. ">lastResult()</a> It may provide situation-specific information instead.  <a href="#afb5f61cb5abb68e1177ec25339513d45">More...</a><br /></td></tr>
<tr class="separator:afb5f61cb5abb68e1177ec25339513d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7c050c6f13611d99f2e67473d7ce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa2f7c050c6f13611d99f2e67473d7ce4">recordingQueueLength</a> (void) const </td></tr>
<tr class="memdesc:aa2f7c050c6f13611d99f2e67473d7ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of packets currently waiting in the slow data cache for the device based.  <a href="#aa2f7c050c6f13611d99f2e67473d7ce4">More...</a><br /></td></tr>
<tr class="separator:aa2f7c050c6f13611d99f2e67473d7ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12ae093fdf9cb837f1bc7d2c7069302"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa12ae093fdf9cb837f1bc7d2c7069302">cacheSize</a> (void) const </td></tr>
<tr class="memdesc:aa12ae093fdf9cb837f1bc7d2c7069302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently in the slow data cache for the device.  <a href="#aa12ae093fdf9cb837f1bc7d2c7069302">More...</a><br /></td></tr>
<tr class="separator:aa12ae093fdf9cb837f1bc7d2c7069302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac604dd0e7d5f5a9373cdb7d5380d8250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac604dd0e7d5f5a9373cdb7d5380d8250">deviceState</a> (void) const </td></tr>
<tr class="memdesc:ac604dd0e7d5f5a9373cdb7d5380d8250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of this device.  <a href="#ac604dd0e7d5f5a9373cdb7d5380d8250">More...</a><br /></td></tr>
<tr class="separator:ac604dd0e7d5f5a9373cdb7d5380d8250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208157faba015c166f2878e070cfad94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a208157faba015c166f2878e070cfad94">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a208157faba015c166f2878e070cfad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#a208157faba015c166f2878e070cfad94">More...</a><br /></td></tr>
<tr class="separator:a208157faba015c166f2878e070cfad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affecdda0f378e2193c75a3e01055eecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#affecdda0f378e2193c75a3e01055eecc">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:affecdda0f378e2193c75a3e01055eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#affecdda0f378e2193c75a3e01055eecc">More...</a><br /></td></tr>
<tr class="separator:affecdda0f378e2193c75a3e01055eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3608b05b6a94c8ff3889a1976ea42ee6">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a3608b05b6a94c8ff3889a1976ea42ee6">More...</a><br /></td></tr>
<tr class="separator:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214d93f19a57c11ce1cf1fd2b0f750a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac214d93f19a57c11ce1cf1fd2b0f750a">deviceConfiguration</a> (void) const </td></tr>
<tr class="memdesc:ac214d93f19a57c11ce1cf1fd2b0f750a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device configuration.  <a href="#ac214d93f19a57c11ce1cf1fd2b0f750a">More...</a><br /></td></tr>
<tr class="separator:ac214d93f19a57c11ce1cf1fd2b0f750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a4256625a1015db63ea98e3f8c6b3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48a4256625a1015db63ea98e3f8c6b3e">batteryLevel</a> (void) const </td></tr>
<tr class="memdesc:a48a4256625a1015db63ea98e3f8c6b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication.  <a href="#a48a4256625a1015db63ea98e3f8c6b3e">More...</a><br /></td></tr>
<tr class="separator:a48a4256625a1015db63ea98e3f8c6b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c7fbc6491350c79800b3dc20359fa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3">updateRateForDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a81c7fbc6491350c79800b3dc20359fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a81c7fbc6491350c79800b3dc20359fa3">More...</a><br /></td></tr>
<tr class="separator:a81c7fbc6491350c79800b3dc20359fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3e588c33f4afdf18e6d4af7f4a2bcdb5">updateRateForProcessedDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a3e588c33f4afdf18e6d4af7f4a2bcdb5">More...</a><br /></td></tr>
<tr class="separator:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617e87d8f8ccf472f4f622f2e872171d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_int_array.html">XsIntArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a617e87d8f8ccf472f4f622f2e872171d">supportedUpdateRates</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType=<a class="el" href="group__enums.html#gga7f6c648c619f528344bfa0630c1f7252a0f6d9a98f741377d30c073548e64b97c">XDI_None</a>) const </td></tr>
<tr class="memdesc:a617e87d8f8ccf472f4f622f2e872171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported update rates for the given <em>dataType</em>.  <a href="#a617e87d8f8ccf472f4f622f2e872171d">More...</a><br /></td></tr>
<tr class="separator:a617e87d8f8ccf472f4f622f2e872171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcda8710cd0aec33f33967f1cafaee7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afcda8710cd0aec33f33967f1cafaee7a">maximumUpdateRate</a> (void) const </td></tr>
<tr class="memdesc:afcda8710cd0aec33f33967f1cafaee7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum update rate for the device.  <a href="#afcda8710cd0aec33f33967f1cafaee7a">More...</a><br /></td></tr>
<tr class="separator:afcda8710cd0aec33f33967f1cafaee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24c84fbcf4691c7c31b76dc276c275"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275">hasDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:aee24c84fbcf4691c7c31b76dc276c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em>.  <a href="#aee24c84fbcf4691c7c31b76dc276c275">More...</a><br /></td></tr>
<tr class="separator:aee24c84fbcf4691c7c31b76dc276c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d8f53878808179a778b98e229e8242"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a76d8f53878808179a778b98e229e8242">hasProcessedDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a76d8f53878808179a778b98e229e8242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em> after processing on the host.  <a href="#a76d8f53878808179a778b98e229e8242">More...</a><br /></td></tr>
<tr class="separator:a76d8f53878808179a778b98e229e8242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa808cef643f6f855dcc93ad24e3f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6fa808cef643f6f855dcc93ad24e3f10">productCode</a> (void) const </td></tr>
<tr class="memdesc:a6fa808cef643f6f855dcc93ad24e3f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product code of the device.  <a href="#a6fa808cef643f6f855dcc93ad24e3f10">More...</a><br /></td></tr>
<tr class="separator:a6fa808cef643f6f855dcc93ad24e3f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8be9976cc53c225affc305821b7722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9b8be9976cc53c225affc305821b7722">portName</a> (void) const </td></tr>
<tr class="memdesc:a9b8be9976cc53c225affc305821b7722"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port name of the connection.  <a href="#a9b8be9976cc53c225affc305821b7722">More...</a><br /></td></tr>
<tr class="separator:a9b8be9976cc53c225affc305821b7722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947f084fda5a5a73e27feae5b511e90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a947f084fda5a5a73e27feae5b511e90b">portInfo</a> (void) const </td></tr>
<tr class="memdesc:a947f084fda5a5a73e27feae5b511e90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port information of the connection.  <a href="#a947f084fda5a5a73e27feae5b511e90b">More...</a><br /></td></tr>
<tr class="separator:a947f084fda5a5a73e27feae5b511e90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5fe131e261f0126b62d36faee29b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adf5fe131e261f0126b62d36faee29b16">baudRate</a> (void) const </td></tr>
<tr class="memdesc:adf5fe131e261f0126b62d36faee29b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected.  <a href="#adf5fe131e261f0126b62d36faee29b16">More...</a><br /></td></tr>
<tr class="separator:adf5fe131e261f0126b62d36faee29b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cec49fbd44450843078f0db55eb323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a29cec49fbd44450843078f0db55eb323">serialBaudRate</a> (void) const </td></tr>
<tr class="memdesc:a29cec49fbd44450843078f0db55eb323"><td class="mdescLeft">&#160;</td><td class="mdescRight">The baud rate configured for cabled connection.  <a href="#a29cec49fbd44450843078f0db55eb323">More...</a><br /></td></tr>
<tr class="separator:a29cec49fbd44450843078f0db55eb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60c0231d8d5f7f9033954c0b6e6e25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa60c0231d8d5f7f9033954c0b6e6e25e">hardwareVersion</a> (void) const </td></tr>
<tr class="memdesc:aa60c0231d8d5f7f9033954c0b6e6e25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hardware version of the device.  <a href="#aa60c0231d8d5f7f9033954c0b6e6e25e">More...</a><br /></td></tr>
<tr class="separator:aa60c0231d8d5f7f9033954c0b6e6e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49e90836b702ba8d2d3ff7e5eb27d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2b49e90836b702ba8d2d3ff7e5eb27d9">startRecording</a> (void)</td></tr>
<tr class="memdesc:a2b49e90836b702ba8d2d3ff7e5eb27d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data.  <a href="#a2b49e90836b702ba8d2d3ff7e5eb27d9">More...</a><br /></td></tr>
<tr class="separator:a2b49e90836b702ba8d2d3ff7e5eb27d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32d16f3ff81d53a0e309dbb14dc562e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af32d16f3ff81d53a0e309dbb14dc562e">triggerStartRecording</a> (void)</td></tr>
<tr class="memdesc:af32d16f3ff81d53a0e309dbb14dc562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data through generating a virtual input trigger.  <a href="#af32d16f3ff81d53a0e309dbb14dc562e">More...</a><br /></td></tr>
<tr class="separator:af32d16f3ff81d53a0e309dbb14dc562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784f73a6a186365a5f9ce9be66a87367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a784f73a6a186365a5f9ce9be66a87367">stopRecording</a> (void)</td></tr>
<tr class="memdesc:a784f73a6a186365a5f9ce9be66a87367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording incoming data.  <a href="#a784f73a6a186365a5f9ce9be66a87367">More...</a><br /></td></tr>
<tr class="separator:a784f73a6a186365a5f9ce9be66a87367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4924c51c4de8d1791bee6d2c00855f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ade4924c51c4de8d1791bee6d2c00855f">getStartRecordingPacketId</a> (void) const </td></tr>
<tr class="memdesc:ade4924c51c4de8d1791bee6d2c00855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ID of the first packet that should be recorded.  <a href="#ade4924c51c4de8d1791bee6d2c00855f">More...</a><br /></td></tr>
<tr class="separator:ade4924c51c4de8d1791bee6d2c00855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2363d72b55fd8dd65c83612db36ac632"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2363d72b55fd8dd65c83612db36ac632">getStopRecordingPacketId</a> (void) const </td></tr>
<tr class="memdesc:a2363d72b55fd8dd65c83612db36ac632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ID of the last packet that should be recorded.  <a href="#a2363d72b55fd8dd65c83612db36ac632">More...</a><br /></td></tr>
<tr class="separator:a2363d72b55fd8dd65c83612db36ac632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14166aed1e4d0e30fb3e80aed55453e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e">setOptions</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enable, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> disable)</td></tr>
<tr class="memdesc:af14166aed1e4d0e30fb3e80aed55453e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and disable processing options.  <a href="#af14166aed1e4d0e30fb3e80aed55453e">More...</a><br /></td></tr>
<tr class="separator:af14166aed1e4d0e30fb3e80aed55453e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c443be103003479799fa888ada5216e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e">areOptionsEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> options) const </td></tr>
<tr class="memdesc:a8c443be103003479799fa888ada5216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when all the specified processing options are enabled.  <a href="#a8c443be103003479799fa888ada5216e">More...</a><br /></td></tr>
<tr class="separator:a8c443be103003479799fa888ada5216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927432e398ce365fcde26158b288c980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a927432e398ce365fcde26158b288c980">getOptions</a> (void) const </td></tr>
<tr class="memdesc:a927432e398ce365fcde26158b288c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently enabled options.  <a href="#a927432e398ce365fcde26158b288c980">More...</a><br /></td></tr>
<tr class="separator:a927432e398ce365fcde26158b288c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9656439549ad9d4a2572aea7afaa48d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5">sendCustomMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageSend, bool waitForResult, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageReceive, int timeout=0)</td></tr>
<tr class="memdesc:a9656439549ad9d4a2572aea7afaa48d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a custom message <em>messageSend</em> to the device and possibly wait for a result.  <a href="#a9656439549ad9d4a2572aea7afaa48d5">More...</a><br /></td></tr>
<tr class="separator:a9656439549ad9d4a2572aea7afaa48d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68153cc14002d710e1c896b0ee6f1f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac68153cc14002d710e1c896b0ee6f1f9">sendRawMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:ac68153cc14002d710e1c896b0ee6f1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message directly to the communicator.  <a href="#ac68153cc14002d710e1c896b0ee6f1f9">More...</a><br /></td></tr>
<tr class="separator:ac68153cc14002d710e1c896b0ee6f1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3febab304a21f08d188698aec93a97e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3febab304a21f08d188698aec93a97e2">setSerialBaudRate</a> (<a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate)</td></tr>
<tr class="memdesc:a3febab304a21f08d188698aec93a97e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the serial baudrate to <em>baudrate</em>.  <a href="#a3febab304a21f08d188698aec93a97e2">More...</a><br /></td></tr>
<tr class="separator:a3febab304a21f08d188698aec93a97e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a756abb13ac67e12ac4ea802903477"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_int_array.html">XsIntArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a75a756abb13ac67e12ac4ea802903477">portConfiguration</a> (void) const </td></tr>
<tr class="memdesc:a75a756abb13ac67e12ac4ea802903477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current port configuration of a device.  <a href="#a75a756abb13ac67e12ac4ea802903477">More...</a><br /></td></tr>
<tr class="separator:a75a756abb13ac67e12ac4ea802903477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e60613acdb412005dd3ec00baf6622"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae6e60613acdb412005dd3ec00baf6622">setPortConfiguration</a> (<a class="el" href="struct_xs_int_array.html">XsIntArray</a> &amp;config)</td></tr>
<tr class="memdesc:ae6e60613acdb412005dd3ec00baf6622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the port configuration of a device.  <a href="#ae6e60613acdb412005dd3ec00baf6622">More...</a><br /></td></tr>
<tr class="separator:ae6e60613acdb412005dd3ec00baf6622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1ca78bee44913757b6fe623fc02682"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aad1ca78bee44913757b6fe623fc02682">isMotionTracker</a> (void) const </td></tr>
<tr class="memdesc:aad1ca78bee44913757b6fe623fc02682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a motion tracker.  <a href="#aad1ca78bee44913757b6fe623fc02682">More...</a><br /></td></tr>
<tr class="separator:aad1ca78bee44913757b6fe623fc02682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b82b4a47ddc389a96b16a1e265e4519"><td class="memItemLeft" align="right" valign="top">XsOperationalMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3b82b4a47ddc389a96b16a1e265e4519">operationalMode</a> (void) const </td></tr>
<tr class="memdesc:a3b82b4a47ddc389a96b16a1e265e4519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operational mode.  <a href="#a3b82b4a47ddc389a96b16a1e265e4519">More...</a><br /></td></tr>
<tr class="separator:a3b82b4a47ddc389a96b16a1e265e4519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1f3c5fb2d9a4b4f04ab99c7843fea294">setOperationalMode</a> (XsOperationalMode mode)</td></tr>
<tr class="memdesc:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device in the given operational mode.  <a href="#a1f3c5fb2d9a4b4f04ab99c7843fea294">More...</a><br /></td></tr>
<tr class="separator:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad682f0f6a9d5cb6a2f6be5960e947c7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad682f0f6a9d5cb6a2f6be5960e947c7e">updateRate</a> (void) const </td></tr>
<tr class="memdesc:ad682f0f6a9d5cb6a2f6be5960e947c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the legacy update rate of the device.  <a href="#ad682f0f6a9d5cb6a2f6be5960e947c7e">More...</a><br /></td></tr>
<tr class="separator:ad682f0f6a9d5cb6a2f6be5960e947c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43f1e4fe0a563c86f40a663e113b1bbf">setUpdateRate</a> (int rate)</td></tr>
<tr class="memdesc:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the legacy update rate of the device.  <a href="#a43f1e4fe0a563c86f40a663e113b1bbf">More...</a><br /></td></tr>
<tr class="separator:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033dee757377384f010ffd9fb61dcd81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a033dee757377384f010ffd9fb61dcd81">deviceOptionFlags</a> (void) const </td></tr>
<tr class="memdesc:a033dee757377384f010ffd9fb61dcd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device option flags.  <a href="#a033dee757377384f010ffd9fb61dcd81">More...</a><br /></td></tr>
<tr class="separator:a033dee757377384f010ffd9fb61dcd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1033b2fd38c83d64db9390c5fb2368"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aef1033b2fd38c83d64db9390c5fb2368">setDeviceOptionFlags</a> (<a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> setFlags, <a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> clearFlags)</td></tr>
<tr class="memdesc:aef1033b2fd38c83d64db9390c5fb2368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device option flags.  <a href="#aef1033b2fd38c83d64db9390c5fb2368">More...</a><br /></td></tr>
<tr class="separator:aef1033b2fd38c83d64db9390c5fb2368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14314a4fe4fa762c784b5d580746c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae14314a4fe4fa762c784b5d580746c89">outputConfiguration</a> (void) const </td></tr>
<tr class="memdesc:ae14314a4fe4fa762c784b5d580746c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured output of the device.  <a href="#ae14314a4fe4fa762c784b5d580746c89">More...</a><br /></td></tr>
<tr class="separator:ae14314a4fe4fa762c784b5d580746c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac8cf2dbe4ffc890ddf12dace09feed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0ac8cf2dbe4ffc890ddf12dace09feed">processedOutputConfiguration</a> (void) const </td></tr>
<tr class="memdesc:a0ac8cf2dbe4ffc890ddf12dace09feed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full output configuration including post processing outputs.  <a href="#a0ac8cf2dbe4ffc890ddf12dace09feed">More...</a><br /></td></tr>
<tr class="separator:a0ac8cf2dbe4ffc890ddf12dace09feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ba018ecf2f59b3e00e1471acf656ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a41ba018ecf2f59b3e00e1471acf656ab">setOutputConfiguration</a> (<a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;config)</td></tr>
<tr class="memdesc:a41ba018ecf2f59b3e00e1471acf656ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output configuration for this device.  <a href="#a41ba018ecf2f59b3e00e1471acf656ab">More...</a><br /></td></tr>
<tr class="separator:a41ba018ecf2f59b3e00e1471acf656ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fef104c27b7d4fd0ecd18e28dc0136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a98fef104c27b7d4fd0ecd18e28dc0136">isInStringOutputMode</a> (void) const </td></tr>
<tr class="memdesc:a98fef104c27b7d4fd0ecd18e28dc0136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in string mode.  <a href="#a98fef104c27b7d4fd0ecd18e28dc0136">More...</a><br /></td></tr>
<tr class="separator:a98fef104c27b7d4fd0ecd18e28dc0136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a825a8ec9fee89b6da73dbeba218e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5a825a8ec9fee89b6da73dbeba218e56">canOutputConfiguration</a> (void) const </td></tr>
<tr class="memdesc:a5a825a8ec9fee89b6da73dbeba218e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured CAN output of the device.  <a href="#a5a825a8ec9fee89b6da73dbeba218e56">More...</a><br /></td></tr>
<tr class="separator:a5a825a8ec9fee89b6da73dbeba218e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc34af532ebc3c86a948e99f3e307d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a53cc34af532ebc3c86a948e99f3e307d">setCanOutputConfiguration</a> (<a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> &amp;config)</td></tr>
<tr class="memdesc:a53cc34af532ebc3c86a948e99f3e307d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CAN output configuration for this device.  <a href="#a53cc34af532ebc3c86a948e99f3e307d">More...</a><br /></td></tr>
<tr class="separator:a53cc34af532ebc3c86a948e99f3e307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b98e3907877e7c358129137a0731e1a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1b98e3907877e7c358129137a0731e1a">canConfiguration</a> (void) const </td></tr>
<tr class="memdesc:a1b98e3907877e7c358129137a0731e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured CAN configuration of the device.  <a href="#a1b98e3907877e7c358129137a0731e1a">More...</a><br /></td></tr>
<tr class="separator:a1b98e3907877e7c358129137a0731e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dbc784ace70b92caaefb7626d64887"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48dbc784ace70b92caaefb7626d64887">setCanConfiguration</a> (uint32_t config)</td></tr>
<tr class="memdesc:a48dbc784ace70b92caaefb7626d64887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CAN configuration for this device.  <a href="#a48dbc784ace70b92caaefb7626d64887">More...</a><br /></td></tr>
<tr class="separator:a48dbc784ace70b92caaefb7626d64887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b92988f84be8146ca072078d731f22b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0b92988f84be8146ca072078d731f22b">usesLegacyDeviceMode</a> (void) const </td></tr>
<tr class="memdesc:a0b92988f84be8146ca072078d731f22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the device uses legacy device mode.  <a href="#a0b92988f84be8146ca072078d731f22b">More...</a><br /></td></tr>
<tr class="separator:a0b92988f84be8146ca072078d731f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a6db129db6c4a9ed70c046edc4f0c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a486a6db129db6c4a9ed70c046edc4f0c">stringOutputType</a> (void) const </td></tr>
<tr class="memdesc:a486a6db129db6c4a9ed70c046edc4f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string output type.  <a href="#a486a6db129db6c4a9ed70c046edc4f0c">More...</a><br /></td></tr>
<tr class="separator:a486a6db129db6c4a9ed70c046edc4f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04842d5110b59731fc465d621c181936"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a04842d5110b59731fc465d621c181936">stringSamplePeriod</a> (void) const </td></tr>
<tr class="memdesc:a04842d5110b59731fc465d621c181936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample period for string output.  <a href="#a04842d5110b59731fc465d621c181936">More...</a><br /></td></tr>
<tr class="separator:a04842d5110b59731fc465d621c181936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb20367769efdbca2c3a5b78acf9e9e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aceb20367769efdbca2c3a5b78acf9e9e">stringSkipFactor</a> (void) const </td></tr>
<tr class="memdesc:aceb20367769efdbca2c3a5b78acf9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skipfactor for string output.  <a href="#aceb20367769efdbca2c3a5b78acf9e9e">More...</a><br /></td></tr>
<tr class="separator:aceb20367769efdbca2c3a5b78acf9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f01736d0491a404eecd35cdfee3fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afd4f01736d0491a404eecd35cdfee3fc">setStringOutputMode</a> (uint16_t type, uint16_t period, uint16_t skipFactor)</td></tr>
<tr class="memdesc:afd4f01736d0491a404eecd35cdfee3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the string output mode for this device.  <a href="#afd4f01736d0491a404eecd35cdfee3fc">More...</a><br /></td></tr>
<tr class="separator:afd4f01736d0491a404eecd35cdfee3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455925ce739da41a207990d31f10bdfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string_output_type_array.html">XsStringOutputTypeArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a455925ce739da41a207990d31f10bdfe">supportedStringOutputTypes</a> (void) const </td></tr>
<tr class="memdesc:a455925ce739da41a207990d31f10bdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported string output types.  <a href="#a455925ce739da41a207990d31f10bdfe">More...</a><br /></td></tr>
<tr class="separator:a455925ce739da41a207990d31f10bdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632fc319d29c737ec40a97cd1c0534c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a632fc319d29c737ec40a97cd1c0534c0">dataLength</a> (void) const </td></tr>
<tr class="memdesc:a632fc319d29c737ec40a97cd1c0534c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the data in the legacy MTData packets that the device will send in measurement mode.  <a href="#a632fc319d29c737ec40a97cd1c0534c0">More...</a><br /></td></tr>
<tr class="separator:a632fc319d29c737ec40a97cd1c0534c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00db14ca9852fbee4289a30a94c6eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad00db14ca9852fbee4289a30a94c6eb2">syncSettings</a> (void) const </td></tr>
<tr class="memdesc:ad00db14ca9852fbee4289a30a94c6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the current synchronization settings of the device.  <a href="#ad00db14ca9852fbee4289a30a94c6eb2">More...</a><br /></td></tr>
<tr class="separator:ad00db14ca9852fbee4289a30a94c6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027b516c49744d85c28129b9a95c4eaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a027b516c49744d85c28129b9a95c4eaa">setSyncSettings</a> (const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;settingList)</td></tr>
<tr class="memdesc:a027b516c49744d85c28129b9a95c4eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the synchronization settings of the device.  <a href="#a027b516c49744d85c28129b9a95c4eaa">More...</a><br /></td></tr>
<tr class="separator:a027b516c49744d85c28129b9a95c4eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add838b44c58b46df62660c511d0294f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#add838b44c58b46df62660c511d0294f2">isSyncMaster</a> (void) const </td></tr>
<tr class="memdesc:add838b44c58b46df62660c511d0294f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a master role regarding the device synchronization  <a href="#add838b44c58b46df62660c511d0294f2">More...</a><br /></td></tr>
<tr class="separator:add838b44c58b46df62660c511d0294f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad794d654ce040f786590b64d391b4475"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad794d654ce040f786590b64d391b4475">isSyncSlave</a> (void) const </td></tr>
<tr class="memdesc:ad794d654ce040f786590b64d391b4475"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a slave role regarding the device synchronization  <a href="#ad794d654ce040f786590b64d391b4475">More...</a><br /></td></tr>
<tr class="separator:ad794d654ce040f786590b64d391b4475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5003fb23821cf7dfa935e6aa1932ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aef5003fb23821cf7dfa935e6aa1932ab">supportedSyncSettings</a> (void) const </td></tr>
<tr class="memdesc:aef5003fb23821cf7dfa935e6aa1932ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all supported synchronization settings available on the device.  <a href="#aef5003fb23821cf7dfa935e6aa1932ab">More...</a><br /></td></tr>
<tr class="separator:aef5003fb23821cf7dfa935e6aa1932ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71743a68785ec3af6c5c5763a69aca62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a71743a68785ec3af6c5c5763a69aca62">gotoMeasurement</a> (void)</td></tr>
<tr class="memdesc:a71743a68785ec3af6c5c5763a69aca62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put this device in measurement mode.  <a href="#a71743a68785ec3af6c5c5763a69aca62">More...</a><br /></td></tr>
<tr class="separator:a71743a68785ec3af6c5c5763a69aca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec3280fe994031d49975f99300ee5bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9ec3280fe994031d49975f99300ee5bb">gotoConfig</a> (void)</td></tr>
<tr class="memdesc:a9ec3280fe994031d49975f99300ee5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in config mode.  <a href="#a9ec3280fe994031d49975f99300ee5bb">More...</a><br /></td></tr>
<tr class="separator:a9ec3280fe994031d49975f99300ee5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7460d11e20d33afc13d828af958e32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afa7460d11e20d33afc13d828af958e32">restoreFactoryDefaults</a> (void)</td></tr>
<tr class="memdesc:afa7460d11e20d33afc13d828af958e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the device to its factory default settings.  <a href="#afa7460d11e20d33afc13d828af958e32">More...</a><br /></td></tr>
<tr class="separator:afa7460d11e20d33afc13d828af958e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac673fd524d04468c0d9c1eca12c59c49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac673fd524d04468c0d9c1eca12c59c49">reset</a> (void)</td></tr>
<tr class="memdesc:ac673fd524d04468c0d9c1eca12c59c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the device.  <a href="#ac673fd524d04468c0d9c1eca12c59c49">More...</a><br /></td></tr>
<tr class="separator:ac673fd524d04468c0d9c1eca12c59c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d8c44453e80d1c9fa2efc30062cd79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48d8c44453e80d1c9fa2efc30062cd79">reopenPort</a> (bool <a class="el" href="struct_xs_device.html#a9ec3280fe994031d49975f99300ee5bb">gotoConfig</a>, bool skipDeviceIdCheck=false)</td></tr>
<tr class="memdesc:a48d8c44453e80d1c9fa2efc30062cd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens a port Uses rescan method to redetect a device. Also if USB descriptor has changed.  <a href="#a48d8c44453e80d1c9fa2efc30062cd79">More...</a><br /></td></tr>
<tr class="separator:a48d8c44453e80d1c9fa2efc30062cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723430c9c1617967bacc8f308e15a45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab723430c9c1617967bacc8f308e15a45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab723430c9c1617967bacc8f308e15a45">writeDeviceSettingsToFile</a> (void)</td></tr>
<tr class="memdesc:ab723430c9c1617967bacc8f308e15a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the emts/wms/xms of the device and all its children to the open logfile. <br /></td></tr>
<tr class="separator:ab723430c9c1617967bacc8f308e15a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe67be34b9a34bdad40a155e81a3698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe67be34b9a34bdad40a155e81a3698"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8fe67be34b9a34bdad40a155e81a3698">flushInputBuffers</a> (void)</td></tr>
<tr class="memdesc:a8fe67be34b9a34bdad40a155e81a3698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of the device. <br /></td></tr>
<tr class="separator:a8fe67be34b9a34bdad40a155e81a3698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2e45b77febc07c6355da108759528d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3d2e45b77febc07c6355da108759528d">syncRole</a> (void) const </td></tr>
<tr class="memdesc:a3d2e45b77febc07c6355da108759528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the synchronization role of the device.  <a href="#a3d2e45b77febc07c6355da108759528d">More...</a><br /></td></tr>
<tr class="separator:a3d2e45b77febc07c6355da108759528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f7981d180616368a61f6d16bfafa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad37f7981d180616368a61f6d16bfafa6">loadLogFile</a> (void)</td></tr>
<tr class="memdesc:ad37f7981d180616368a61f6d16bfafa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a complete logfile.  <a href="#ad37f7981d180616368a61f6d16bfafa6">More...</a><br /></td></tr>
<tr class="separator:ad37f7981d180616368a61f6d16bfafa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2448f25505c27fee9ecab1853edb3793"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2448f25505c27fee9ecab1853edb3793">abortLoadLogFile</a> (void)</td></tr>
<tr class="memdesc:a2448f25505c27fee9ecab1853edb3793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts loading a logfile.  <a href="#a2448f25505c27fee9ecab1853edb3793">More...</a><br /></td></tr>
<tr class="separator:a2448f25505c27fee9ecab1853edb3793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d05ca61eeac4922d5b2e9f781e6595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa5d05ca61eeac4922d5b2e9f781e6595">logFileName</a> (void) const </td></tr>
<tr class="memdesc:aa5d05ca61eeac4922d5b2e9f781e6595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the log file the device is reading from.  <a href="#aa5d05ca61eeac4922d5b2e9f781e6595">More...</a><br /></td></tr>
<tr class="separator:aa5d05ca61eeac4922d5b2e9f781e6595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeafc3cb53243db1aaea7213002d42c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3aeafc3cb53243db1aaea7213002d42c">resetOrientation</a> (<a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a> resetmethod)</td></tr>
<tr class="memdesc:a3aeafc3cb53243db1aaea7213002d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an orientation reset on the device using the given <em>resetMethod</em>.  <a href="#a3aeafc3cb53243db1aaea7213002d42c">More...</a><br /></td></tr>
<tr class="separator:a3aeafc3cb53243db1aaea7213002d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454a6e78a01a27e4c59619bd84da972d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a454a6e78a01a27e4c59619bd84da972d">resetLogFileReadPosition</a> (void)</td></tr>
<tr class="memdesc:a454a6e78a01a27e4c59619bd84da972d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read position of the open log file to the start of the file.  <a href="#a454a6e78a01a27e4c59619bd84da972d">More...</a><br /></td></tr>
<tr class="separator:a454a6e78a01a27e4c59619bd84da972d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb33bc239ad3ff9b05f57c8bba205e43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aeb33bc239ad3ff9b05f57c8bba205e43">logFileSize</a> (void) const </td></tr>
<tr class="memdesc:aeb33bc239ad3ff9b05f57c8bba205e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the log file the device is reading from.  <a href="#aeb33bc239ad3ff9b05f57c8bba205e43">More...</a><br /></td></tr>
<tr class="separator:aeb33bc239ad3ff9b05f57c8bba205e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d157341846d031ae8d8a85f174a59c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1d157341846d031ae8d8a85f174a59c2">logFileReadPosition</a> (void) const </td></tr>
<tr class="memdesc:a1d157341846d031ae8d8a85f174a59c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current read position of the open log file.  <a href="#a1d157341846d031ae8d8a85f174a59c2">More...</a><br /></td></tr>
<tr class="separator:a1d157341846d031ae8d8a85f174a59c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c88b3662ef409e1e3585e131106786"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a20c88b3662ef409e1e3585e131106786">updateCachedDeviceInformation</a> (void)</td></tr>
<tr class="memdesc:a20c88b3662ef409e1e3585e131106786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cached device information for all devices connected to this port.  <a href="#a20c88b3662ef409e1e3585e131106786">More...</a><br /></td></tr>
<tr class="separator:a20c88b3662ef409e1e3585e131106786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026c49500ad437124d9d4f3d8734f6d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9">enableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:a026c49500ad437124d9d4f3d8734f6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an additional communication protocol when reading messages.  <a href="#a026c49500ad437124d9d4f3d8734f6d9">More...</a><br /></td></tr>
<tr class="separator:a026c49500ad437124d9d4f3d8734f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a12cb16caa27b67d8c5e6b6f534acb5f4">disableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9" title="Enable an additional communication protocol when reading messages. ">XsDevice::enableProtocol</a>.  <a href="#a12cb16caa27b67d8c5e6b6f534acb5f4">More...</a><br /></td></tr>
<tr class="separator:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda57eca1b67c459bb0aa44f9c3130fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aeda57eca1b67c459bb0aa44f9c3130fe">isProtocolEnabled</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol) const </td></tr>
<tr class="separator:aeda57eca1b67c459bb0aa44f9c3130fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94af58c8654c885d6e343df3f8ed36be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a94af58c8654c885d6e343df3f8ed36be">deviceBufferSize</a> (void)</td></tr>
<tr class="memdesc:a94af58c8654c885d6e343df3f8ed36be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the size of the interal buffer.  <a href="#a94af58c8654c885d6e343df3f8ed36be">More...</a><br /></td></tr>
<tr class="separator:a94af58c8654c885d6e343df3f8ed36be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf52735776e76c08aeb22e24b7bf78d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acbf52735776e76c08aeb22e24b7bf78d">setDeviceBufferSize</a> (uint32_t frames)</td></tr>
<tr class="memdesc:acbf52735776e76c08aeb22e24b7bf78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the device to set it's internal buffer to the specified size.  <a href="#acbf52735776e76c08aeb22e24b7bf78d">More...</a><br /></td></tr>
<tr class="separator:acbf52735776e76c08aeb22e24b7bf78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71818f49389dba396fa88140837354a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab71818f49389dba396fa88140837354a">connectivityState</a> (void) const </td></tr>
<tr class="memdesc:ab71818f49389dba396fa88140837354a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connectivity state of the device.  <a href="#ab71818f49389dba396fa88140837354a">More...</a><br /></td></tr>
<tr class="separator:ab71818f49389dba396fa88140837354a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a17bae6b2155db46cb690c474c35dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af5a17bae6b2155db46cb690c474c35dd">waitForAllDevicesInitialized</a> (void)</td></tr>
<tr class="memdesc:af5a17bae6b2155db46cb690c474c35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until are known devices are initialized.  <a href="#af5a17bae6b2155db46cb690c474c35dd">More...</a><br /></td></tr>
<tr class="separator:af5a17bae6b2155db46cb690c474c35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d819fca52a6ce5d192bbe8aab9360a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a02d819fca52a6ce5d192bbe8aab9360a">children</a> (void) const </td></tr>
<tr class="memdesc:a02d819fca52a6ce5d192bbe8aab9360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a managed array containing the child-devices this device has. For standalone devices this is always an empty array.  <a href="#a02d819fca52a6ce5d192bbe8aab9360a">More...</a><br /></td></tr>
<tr class="separator:a02d819fca52a6ce5d192bbe8aab9360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574ca4074faf41de90fed078414d1022"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a574ca4074faf41de90fed078414d1022">childCount</a> (void) const </td></tr>
<tr class="memdesc:a574ca4074faf41de90fed078414d1022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of child-devices this device has. For standalone devices this is always 0.  <a href="#a574ca4074faf41de90fed078414d1022">More...</a><br /></td></tr>
<tr class="separator:a574ca4074faf41de90fed078414d1022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af0dcccddf838764795b169213a9af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a24af0dcccddf838764795b169213a9af">enableRadio</a> (int channel)</td></tr>
<tr class="memdesc:a24af0dcccddf838764795b169213a9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio channel to use for wireless communication.  <a href="#a24af0dcccddf838764795b169213a9af">More...</a><br /></td></tr>
<tr class="separator:a24af0dcccddf838764795b169213a9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e631a78e1eb13b2068f3aacf02f8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa45e631a78e1eb13b2068f3aacf02f8e">disableRadio</a> (void)</td></tr>
<tr class="memdesc:aa45e631a78e1eb13b2068f3aacf02f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the radio for this station, resetting all children to disconnected state.  <a href="#aa45e631a78e1eb13b2068f3aacf02f8e">More...</a><br /></td></tr>
<tr class="separator:aa45e631a78e1eb13b2068f3aacf02f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6565430d6bf14d48a999bd0c11d19cdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6565430d6bf14d48a999bd0c11d19cdc">radioChannel</a> (void) const </td></tr>
<tr class="memdesc:a6565430d6bf14d48a999bd0c11d19cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radio channel used for wireless communication.  <a href="#a6565430d6bf14d48a999bd0c11d19cdc">More...</a><br /></td></tr>
<tr class="separator:a6565430d6bf14d48a999bd0c11d19cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49332ef50f311204a3a8ac64d91a3cc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a49332ef50f311204a3a8ac64d91a3cc0">isRadioEnabled</a> (void) const </td></tr>
<tr class="memdesc:a49332ef50f311204a3a8ac64d91a3cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the radio is enabled.  <a href="#a49332ef50f311204a3a8ac64d91a3cc0">More...</a><br /></td></tr>
<tr class="separator:a49332ef50f311204a3a8ac64d91a3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67501a215db1bfabcf9f9720648dcbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa67501a215db1bfabcf9f9720648dcbc">makeOperational</a> (void)</td></tr>
<tr class="memdesc:aa67501a215db1bfabcf9f9720648dcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Awinda station to operational state.  <a href="#aa67501a215db1bfabcf9f9720648dcbc">More...</a><br /></td></tr>
<tr class="separator:aa67501a215db1bfabcf9f9720648dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8442e17e67e191cebd498c7e1c26228"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad8442e17e67e191cebd498c7e1c26228">isOperational</a> (void) const </td></tr>
<tr class="separator:ad8442e17e67e191cebd498c7e1c26228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cc00568e74c3d1e8bd0aef10382635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa6cc00568e74c3d1e8bd0aef10382635">isInSyncStationMode</a> (void)</td></tr>
<tr class="separator:aa6cc00568e74c3d1e8bd0aef10382635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43b42d6bab3640389ba5936cbd5aaa4d">setSyncStationMode</a> (bool enabled)</td></tr>
<tr class="memdesc:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Sync Station mode of the Awinda Station device.  <a href="#a43b42d6bab3640389ba5936cbd5aaa4d">More...</a><br /></td></tr>
<tr class="separator:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8fee3beab14ee2e2f083eed710be28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2c8fee3beab14ee2e2f083eed710be28">stealthMode</a> (void) const </td></tr>
<tr class="memdesc:a2c8fee3beab14ee2e2f083eed710be28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of the stealth mode setting.  <a href="#a2c8fee3beab14ee2e2f083eed710be28">More...</a><br /></td></tr>
<tr class="separator:a2c8fee3beab14ee2e2f083eed710be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6d31de9b2703f3f28451413b047cde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1b6d31de9b2703f3f28451413b047cde">setStealthMode</a> (bool enabled)</td></tr>
<tr class="memdesc:a1b6d31de9b2703f3f28451413b047cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable stealth mode.  <a href="#a1b6d31de9b2703f3f28451413b047cde">More...</a><br /></td></tr>
<tr class="separator:a1b6d31de9b2703f3f28451413b047cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9a63a1bc2d1424df962f81bbcf8977bb">discardRetransmissions</a> (int64_t firstNewPacketId)</td></tr>
<tr class="memdesc:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell XDA and the device that any data from before <em>firstNewPacketId</em> may be lossy.  <a href="#a9a63a1bc2d1424df962f81bbcf8977bb">More...</a><br /></td></tr>
<tr class="separator:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8814eb53ad1756d5ab49b4b35fc7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a82b8814eb53ad1756d5ab49b4b35fc7c">abortFlushing</a> (void)</td></tr>
<tr class="memdesc:a82b8814eb53ad1756d5ab49b4b35fc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the wireless flushing operation and finalize the recording.  <a href="#a82b8814eb53ad1756d5ab49b4b35fc7c">More...</a><br /></td></tr>
<tr class="separator:a82b8814eb53ad1756d5ab49b4b35fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2fa1b5a95fc6cae2b3b661936dc79670">setDeviceAccepted</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>)</td></tr>
<tr class="memdesc:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a device.  <a href="#a2fa1b5a95fc6cae2b3b661936dc79670">More...</a><br /></td></tr>
<tr class="separator:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cddf966e39a4abacb0bc279e31ffdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a16cddf966e39a4abacb0bc279e31ffdf">setDeviceRejected</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>)</td></tr>
<tr class="memdesc:a16cddf966e39a4abacb0bc279e31ffdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects a device.  <a href="#a16cddf966e39a4abacb0bc279e31ffdf">More...</a><br /></td></tr>
<tr class="separator:a16cddf966e39a4abacb0bc279e31ffdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf">setAccessControlMode</a> (<a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a> mode, const <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> &amp;initialList)</td></tr>
<tr class="memdesc:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access control mode of the master device.  <a href="#ac620eb9326e9c98fdd82dd597cf39cbf">More...</a><br /></td></tr>
<tr class="separator:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1947781609b90542a9496ad371a2e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae1947781609b90542a9496ad371a2e47">accessControlMode</a> (void) const </td></tr>
<tr class="memdesc:ae1947781609b90542a9496ad371a2e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the access control mode of the master device.  <a href="#ae1947781609b90542a9496ad371a2e47">More...</a><br /></td></tr>
<tr class="separator:ae1947781609b90542a9496ad371a2e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fb0f69cf51ea4014dd4c0cb852d6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a51fb0f69cf51ea4014dd4c0cb852d6e4">currentAccessControlList</a> (void) const </td></tr>
<tr class="memdesc:a51fb0f69cf51ea4014dd4c0cb852d6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the access control list of the master device.  <a href="#a51fb0f69cf51ea4014dd4c0cb852d6e4">More...</a><br /></td></tr>
<tr class="separator:a51fb0f69cf51ea4014dd4c0cb852d6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd6151790a88275589be880b1aac8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abcd6151790a88275589be880b1aac8ec">setDeviceParameter</a> (const <a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;parameter)</td></tr>
<tr class="memdesc:abcd6151790a88275589be880b1aac8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given parameter for the device.  <a href="#abcd6151790a88275589be880b1aac8ec">More...</a><br /></td></tr>
<tr class="separator:abcd6151790a88275589be880b1aac8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a76cfeac115b80bd9e879838dbfd0ef6f">deviceParameter</a> (<a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;parameter) const </td></tr>
<tr class="memdesc:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the requested parameter's current value.  <a href="#a76cfeac115b80bd9e879838dbfd0ef6f">More...</a><br /></td></tr>
<tr class="separator:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac973b8c1f4bfba660480fc219ef599d0"><td class="memItemLeft" align="right" valign="top">XsGnssPlatform&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac973b8c1f4bfba660480fc219ef599d0">gnssPlatform</a> (void) const </td></tr>
<tr class="memdesc:ac973b8c1f4bfba660480fc219ef599d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device GNSS platform.  <a href="#ac973b8c1f4bfba660480fc219ef599d0">More...</a><br /></td></tr>
<tr class="separator:ac973b8c1f4bfba660480fc219ef599d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220f5fa69008190200f3845dd464f9f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a220f5fa69008190200f3845dd464f9f9">setGnssPlatform</a> (XsGnssPlatform <a class="el" href="struct_xs_device.html#ac973b8c1f4bfba660480fc219ef599d0">gnssPlatform</a>)</td></tr>
<tr class="memdesc:a220f5fa69008190200f3845dd464f9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device GNSS platform.  <a href="#a220f5fa69008190200f3845dd464f9f9">More...</a><br /></td></tr>
<tr class="separator:a220f5fa69008190200f3845dd464f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbcc97e51468bdc61bdc51f322a3f56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afdbcc97e51468bdc61bdc51f322a3f56">acceptConnection</a> (void)</td></tr>
<tr class="memdesc:afdbcc97e51468bdc61bdc51f322a3f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connections from the device on the parent/master device.  <a href="#afdbcc97e51468bdc61bdc51f322a3f56">More...</a><br /></td></tr>
<tr class="separator:afdbcc97e51468bdc61bdc51f322a3f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d22f8e3befaee56238d516859e138d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a33d22f8e3befaee56238d516859e138d">rejectConnection</a> (void)</td></tr>
<tr class="memdesc:a33d22f8e3befaee56238d516859e138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject connections from the device on the parent/master device.  <a href="#a33d22f8e3befaee56238d516859e138d">More...</a><br /></td></tr>
<tr class="separator:a33d22f8e3befaee56238d516859e138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ccd0f755dda5966d94421036d51bcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a98ccd0f755dda5966d94421036d51bcb">wirelessPriority</a> (void) const </td></tr>
<tr class="memdesc:a98ccd0f755dda5966d94421036d51bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wireless priority of the device.  <a href="#a98ccd0f755dda5966d94421036d51bcb">More...</a><br /></td></tr>
<tr class="separator:a98ccd0f755dda5966d94421036d51bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5777d11869ea81ba031387a00eecc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2b5777d11869ea81ba031387a00eecc2">setWirelessPriority</a> (int priority)</td></tr>
<tr class="memdesc:a2b5777d11869ea81ba031387a00eecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wireless priority of the device.  <a href="#a2b5777d11869ea81ba031387a00eecc2">More...</a><br /></td></tr>
<tr class="separator:a2b5777d11869ea81ba031387a00eecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0756862440ae1099a5b9ff2f8927034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af0756862440ae1099a5b9ff2f8927034">rejectReason</a> (void) const </td></tr>
<tr class="memdesc:af0756862440ae1099a5b9ff2f8927034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason why a device's connection was rejected.  <a href="#af0756862440ae1099a5b9ff2f8927034">More...</a><br /></td></tr>
<tr class="separator:af0756862440ae1099a5b9ff2f8927034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d4a15dcb2fcc76deddaf44461a77e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a44d4a15dcb2fcc76deddaf44461a77e9">requestBatteryLevel</a> (void)</td></tr>
<tr class="memdesc:a44d4a15dcb2fcc76deddaf44461a77e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the battery level from the device.  <a href="#a44d4a15dcb2fcc76deddaf44461a77e9">More...</a><br /></td></tr>
<tr class="separator:a44d4a15dcb2fcc76deddaf44461a77e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba9b53c6eff4c39a1bd07901a347694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5ba9b53c6eff4c39a1bd07901a347694">batteryLevelTime</a> (void)</td></tr>
<tr class="memdesc:a5ba9b53c6eff4c39a1bd07901a347694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the time the battery level was last updated.  <a href="#a5ba9b53c6eff4c39a1bd07901a347694">More...</a><br /></td></tr>
<tr class="separator:a5ba9b53c6eff4c39a1bd07901a347694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01256f48cf926440c226c91fadc72ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a01256f48cf926440c226c91fadc72ab8">setTransportMode</a> (bool transportModeEnabled)</td></tr>
<tr class="memdesc:a01256f48cf926440c226c91fadc72ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the transport mode for the device.  <a href="#a01256f48cf926440c226c91fadc72ab8">More...</a><br /></td></tr>
<tr class="separator:a01256f48cf926440c226c91fadc72ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ba89f3f793404227f9786ff57abe05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a54ba89f3f793404227f9786ff57abe05">transportMode</a> (void)</td></tr>
<tr class="memdesc:a54ba89f3f793404227f9786ff57abe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the transport mode feature.  <a href="#a54ba89f3f793404227f9786ff57abe05">More...</a><br /></td></tr>
<tr class="separator:a54ba89f3f793404227f9786ff57abe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1978013d5857f966f21443c87720fa75"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1978013d5857f966f21443c87720fa75">lastKnownRssi</a> (void) const </td></tr>
<tr class="memdesc:a1978013d5857f966f21443c87720fa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last known RSSI value of the device.  <a href="#a1978013d5857f966f21443c87720fa75">More...</a><br /></td></tr>
<tr class="separator:a1978013d5857f966f21443c87720fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4197ecec22e67822a53909b27c2e04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6a4197ecec22e67822a53909b27c2e04">packetErrorRate</a> (void) const </td></tr>
<tr class="memdesc:a6a4197ecec22e67822a53909b27c2e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet error rate for the for the device.  <a href="#a6a4197ecec22e67822a53909b27c2e04">More...</a><br /></td></tr>
<tr class="separator:a6a4197ecec22e67822a53909b27c2e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fa6614d94f6ec21f8c4e831e9736af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab3fa6614d94f6ec21f8c4e831e9736af">isBlueToothEnabled</a> (void) const </td></tr>
<tr class="memdesc:ab3fa6614d94f6ec21f8c4e831e9736af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device has its BlueTooth radio enabled.  <a href="#ab3fa6614d94f6ec21f8c4e831e9736af">More...</a><br /></td></tr>
<tr class="separator:ab3fa6614d94f6ec21f8c4e831e9736af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99583e7e3b8be3c0f70454ebbf885afd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a99583e7e3b8be3c0f70454ebbf885afd">setBlueToothEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a99583e7e3b8be3c0f70454ebbf885afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device.  <a href="#a99583e7e3b8be3c0f70454ebbf885afd">More...</a><br /></td></tr>
<tr class="separator:a99583e7e3b8be3c0f70454ebbf885afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bdcbad1f87cf5ae864df727832bf8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a23bdcbad1f87cf5ae864df727832bf8f">isBusPowerEnabled</a> (void) const </td></tr>
<tr class="memdesc:a23bdcbad1f87cf5ae864df727832bf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Xbus is powering its child devices or not.  <a href="#a23bdcbad1f87cf5ae864df727832bf8f">More...</a><br /></td></tr>
<tr class="separator:a23bdcbad1f87cf5ae864df727832bf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af6b8c2b18ad882c64b0ff3b7ad89655d">setBusPowerEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the Xbus to provide power to its child devices or not.  <a href="#af6b8c2b18ad882c64b0ff3b7ad89655d">More...</a><br /></td></tr>
<tr class="separator:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9999b40fd7bd300c1f17f6517fe8d05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac9999b40fd7bd300c1f17f6517fe8d05">powerDown</a> (void)</td></tr>
<tr class="memdesc:ac9999b40fd7bd300c1f17f6517fe8d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the device to power down completely.  <a href="#ac9999b40fd7bd300c1f17f6517fe8d05">More...</a><br /></td></tr>
<tr class="separator:ac9999b40fd7bd300c1f17f6517fe8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af016f3da4aa7b43d19250080ff406875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af016f3da4aa7b43d19250080ff406875">errorMode</a> (void) const </td></tr>
<tr class="memdesc:af016f3da4aa7b43d19250080ff406875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error mode of the device.  <a href="#af016f3da4aa7b43d19250080ff406875">More...</a><br /></td></tr>
<tr class="separator:af016f3da4aa7b43d19250080ff406875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a91f03a8e30b52e38cebb8bfc3e6a7573">setErrorMode</a> (<a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> errormode)</td></tr>
<tr class="memdesc:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error mode of the device.  <a href="#a91f03a8e30b52e38cebb8bfc3e6a7573">More...</a><br /></td></tr>
<tr class="separator:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e374050eb6373033799b6a3acb9d61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61">setHeadingOffset</a> (double offset)</td></tr>
<tr class="memdesc:a25e374050eb6373033799b6a3acb9d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'heading offset' setting of the device.  <a href="#a25e374050eb6373033799b6a3acb9d61">More...</a><br /></td></tr>
<tr class="separator:a25e374050eb6373033799b6a3acb9d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbb7550a81f66470d36f9b87e7b3374"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7cbb7550a81f66470d36f9b87e7b3374">headingOffset</a> (void) const </td></tr>
<tr class="memdesc:a7cbb7550a81f66470d36f9b87e7b3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 'heading offset' setting of the device.  <a href="#a7cbb7550a81f66470d36f9b87e7b3374">More...</a><br /></td></tr>
<tr class="separator:a7cbb7550a81f66470d36f9b87e7b3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d6968b26addd3da277435a0fbec82a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a89d6968b26addd3da277435a0fbec82a">setLocationId</a> (int id)</td></tr>
<tr class="memdesc:a89d6968b26addd3da277435a0fbec82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location ID of the device.  <a href="#a89d6968b26addd3da277435a0fbec82a">More...</a><br /></td></tr>
<tr class="separator:a89d6968b26addd3da277435a0fbec82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf71b3c0e24ebcf579d7371ee87cb54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5cf71b3c0e24ebcf579d7371ee87cb54">locationId</a> (void) const </td></tr>
<tr class="memdesc:a5cf71b3c0e24ebcf579d7371ee87cb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location ID of the device.  <a href="#a5cf71b3c0e24ebcf579d7371ee87cb54">More...</a><br /></td></tr>
<tr class="separator:a5cf71b3c0e24ebcf579d7371ee87cb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551c9cc98da43c7953f01d412ecb986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3551c9cc98da43c7953f01d412ecb986">getDeviceFromLocationId</a> (uint16_t locId)</td></tr>
<tr class="memdesc:a3551c9cc98da43c7953f01d412ecb986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device given <em>locId</em>.  <a href="#a3551c9cc98da43c7953f01d412ecb986">More...</a><br /></td></tr>
<tr class="separator:a3551c9cc98da43c7953f01d412ecb986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf256a32a1009d3181b291ca147c71f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abf256a32a1009d3181b291ca147c71f9">objectAlignment</a> (void) const </td></tr>
<tr class="memdesc:abf256a32a1009d3181b291ca147c71f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object alignment matrix of the device.  <a href="#abf256a32a1009d3181b291ca147c71f9">More...</a><br /></td></tr>
<tr class="separator:abf256a32a1009d3181b291ca147c71f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3bbd3c53640d1f34d3990fe6349a4a40">setObjectAlignment</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the object alignment of the device to the given <em>matrix</em>.  <a href="#a3bbd3c53640d1f34d3990fe6349a4a40">More...</a><br /></td></tr>
<tr class="separator:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98b0d4146b969af649c8008ed471d19"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa98b0d4146b969af649c8008ed471d19">gravityMagnitude</a> (void) const </td></tr>
<tr class="memdesc:aa98b0d4146b969af649c8008ed471d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Gravity Magnitude' of the device.  <a href="#aa98b0d4146b969af649c8008ed471d19">More...</a><br /></td></tr>
<tr class="separator:aa98b0d4146b969af649c8008ed471d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aecf0f050da7d709d73917ece872436"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436">setGravityMagnitude</a> (double mag)</td></tr>
<tr class="memdesc:a1aecf0f050da7d709d73917ece872436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>.  <a href="#a1aecf0f050da7d709d73917ece872436">More...</a><br /></td></tr>
<tr class="separator:a1aecf0f050da7d709d73917ece872436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81dc4dc4e31b9b7bf0a9e67a1139af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_vector.html">XsVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa81dc4dc4e31b9b7bf0a9e67a1139af6">initialPositionLLA</a> (void) const </td></tr>
<tr class="memdesc:aa81dc4dc4e31b9b7bf0a9e67a1139af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'Latitude Longitude Altitude' setting of the device.  <a href="#aa81dc4dc4e31b9b7bf0a9e67a1139af6">More...</a><br /></td></tr>
<tr class="separator:aa81dc4dc4e31b9b7bf0a9e67a1139af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de8e64303b89c2603f21f1040de71b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6">setInitialPositionLLA</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a2de8e64303b89c2603f21f1040de71b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>.  <a href="#a2de8e64303b89c2603f21f1040de71b6">More...</a><br /></td></tr>
<tr class="separator:a2de8e64303b89c2603f21f1040de71b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8314ecf10e85e01c0f140749cd4fde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_time_info.html">XsTimeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab8314ecf10e85e01c0f140749cd4fde6">utcTime</a> (void) const </td></tr>
<tr class="memdesc:ab8314ecf10e85e01c0f140749cd4fde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'UTC Time' setting of the device.  <a href="#ab8314ecf10e85e01c0f140749cd4fde6">More...</a><br /></td></tr>
<tr class="separator:ab8314ecf10e85e01c0f140749cd4fde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96019db07120f4c50b7d50fda4201a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af96019db07120f4c50b7d50fda4201a0">setUtcTime</a> (const <a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> &amp;time)</td></tr>
<tr class="memdesc:af96019db07120f4c50b7d50fda4201a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'UTC Time' setting of the device to the given <em>time</em>.  <a href="#af96019db07120f4c50b7d50fda4201a0">More...</a><br /></td></tr>
<tr class="separator:af96019db07120f4c50b7d50fda4201a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdb2c03d2f9188cbbcf47e9bc0b933f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3cdb2c03d2f9188cbbcf47e9bc0b933f">reinitialize</a> (void)</td></tr>
<tr class="memdesc:a3cdb2c03d2f9188cbbcf47e9bc0b933f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>.  <a href="#a3cdb2c03d2f9188cbbcf47e9bc0b933f">More...</a><br /></td></tr>
<tr class="separator:a3cdb2c03d2f9188cbbcf47e9bc0b933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07ca5fae0138ecb9067ad5c7ec13b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac07ca5fae0138ecb9067ad5c7ec13b5d">xdaFilterProfile</a> (void) const </td></tr>
<tr class="memdesc:ac07ca5fae0138ecb9067ad5c7ec13b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use for computing orientations on the host PC.  <a href="#ac07ca5fae0138ecb9067ad5c7ec13b5d">More...</a><br /></td></tr>
<tr class="separator:ac07ca5fae0138ecb9067ad5c7ec13b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d32dca25c36ce8a6a65fa8767b8049"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049">setXdaFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:a89d32dca25c36ce8a6a65fa8767b8049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.  <a href="#a89d32dca25c36ce8a6a65fa8767b8049">More...</a><br /></td></tr>
<tr class="separator:a89d32dca25c36ce8a6a65fa8767b8049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36567f3a21009b64a26346536576c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1d36567f3a21009b64a26346536576c1">setXdaFilterProfile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;profileType)</td></tr>
<tr class="memdesc:a1d36567f3a21009b64a26346536576c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.  <a href="#a1d36567f3a21009b64a26346536576c1">More...</a><br /></td></tr>
<tr class="separator:a1d36567f3a21009b64a26346536576c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceb6039061b54469e5185b740f0726c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3ceb6039061b54469e5185b740f0726c">onboardFilterProfile</a> (void) const </td></tr>
<tr class="memdesc:a3ceb6039061b54469e5185b740f0726c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use by the device for computing orientations.  <a href="#a3ceb6039061b54469e5185b740f0726c">More...</a><br /></td></tr>
<tr class="separator:a3ceb6039061b54469e5185b740f0726c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf">setOnboardFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.  <a href="#a104c62ce2ddaaef1d82bb68fb8e83ddf">More...</a><br /></td></tr>
<tr class="separator:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3f3c7d902009957b60348047972ca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ade3f3c7d902009957b60348047972ca6">setOnboardFilterProfile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;profileType)</td></tr>
<tr class="memdesc:ade3f3c7d902009957b60348047972ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.  <a href="#ade3f3c7d902009957b60348047972ca6">More...</a><br /></td></tr>
<tr class="separator:ade3f3c7d902009957b60348047972ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293cd63b511ab11a8a02aadd306e348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3293cd63b511ab11a8a02aadd306e348">replaceFilterProfile</a> (const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;profileCurrent, const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;profileNew)</td></tr>
<tr class="memdesc:a3293cd63b511ab11a8a02aadd306e348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces profileCurrent by profileNew in the device.  <a href="#a3293cd63b511ab11a8a02aadd306e348">More...</a><br /></td></tr>
<tr class="separator:a3293cd63b511ab11a8a02aadd306e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d818db7d23b4fcde4e7ac3813674d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d">availableOnboardFilterProfiles</a> (void) const </td></tr>
<tr class="memdesc:abe9d818db7d23b4fcde4e7ac3813674d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the device.  <a href="#abe9d818db7d23b4fcde4e7ac3813674d">More...</a><br /></td></tr>
<tr class="separator:abe9d818db7d23b4fcde4e7ac3813674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e0762821a17597317428ef1877abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe">availableXdaFilterProfiles</a> (void) const </td></tr>
<tr class="memdesc:abc2e0762821a17597317428ef1877abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the host PC.  <a href="#abc2e0762821a17597317428ef1877abe">More...</a><br /></td></tr>
<tr class="separator:abc2e0762821a17597317428ef1877abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7459738f46fd70e231eb268cc32906"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1c7459738f46fd70e231eb268cc32906">accelerometerRange</a> (void) const </td></tr>
<tr class="memdesc:a1c7459738f46fd70e231eb268cc32906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the accelerometers in the device.  <a href="#a1c7459738f46fd70e231eb268cc32906">More...</a><br /></td></tr>
<tr class="separator:a1c7459738f46fd70e231eb268cc32906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a0a2759350a42cf70d38cce2e81ccc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad1a0a2759350a42cf70d38cce2e81ccc">gyroscopeRange</a> (void) const </td></tr>
<tr class="memdesc:ad1a0a2759350a42cf70d38cce2e81ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the gyroscopes in the device.  <a href="#ad1a0a2759350a42cf70d38cce2e81ccc">More...</a><br /></td></tr>
<tr class="separator:ad1a0a2759350a42cf70d38cce2e81ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3340a175cded1e16f4e5c87e7a6709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709">setNoRotation</a> (uint16_t duration)</td></tr>
<tr class="memdesc:adf3340a175cded1e16f4e5c87e7a6709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the no rotation period to <em>duration</em>.  <a href="#adf3340a175cded1e16f4e5c87e7a6709">More...</a><br /></td></tr>
<tr class="separator:adf3340a175cded1e16f4e5c87e7a6709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2336973e3f39f60485823043d788fe12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2336973e3f39f60485823043d788fe12">startRepresentativeMotion</a> (void)</td></tr>
<tr class="memdesc:a2336973e3f39f60485823043d788fe12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the user indicate that he is starting the representative motion for the In-Run Compass Calibration.  <a href="#a2336973e3f39f60485823043d788fe12">More...</a><br /></td></tr>
<tr class="separator:a2336973e3f39f60485823043d788fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9152c38978172f78379fad1ca867653d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9152c38978172f78379fad1ca867653d">representativeMotionState</a> (void)</td></tr>
<tr class="memdesc:a9152c38978172f78379fad1ca867653d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the active representative motion state for the In-Run Compass Calibration.  <a href="#a9152c38978172f78379fad1ca867653d">More...</a><br /></td></tr>
<tr class="separator:a9152c38978172f78379fad1ca867653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258ca251ee2c6ef201401962a8e7fcde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_icc_rep_motion_result.html">XsIccRepMotionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a258ca251ee2c6ef201401962a8e7fcde">stopRepresentativeMotion</a> (void)</td></tr>
<tr class="memdesc:a258ca251ee2c6ef201401962a8e7fcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the user indicate that he stopped the representative motion.  <a href="#a258ca251ee2c6ef201401962a8e7fcde">More...</a><br /></td></tr>
<tr class="separator:a258ca251ee2c6ef201401962a8e7fcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1519cb9c51faf87613bf6e0809c60c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad1519cb9c51faf87613bf6e0809c60c1">storeIccResults</a> (void)</td></tr>
<tr class="memdesc:ad1519cb9c51faf87613bf6e0809c60c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the onboard ICC results for use by the device.  <a href="#ad1519cb9c51faf87613bf6e0809c60c1">More...</a><br /></td></tr>
<tr class="separator:ad1519cb9c51faf87613bf6e0809c60c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9236fcd28b24a4928faaa958b4a0eae"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa9236fcd28b24a4928faaa958b4a0eae">rs485TransmissionDelay</a> (void) const </td></tr>
<tr class="memdesc:aa9236fcd28b24a4928faaa958b4a0eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transmission delay used for RS485 transmissions.  <a href="#aa9236fcd28b24a4928faaa958b4a0eae">More...</a><br /></td></tr>
<tr class="separator:aa9236fcd28b24a4928faaa958b4a0eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba7004a5136186128bc156db997a359"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5ba7004a5136186128bc156db997a359">setRs485TransmissionDelay</a> (uint16_t delay)</td></tr>
<tr class="memdesc:a5ba7004a5136186128bc156db997a359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission delay used for RS485 transmissions.  <a href="#a5ba7004a5136186128bc156db997a359">More...</a><br /></td></tr>
<tr class="separator:a5ba7004a5136186128bc156db997a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b6c4ac8b4d23b50c72d323831136b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab46b6c4ac8b4d23b50c72d323831136b">runSelfTest</a> (void)</td></tr>
<tr class="memdesc:ab46b6c4ac8b4d23b50c72d323831136b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the self test for the device.  <a href="#ab46b6c4ac8b4d23b50c72d323831136b">More...</a><br /></td></tr>
<tr class="separator:ab46b6c4ac8b4d23b50c72d323831136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2c57c8b14647bde28bf31ee30ca7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a39c2c57c8b14647bde28bf31ee30ca7f">requestData</a> (void)</td></tr>
<tr class="memdesc:a39c2c57c8b14647bde28bf31ee30ca7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request data when configured in legacy mode with infinite skip factor.  <a href="#a39c2c57c8b14647bde28bf31ee30ca7f">More...</a><br /></td></tr>
<tr class="separator:a39c2c57c8b14647bde28bf31ee30ca7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b09cfed26b2243eb3a9c5c179827a22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8b09cfed26b2243eb3a9c5c179827a22">storeFilterState</a> (void)</td></tr>
<tr class="memdesc:a8b09cfed26b2243eb3a9c5c179827a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store orientation filter state in the device.  <a href="#a8b09cfed26b2243eb3a9c5c179827a22">More...</a><br /></td></tr>
<tr class="separator:a8b09cfed26b2243eb3a9c5c179827a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa17e702e833730b5bcbcb1b541d5f1c3">getDataPacketByIndex</a> (XsSize index) const </td></tr>
<tr class="memdesc:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cached data packet with <em>index</em>.  <a href="#aa17e702e833730b5bcbcb1b541d5f1c3">More...</a><br /></td></tr>
<tr class="separator:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b0738e556db3b732766550e4406ac"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a396b0738e556db3b732766550e4406ac">getDataPacketCount</a> (void) const </td></tr>
<tr class="memdesc:a396b0738e556db3b732766550e4406ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current size of the retained data packet cache.  <a href="#a396b0738e556db3b732766550e4406ac">More...</a><br /></td></tr>
<tr class="separator:a396b0738e556db3b732766550e4406ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366964ff749d6a2cbec52bbaf2b47692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a366964ff749d6a2cbec52bbaf2b47692">lastAvailableLiveData</a> (void) const </td></tr>
<tr class="memdesc:a366964ff749d6a2cbec52bbaf2b47692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last available live data.  <a href="#a366964ff749d6a2cbec52bbaf2b47692">More...</a><br /></td></tr>
<tr class="separator:a366964ff749d6a2cbec52bbaf2b47692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ef22d9d1e3dfd3f889966525026a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a34ef22d9d1e3dfd3f889966525026a85">takeFirstDataPacketInQueue</a> (void)</td></tr>
<tr class="memdesc:a34ef22d9d1e3dfd3f889966525026a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first packet in the packet queue or an empty packet if the queue is empty.  <a href="#a34ef22d9d1e3dfd3f889966525026a85">More...</a><br /></td></tr>
<tr class="separator:a34ef22d9d1e3dfd3f889966525026a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964dfd9c6f751ece23bc2f723d4a188a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a964dfd9c6f751ece23bc2f723d4a188a">isInitialBiasUpdateEnabled</a> (void) const </td></tr>
<tr class="memdesc:a964dfd9c6f751ece23bc2f723d4a188a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#a964dfd9c6f751ece23bc2f723d4a188a">More...</a><br /></td></tr>
<tr class="separator:a964dfd9c6f751ece23bc2f723d4a188a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c10338c003a5f69bb5968583809de96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96">setInitialBiasUpdateEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a9c10338c003a5f69bb5968583809de96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#a9c10338c003a5f69bb5968583809de96">More...</a><br /></td></tr>
<tr class="separator:a9c10338c003a5f69bb5968583809de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96e89968e94b49b8a9aafaaa5126e0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad96e89968e94b49b8a9aafaaa5126e0e">isFixedGravityEnabled</a> (void) const </td></tr>
<tr class="memdesc:ad96e89968e94b49b8a9aafaaa5126e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the fixed gravity value should be used or if it should be computed from the initialPositionLLA value.  <a href="#ad96e89968e94b49b8a9aafaaa5126e0e">More...</a><br /></td></tr>
<tr class="separator:ad96e89968e94b49b8a9aafaaa5126e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b98429d0b592a3395fb853619e8a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0d5b98429d0b592a3395fb853619e8a7">setFixedGravityEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a0d5b98429d0b592a3395fb853619e8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the fixed gravity value should be used or if it should be computed from the initialPositionLLA value.  <a href="#a0d5b98429d0b592a3395fb853619e8a7">More...</a><br /></td></tr>
<tr class="separator:a0d5b98429d0b592a3395fb853619e8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aea7017d2579fee0b04243ad7a1a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac6aea7017d2579fee0b04243ad7a1a16">createConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:ac6aea7017d2579fee0b04243ad7a1a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current device configuration in a config file(.xsa)  <a href="#ac6aea7017d2579fee0b04243ad7a1a16">More...</a><br /></td></tr>
<tr class="separator:ac6aea7017d2579fee0b04243ad7a1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a08ea246d7c10a63c5d6c4cebb32a4eb5">applyConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a config file(.xsa) and configures the device accordingly.  <a href="#a08ea246d7c10a63c5d6c4cebb32a4eb5">More...</a><br /></td></tr>
<tr class="separator:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ae39415f88e591be84e34f659d887c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c">setAlignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:aa5ae39415f88e591be84e34f659d887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L' or S to the chosen frame S'.  <a href="#aa5ae39415f88e591be84e34f659d887c">More...</a><br /></td></tr>
<tr class="separator:aa5ae39415f88e591be84e34f659d887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d">alignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation matrix to rotate S to the chosen frame S'.  <a href="#a32aefeb3bcf3a82a8e6c2e1281283a1d">More...</a><br /></td></tr>
<tr class="separator:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa">setAlignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;quat)</td></tr>
<tr class="memdesc:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L' or S to the chosen frame S'.  <a href="#a5c5ba2ab3c1a316f6142d2383c472daa">More...</a><br /></td></tr>
<tr class="separator:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4159ae056441f563d06e4d94450f61e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e">alignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:ae4159ae056441f563d06e4d94450f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation quaternion.  <a href="#ae4159ae056441f563d06e4d94450f61e">More...</a><br /></td></tr>
<tr class="separator:ae4159ae056441f563d06e4d94450f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a7a98d741d407f20d71e43ea87ba86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a80a7a98d741d407f20d71e43ea87ba86">deviceIsDocked</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) const </td></tr>
<tr class="memdesc:a80a7a98d741d407f20d71e43ea87ba86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the device is docked.  <a href="#a80a7a98d741d407f20d71e43ea87ba86">More...</a><br /></td></tr>
<tr class="separator:a80a7a98d741d407f20d71e43ea87ba86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48811a0c1bb107f6495b645c8163d966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48811a0c1bb107f6495b645c8163d966">isLoadLogFileInProgress</a> (void) const </td></tr>
<tr class="memdesc:a48811a0c1bb107f6495b645c8163d966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file operation started by loadLogFile is still in progress.  <a href="#a48811a0c1bb107f6495b645c8163d966">More...</a><br /></td></tr>
<tr class="separator:a48811a0c1bb107f6495b645c8163d966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c449c1b70c5b8eae026bdc8c5e28c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7c449c1b70c5b8eae026bdc8c5e28c3d">waitForLoadLogFileDone</a> (void) const </td></tr>
<tr class="memdesc:a7c449c1b70c5b8eae026bdc8c5e28c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the file operation started by loadLogFile to complete.  <a href="#a7c449c1b70c5b8eae026bdc8c5e28c3d">More...</a><br /></td></tr>
<tr class="separator:a7c449c1b70c5b8eae026bdc8c5e28c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add668a523749793432961144a66ae046"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#add668a523749793432961144a66ae046">supportedStatusFlags</a> (void) const </td></tr>
<tr class="memdesc:add668a523749793432961144a66ae046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask with all the status flags supported by this device.  <a href="#add668a523749793432961144a66ae046">More...</a><br /></td></tr>
<tr class="separator:add668a523749793432961144a66ae046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a09f36dfad04f941d4d4b8801bec0a8d8">supportsSyncSettings</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>)</td></tr>
<tr class="memdesc:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the device specified by <em>deviceId</em> supports sync settings.  <a href="#a09f36dfad04f941d4d4b8801bec0a8d8">More...</a><br /></td></tr>
<tr class="separator:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9403b0737977dcfbf0b6c1648ba81848"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9403b0737977dcfbf0b6c1648ba81848">isCompatibleSyncSetting</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>, const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &amp;setting1, const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &amp;setting2)</td></tr>
<tr class="memdesc:a9403b0737977dcfbf0b6c1648ba81848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em>.  <a href="#a9403b0737977dcfbf0b6c1648ba81848">More...</a><br /></td></tr>
<tr class="separator:a9403b0737977dcfbf0b6c1648ba81848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fc99f3e32921b758ead95141ccff1"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a179fc99f3e32921b758ead95141ccff1">syncSettingsTimeResolutionInMicroSeconds</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>)</td></tr>
<tr class="separator:a179fc99f3e32921b758ead95141ccff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234b88d2f9cb339be3afcc22547d6ec8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a234b88d2f9cb339be3afcc22547d6ec8">supportedSyncSettings</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#ae739c221e20e36b22c12a2bf2d4836df">deviceId</a>)</td></tr>
<tr class="memdesc:a234b88d2f9cb339be3afcc22547d6ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the supported synchronization settings for a specified <em>deviceId</em> or deviceId mask.  <a href="#a234b88d2f9cb339be3afcc22547d6ec8">More...</a><br /></td></tr>
<tr class="separator:a234b88d2f9cb339be3afcc22547d6ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> object. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a82b8814eb53ad1756d5ab49b4b35fc7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::abortFlushing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the wireless flushing operation and finalize the recording. </p>
<dl class="section return"><dt>Returns</dt><dd>true if no flushing is in progress when the function exits </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a2448f25505c27fee9ecab1853edb3793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::abortLoadLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts loading a logfile. </p>
<dl class="section return"><dt>Returns</dt><dd>true if loading is aborted successfully </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if no file was currently loading returns false </dd></dl>

</div>
</div>
<a class="anchor" id="a1c7459738f46fd70e231eb268cc32906"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::accelerometerRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the accelerometers in the device. </p>
<p>The actual official range is -accelerometerRange() .. <a class="el" href="struct_xs_device.html#a1c7459738f46fd70e231eb268cc32906" title="Returns the maximum official value of the accelerometers in the device. ">accelerometerRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p><dl class="section return"><dt>Returns</dt><dd>The maximum value of the accelerometers in m/s^2 </dd></dl>

</div>
</div>
<a class="anchor" id="afdbcc97e51468bdc61bdc51f322a3f56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::acceptConnection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept connections from the device on the parent/master device. </p>
<p>This function can be used to accept connections from a device that has been rejected. Call this function from within the onConnectivityChanged callback. </p><dl class="section return"><dt>Returns</dt><dd>true if the device will be accepted next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw rejected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="ae1947781609b90542a9496ad371a2e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a> XsDevicePtr::accessControlMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the access control mode of the master device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured access control mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf" title="Set the access control mode of the master device. ">setAccessControlMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a51fb0f69cf51ea4014dd4c0cb852d6e4" title="Request the access control list of the master device. ">currentAccessControlList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affecdda0f378e2193c75a3e01055eecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a32aefeb3bcf3a82a8e6c2e1281283a1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevicePtr::alignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation matrix to rotate S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae4159ae056441f563d06e4d94450f61e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> XsDevicePtr::alignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08ea246d7c10a63c5d6c4cebb32a4eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::applyConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a config file(.xsa) and configures the device accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8c443be103003479799fa888ada5216e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::areOptionsEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when all the specified processing options are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The options to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the options are enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe9d818db7d23b4fcde4e7ac3813674d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> XsDevicePtr::availableOnboardFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a3ceb6039061b54469e5185b740f0726c" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc2e0762821a17597317428ef1877abe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> XsDevicePtr::availableXdaFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the host PC </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac07ca5fae0138ecb9067ad5c7ec13b5d" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a48a4256625a1015db63ea98e3f8c6b3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::batteryLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication. </p>
<p>Bodypack: The amount of time remaining for measurement given any battery level greatly depends on the type of batteries used, the number of sensors attached to the Bodypack and the used output options. Mtw: The last known battery level for this motion tracker. First call </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a44d4a15dcb2fcc76deddaf44461a77e9" title="Request the battery level from the device. ">requestBatteryLevel</a> to have a battery level available. The callback </dd>
<dd>
onInfoResponse with ID <a class="el" href="group__enums.html#ggafc251752e68beaf61a5fd95627b344baadedf85741d51224bcc9b24a8ae08532f" title="Request battery level. ">XIR_BatteryLevel</a> will indicate when the requested battery level is available. This function is available in both config and measurement mode. For devices in wired mode this function can be called without calling </dd>
<dd>
<a class="el" href="struct_xs_device.html#a44d4a15dcb2fcc76deddaf44461a77e9" title="Request the battery level from the device. ">requestBatteryLevel</a> first </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The battery level in the range 0-100 </dd></dl>

</div>
</div>
<a class="anchor" id="a5ba9b53c6eff4c39a1bd07901a347694"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> XsDevicePtr::batteryLevelTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the time the battery level was last updated. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps. ">XsTimeStamp</a> the battery level was last set </dd></dl>

</div>
</div>
<a class="anchor" id="adf5fe131e261f0126b62d36faee29b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> XsDevicePtr::baudRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#a29cec49fbd44450843078f0db55eb323" title="The baud rate configured for cabled connection. ">serialBaudRate()</a> function in that it will only return the baud rate of the current connection, whereas the <a class="el" href="struct_xs_device.html#a29cec49fbd44450843078f0db55eb323" title="The baud rate configured for cabled connection. ">serialBaudRate()</a> function will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly). </p><dl class="section return"><dt>Returns</dt><dd>The baud rate of the serial connection or XBR_Invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a8d48fb574f706adf5976cf94e110efe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::busId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bus ID for this device. </p>
<dl class="section return"><dt>Returns</dt><dd>The bus ID of the device </dd></dl>

</div>
</div>
<a class="anchor" id="aa12ae093fdf9cb837f1bc7d2c7069302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::cacheSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently in the slow data cache for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The actual number of items in the cache, which may contain huge gaps in packet ids </dd></dl>

</div>
</div>
<a class="anchor" id="a1b98e3907877e7c358129137a0731e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::canConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured CAN configuration of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The can configuration of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a5a825a8ec9fee89b6da73dbeba218e56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> XsDevicePtr::canOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured CAN output of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The can output configuration of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a574ca4074faf41de90fed078414d1022"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::childCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of child-devices this device has. For standalone devices this is always 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of child devices of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a02d819fca52a6ce5d192bbe8aab9360a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device.html">XsDevice</a> * &gt; XsDevicePtr::children </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a managed array containing the child-devices this device has. For standalone devices this is always an empty array. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of pointers to the child devices of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a208157faba015c166f2878e070cfad94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a517288ec25530fc1ef25c1688bab7bcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::closeLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

</div>
</div>
<a class="anchor" id="ab71818f49389dba396fa88140837354a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> XsDevicePtr::connectivityState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connectivity state of the device. </p>
<p>The connectivity describes how and if the device is connected to XDA. </p><dl class="section return"><dt>Returns</dt><dd>The current connectivity of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c" title="XsDevice connectivity state identifiers. ">XsConnectivityState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6aea7017d2579fee0b04243ad7a1a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::createConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the current device configuration in a config file(.xsa) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8afe4b27a5df14e02c8a1c6a7dfcb3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::createLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a log file for logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The desired path and filename of the log file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a51fb0f69cf51ea4014dd4c0cb852d6e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> XsDevicePtr::currentAccessControlList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the access control list of the master device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured access control list. This can be either a blacklist or a whitelist. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf" title="Set the access control mode of the master device. ">setAccessControlMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae1947781609b90542a9496ad371a2e47" title="Request the access control mode of the master device. ">accessControlMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a632fc319d29c737ec40a97cd1c0534c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::dataLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the data in the legacy MTData packets that the device will send in measurement mode. </p>
<p>This function will only return a value when the device is configured for legacy output, otherwise it will return 0. </p><dl class="section return"><dt>Returns</dt><dd>The data size of the MTData packets that will be sent by the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setDeviceMode </dd>
<dd>
deviceMode </dd></dl>

</div>
</div>
<a class="anchor" id="af5252f1f85a52eeef4ac2c5af789c24e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::deviceAtBusId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aac6d6e422d8ccf6316a33f29be3259ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::deviceAtBusIdConst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a94af58c8654c885d6e343df3f8ed36be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::deviceBufferSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the size of the interal buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Buffer size in number of frames </dd></dl>

</div>
</div>
<a class="anchor" id="ac214d93f19a57c11ce1cf1fd2b0f750a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> XsDevicePtr::deviceConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device configuration. </p>
<p>The device configuration contains a summary of the devices connected to the same port. The function will always return the configuration for the port's main device. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the device configuration of the port </dd></dl>

</div>
</div>
<a class="anchor" id="ae739c221e20e36b22c12a2bf2d4836df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsDevicePtr::deviceId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device ID of the device. </p>
<p>Each Xsens device has a unique ID. The ID identifies the device as well as the product family it belongs to. </p><dl class="section return"><dt>Returns</dt><dd>The device ID </dd></dl>

</div>
</div>
<a class="anchor" id="a80a7a98d741d407f20d71e43ea87ba86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::deviceIsDocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the device is docked. </p>
<p>Checks if device <em>dev</em> is docked in this device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked in this device </dd></dl>

</div>
</div>
<a class="anchor" id="a033dee757377384f010ffd9fb61dcd81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> XsDevicePtr::deviceOptionFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device option flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The current configured device option flags </dd></dl>

</div>
</div>
<a class="anchor" id="a76cfeac115b80bd9e879838dbfd0ef6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::deviceParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the requested parameter's current value. </p>
<p>Retrieving device parameters is only valid after initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>a parameter object, corresponding to a row in the table listed under <em>XsDevice::setParameter</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or unsupported with current or current firmware version (XRV_UNSUPPORTED) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>XsDevice::setParameter </dd></dl>

</div>
</div>
<a class="anchor" id="ac604dd0e7d5f5a9373cdb7d5380d8250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> XsDevicePtr::deviceState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the state of this device. </p>
<p>The device state indiciates whether the device is in config mode, measuring, recording, etc </p><dl class="section return"><dt>Returns</dt><dd>The state of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a12cb16caa27b67d8c5e6b6f534acb5f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::disableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9" title="Enable an additional communication protocol when reading messages. ">XsDevice::enableProtocol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the removal was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="aa45e631a78e1eb13b2068f3aacf02f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::disableRadio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the radio for this station, resetting all children to disconnected state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a9a63a1bc2d1424df962f81bbcf8977bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::discardRetransmissions </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>firstNewPacketId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell XDA and the device that any data from before <em>firstNewPacketId</em> may be lossy. </p>
<p>Tell the device to not request retransmissions of missed data older than the supplied <em>firstNewPacketId</em>. If <em>firstNewPacketId</em> is beyond the end of the recording or beyond the highest received packet ID, the lower value is used instead. This means that you can't set this for future packets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstNewPacketId</td><td>The first packet that (if missing) <em>should</em> be retransmitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This applies to master devices that support retransmissions only: Awinda and Bodypack. </dd></dl>

</div>
</div>
<a class="anchor" id="a026c49500ad437124d9d4f3d8734f6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::enableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable an additional communication protocol when reading messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the addition was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="a24af0dcccddf838764795b169213a9af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::enableRadio </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the radio channel to use for wireless communication. </p>
<p>This function can be used to enable or disable the radio of an Awinda Station. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A valid channel number in the range [11..25] or -1 to disable the radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully reconfigured </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="af016f3da4aa7b43d19250080ff406875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> XsDevicePtr::errorMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error mode of the device. </p>
<p>The error mode tells the device what to do if a problem occurs. </p><dl class="section return"><dt>Returns</dt><dd>The currently configured error mode of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a91f03a8e30b52e38cebb8bfc3e6a7573" title="Sets the error mode of the device. ">setErrorMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad6fe5d2f33fbf8ba32a299cd47e56b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::findDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>. </p>
<p>This function returns the child device of the current device that matches the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>

</div>
</div>
<a class="anchor" id="a3327b3ab9c38e6d7146268cbb5f5074f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> const * XsDevicePtr::findDeviceConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>. </p>
<p>This function returns the child device of the current device that matches the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>

</div>
</div>
<a class="anchor" id="a700a14fc473ac6b6cf89e85bdece0f0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevicePtr::firmwareVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the firmware version. </p>
<dl class="section return"><dt>Returns</dt><dd>The firmware version of the live device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The firmware version is not stored in mtb files, so when reading from file this function will return an empty XsVersion object </dd></dl>

</div>
</div>
<a class="anchor" id="aa17e702e833730b5bcbcb1b541d5f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::getDataPacketByIndex </td>
          <td>(</td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cached data packet with <em>index</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The requested index, this does not have to be the same as the packet counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested packet or an empty packet if <em>index</em> is out of range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only works if XSO_RetainLiveData or XSO_RetainBufferedData was set before the data was read </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a396b0738e556db3b732766550e4406ac" title="Return the current size of the retained data packet cache. ">getDataPacketCount</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a396b0738e556db3b732766550e4406ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsDevicePtr::getDataPacketCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current size of the retained data packet cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The current size of the cache </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a396b0738e556db3b732766550e4406ac" title="Return the current size of the retained data packet cache. ">getDataPacketCount</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3551c9cc98da43c7953f01d412ecb986"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::getDeviceFromLocationId </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device given <em>locId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locId</td><td>the location ID of the device we're looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the device if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a927432e398ce365fcde26158b288c980"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsDevicePtr::getOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the currently enabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are enabled for this device and its child devices (if any) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e" title="Returns true when all the specified processing options are enabled. ">areOptionsEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade4924c51c4de8d1791bee6d2c00855f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsDevicePtr::getStartRecordingPacketId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ID of the first packet that should be recorded. </p>
<p>This is only valid in Recording or Flushing states </p><dl class="section return"><dt>Returns</dt><dd>The ID of the first packet that should be recorded </dd></dl>

</div>
</div>
<a class="anchor" id="a2363d72b55fd8dd65c83612db36ac632"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsDevicePtr::getStopRecordingPacketId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ID of the last packet that should be recorded. </p>
<p>This is only valid in Recording or Flushing states or in Measurement after a recording has finished </p><dl class="section return"><dt>Returns</dt><dd>The ID of the last packet that should be / was recorded </dd></dl>

</div>
</div>
<a class="anchor" id="ac973b8c1f4bfba660480fc219ef599d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsGnssPlatform XsDevicePtr::gnssPlatform </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device GNSS platform. </p>
<dl class="section return"><dt>Returns</dt><dd>The current device GNSS platform </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec3280fe994031d49975f99300ee5bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the device in config mode. </p>
<p>Device settings can only be changed in config mode, since changing anything during measurement would mess up the sample timing. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in config mode or was already in config mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a71743a68785ec3af6c5c5763a69aca62" title="Put this device in measurement mode. ">gotoMeasurement</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71743a68785ec3af6c5c5763a69aca62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::gotoMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put this device in measurement mode. </p>
<p>Measurement mode is where the device is sampling data and producing inertial and orientation output. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in measurement mode or was already in measurement mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a9ec3280fe994031d49975f99300ee5bb" title="Put the device in config mode. ">gotoConfig</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa98b0d4146b969af649c8008ed471d19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::gravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'Gravity Magnitude' of the device. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p><dl class="section return"><dt>Returns</dt><dd>The current 'Gravity Magnitude' setting of the device. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag. ">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa81dc4dc4e31b9b7bf0a9e67a1139af6" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1a0a2759350a42cf70d38cce2e81ccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::gyroscopeRange </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the gyroscopes in the device. </p>
<p>The actual official range is -gyroscopeRange() .. <a class="el" href="struct_xs_device.html#ad1a0a2759350a42cf70d38cce2e81ccc" title="Returns the maximum official value of the gyroscopes in the device. ">gyroscopeRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p><dl class="section return"><dt>Returns</dt><dd>The maximum value of the gyroscopes in degrees/s </dd></dl>

</div>
</div>
<a class="anchor" id="aa60c0231d8d5f7f9033954c0b6e6e25e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevicePtr::hardwareVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hardware version of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The hardware version of the device </dd></dl>

</div>
</div>
<a class="anchor" id="aee24c84fbcf4691c7c31b76dc276c275"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::hasDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae14314a4fe4fa762c784b5d580746c89" title="Returns the currently configured output of the device. ">outputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a76d8f53878808179a778b98e229e8242" title="Returns if the currently configured output contains dataType after processing on the host...">hasProcessedDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76d8f53878808179a778b98e229e8242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::hasProcessedDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em> after processing on the host. </p>
<p>Where <a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275" title="Returns if the currently configured output contains dataType. ">hasDataEnabled()</a> only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275" title="Returns if the currently configured output contains dataType. ">hasDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a0ac8cf2dbe4ffc890ddf12dace09feed" title="Return the full output configuration including post processing outputs. ">processedOutputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7cbb7550a81f66470d36f9b87e7b3374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::headingOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 'heading offset' setting of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured heading offset in degrees </dd></dl>

</div>
</div>
<a class="anchor" id="aa81dc4dc4e31b9b7bf0a9e67a1139af6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> XsDevicePtr::initialPositionLLA </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'Latitude Longitude Altitude' setting of the device. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. Note: this XDA data type is the setting initialPositionLLA, which is set by setInitialPositionLLA. It's value is therefore static. Use LatitudeLongitude to retrieve the live position data from the MTi. </p><dl class="section return"><dt>Returns</dt><dd>lla The desired 'Latitude Longitude Altitude' setting for the device. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa98b0d4146b969af649c8008ed471d19" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3fa6614d94f6ec21f8c4e831e9736af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device has its BlueTooth radio enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has its BlueTooth radio enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a99583e7e3b8be3c0f70454ebbf885afd" title="Enable or disable the BlueTooth radio of the device. ">setBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a23bdcbad1f87cf5ae864df727832bf8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the Xbus is powering its child devices or not. </p>
<p>When the bus power is off, the child devices are disabled </p><dl class="section return"><dt>Returns</dt><dd>true If the Xbus is currently providing power to its child devices </dd></dl>

</div>
</div>
<a class="anchor" id="a9403b0737977dcfbf0b6c1648ba81848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isCompatibleSyncSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &amp;&#160;</td>
          <td class="paramname"><em>setting1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> &amp;&#160;</td>
          <td class="paramname"><em>setting2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting1</td><td>Setting 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting2</td><td>Setting 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a40a71199e0ac73a6e3633087d7212211"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isContainerDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this device can have child devices. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a container device </dd></dl>

</div>
</div>
<a class="anchor" id="ad96e89968e94b49b8a9aafaaa5126e0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the fixed gravity value should be used or if it should be computed from the initialPositionLLA value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a0d5b98429d0b592a3395fb853619e8a7" title="Sets whether the fixed gravity value should be used or if it should be computed from the initialPosit...">setFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa98b0d4146b969af649c8008ed471d19" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa81dc4dc4e31b9b7bf0a9e67a1139af6" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a964dfd9c6f751ece23bc2f723d4a188a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p><dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709" title="Set the no rotation period to duration. ">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96" title="Set if the device does gyroscope bias estimation when switching to measurement mode. ">setInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a245785b875173391a1ec45606076700c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInitialized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when the device is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been initialized </dd></dl>

</div>
</div>
<a class="anchor" id="a98fef104c27b7d4fd0ecd18e28dc0136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInStringOutputMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in string mode. </p>
<p>In string mode only NMEA packets are transmitted at the legacy update rate </p><dl class="section return"><dt>Returns</dt><dd>true if the device is configured for string mode output. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6cc00568e74c3d1e8bd0aef10382635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInSyncStationMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is in Sync Station mode (Awinda Station and Sync Station only) </dd></dl>

</div>
</div>
<a class="anchor" id="a48811a0c1bb107f6495b645c8163d966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isLoadLogFileInProgress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the file operation started by loadLogFile is still in progress. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the file operation started by loadLogFile is still in progress </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad37f7981d180616368a61f6d16bfafa6" title="Load a complete logfile. ">loadLogFile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a7c449c1b70c5b8eae026bdc8c5e28c3d" title="Wait for the file operation started by loadLogFile to complete. ">waitForLoadLogFileDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9431efa3b5247f59d7978637cae8c008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMasterDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is the master device (not a child of another device) </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is the master device </dd></dl>

</div>
</div>
<a class="anchor" id="a5c17d9aed6fcf3913b386c289652ae2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMeasuring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a measuring state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a measuring state </dd></dl>

</div>
</div>
<a class="anchor" id="aad1ca78bee44913757b6fe623fc02682"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMotionTracker </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a motion tracker. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a motion tracker or false if it is a master device such as an Awinda Station or a Bodypack </dd></dl>

</div>
</div>
<a class="anchor" id="ad8442e17e67e191cebd498c7e1c26228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isOperational </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is operational </dd></dl>
<dl class="section see"><dt>See also</dt><dd>AwindaStationDevice::makeOperational() </dd></dl>

</div>
</div>
<a class="anchor" id="aeda57eca1b67c459bb0aa44f9c3130fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isProtocolEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when a protocol with type <em>type</em> has been added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>The protocol type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49332ef50f311204a3a8ac64d91a3cc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isRadioEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the radio is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio is enabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="a8783311f6552d50a106275256aa6679e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isReadingFromFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is reading from a file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is reading from a file </dd></dl>

</div>
</div>
<a class="anchor" id="acc553090db95a478977300c52ffd9ca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a recording state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a recording state </dd></dl>

</div>
</div>
<a class="anchor" id="a080a75bb6fbea533c0f031e69f5e0651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isStandaloneDevice </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a standalone device (not a child of another device and not a container device) </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a standalone device, equivalent to !isContainerDevice() &amp;&amp; <a class="el" href="struct_xs_device.html#a9431efa3b5247f59d7978637cae8c008" title="Returns true if this is the master device (not a child of another device) ">isMasterDevice()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="add838b44c58b46df62660c511d0294f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isSyncMaster </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a master role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization master role </dd></dl>

</div>
</div>
<a class="anchor" id="ad794d654ce040f786590b64d391b4475"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isSyncSlave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a slave role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization slave role </dd></dl>

</div>
</div>
<a class="anchor" id="a366964ff749d6a2cbec52bbaf2b47692"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::lastAvailableLiveData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last available live data. </p>
<dl class="section return"><dt>Returns</dt><dd>A packet containing the latest available live data. This packet will contain the latest data of each appropriate type, so it may contain old data mixed with new data if different data comes in at different speeds. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only works if XSO_KeepLastLiveData is set </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1978013d5857f966f21443c87720fa75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t XsDevicePtr::lastKnownRssi </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last known RSSI value of the device. </p>
<p>RSSI values are only relevant for wireless devices. Since the value is measured passively, any time an RSSI value is received by XDA, the last known value is updated. </p><dl class="section return"><dt>Returns</dt><dd>The last known biased RSSI value or XS_RSSI_UNKNOWN if no RSSI value is available (yet) </dd></dl>

</div>
</div>
<a class="anchor" id="a099a9d1ef957c1937220f541e66d97c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::lastResult </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p><dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_xs_device.html#afb5f61cb5abb68e1177ec25339513d45" title="Get the accompanying error text for the value returned by lastResult() It may provide situation-speci...">lastResultText()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb5f61cb5abb68e1177ec25339513d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::lastResultText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the accompanying error text for the value returned by <a class="el" href="struct_xs_device.html#a099a9d1ef957c1937220f541e66d97c8" title="Get the result value of the last operation. ">lastResult()</a> It may provide situation-specific information instead. </p>
<dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_xs_device.html#a099a9d1ef957c1937220f541e66d97c8" title="Get the result value of the last operation. ">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad37f7981d180616368a61f6d16bfafa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::loadLogFile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a complete logfile. </p>
<p>Load the opened log file completely. This function loads all data from the open logfile in a separate thread, generating onProgressUpdated callbacks. This function will return true if the reading was scheduled. </p><dl class="section return"><dt>Returns</dt><dd>true if the threaded loading was successfully started </dd></dl>
<dl class="section see"><dt>See also</dt><dd>onProgressUpdated </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf71b3c0e24ebcf579d7371ee87cb54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::locationId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p><dl class="section return"><dt>Returns</dt><dd>The current location ID stord in the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a89d6968b26addd3da277435a0fbec82a" title="Set the location ID of the device. ">setLocationId</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5d05ca61eeac4922d5b2e9f781e6595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::logFileName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the log file the device is reading from. </p>
<p>Returns an empty string when not in file mode. </p><dl class="section return"><dt>Returns</dt><dd>The name of the logfile </dd></dl>

</div>
</div>
<a class="anchor" id="a1d157341846d031ae8d8a85f174a59c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevicePtr::logFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current read position of the open log file. </p>
<p>If the function encounters an error the function returns -1. </p><dl class="section return"><dt>Returns</dt><dd>The current read position (in bytes) from the start of the file or -1 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aeb33bc239ad3ff9b05f57c8bba205e43" title="Get the size of the log file the device is reading from. ">logFileSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeb33bc239ad3ff9b05f57c8bba205e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevicePtr::logFileSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the log file the device is reading from. </p>
<p>If the function encounters an error the function returns 0. </p><dl class="section return"><dt>Returns</dt><dd>The size of the log file or 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a1d157341846d031ae8d8a85f174a59c2" title="Get the current read position of the open log file. ">logFileReadPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa67501a215db1bfabcf9f9720648dcbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::makeOperational </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Awinda station to operational state. </p>
<dl class="section note"><dt>Note</dt><dd>this is considered an extension to the config state, not a new state. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the awindastation is put in operational mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a22f15fd07a05892389a89799e41ad46b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::master </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the master device of this device. </p>
<p>This function returns the master device of the current device. This may be the device itself </p><dl class="section return"><dt>Returns</dt><dd>The master device of the device </dd></dl>

</div>
</div>
<a class="anchor" id="afcda8710cd0aec33f33967f1cafaee7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::maximumUpdateRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum update rate for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum update rate of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a617e87d8f8ccf472f4f622f2e872171d" title="Ask the device for its supported update rates for the given dataType. ">supportedUpdateRates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf256a32a1009d3181b291ca147c71f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevicePtr::objectAlignment </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object alignment matrix of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'object alignment matrix' setting of the device. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use alignmentRotationQuaternion or alignmentRotationMatrix instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setObjectAlignmentMatrix() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a7cbb7550a81f66470d36f9b87e7b3374" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61" title="Set the &#39;heading offset&#39; setting of the device. ">setHeadingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ceb6039061b54469e5185b740f0726c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevicePtr::onboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use by the device for computing orientations. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac07ca5fae0138ecb9067ad5c7ec13b5d" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b82b4a47ddc389a96b16a1e265e4519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsOperationalMode XsDevicePtr::operationalMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operational mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The current operational mode of the device </dd></dl>

</div>
</div>
<a class="anchor" id="ae14314a4fe4fa762c784b5d580746c89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevicePtr::outputConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured output of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The output configuration of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4197ecec22e67822a53909b27c2e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::packetErrorRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet error rate for the for the device. </p>
<p>The packet error rate indicates the proportion of data packets from the device that are lost or corrupted in some manner over some time window. Depending on the device the packet error rate may be updated actively or passively, and the time window may vary, so packet error rates cannot be compared directly between different types of device.</p>
<dl class="section note"><dt>Note</dt><dd>Not all devices support packet error rate estimation. Those that don't will always report a 0% packet error rate.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The packet error rate as a percentage. </dd></dl>

</div>
</div>
<a class="anchor" id="a75a756abb13ac67e12ac4ea802903477"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> XsDevicePtr::portConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current port configuration of a device. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only Mti6x0 devices supported </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current port configurations of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae6e60613acdb412005dd3ec00baf6622" title="Change the port configuration of a device. ">setPortConfiguration</a>, XsBaudCode </dd></dl>

</div>
</div>
<a class="anchor" id="a947f084fda5a5a73e27feae5b511e90b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> XsDevicePtr::portInfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port information of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The port information object containing the information of the communication port or an empty structure if not connected to a communication port </dd></dl>

</div>
</div>
<a class="anchor" id="a9b8be9976cc53c225affc305821b7722"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::portName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port name of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the communication port or an empty string if not connected to a communication port </dd></dl>

</div>
</div>
<a class="anchor" id="ac9999b40fd7bd300c1f17f6517fe8d05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the device to power down completely. </p>
<p>This function can be used to tell the device to shut down completely, requiring a physical button press on the device to power up again. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully powered down </dd></dl>

</div>
</div>
<a class="anchor" id="a0ac8cf2dbe4ffc890ddf12dace09feed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevicePtr::processedOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full output configuration including post processing outputs. </p>
<p>This function return the list returned by <a class="el" href="struct_xs_device.html#ae14314a4fe4fa762c784b5d580746c89" title="Returns the currently configured output of the device. ">outputConfiguration()</a> and adds outputs that become available during post-processing. </p><dl class="section return"><dt>Returns</dt><dd>The requested output configuration list </dd></dl>

</div>
</div>
<a class="anchor" id="a6fa808cef643f6f855dcc93ad24e3f10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::productCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product code of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The product code of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a6565430d6bf14d48a999bd0c11d19cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::radioChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radio channel used for wireless communication. </p>
<dl class="section return"><dt>Returns</dt><dd>The radio channel used for wireless communication or -1 if the radio is disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f7c050c6f13611d99f2e67473d7ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::recordingQueueLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of packets currently waiting in the slow data cache for the device based. </p>
<dl class="section return"><dt>Returns</dt><dd>The highest received packet ID minus the last reported packet id in the slow data callback </dd></dl>

</div>
</div>
<a class="anchor" id="a751099844b8177fe2072d4ec8766bd5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsDevicePtr::refCounter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current reference counter. </p>
<dl class="section return"><dt>Returns</dt><dd>The current reference count </dd></dl>

</div>
</div>
<a class="anchor" id="a3cdb2c03d2f9188cbbcf47e9bc0b933f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reinitialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>. </p>
<p>This function will read all configuration details freshly from the device and will reinitialize all filters. Especially when you have made changes to the device configuration outside XDA or through <a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5" title="Send a custom message messageSend to the device and possibly wait for a result. ">sendCustomMessage()</a> it is advisable to call this function so XDA will show the correct state of the device. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reinitialized </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device itself is not reset, but will be put in config mode while the settings are being updated. </dd></dl>

</div>
</div>
<a class="anchor" id="a33d22f8e3befaee56238d516859e138d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::rejectConnection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reject connections from the device on the parent/master device. </p>
<p>This function can be used to reject connections from a device that has connected. This function can be called from within the onConnectivityChanged callback or at other times when a device is connected. </p><dl class="section return"><dt>Returns</dt><dd>true if the device will be rejected next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the function returns, this <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> should no longer be used. </dd>
<dd>
MTw connected to Awinda Station only </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af0756862440ae1099a5b9ff2f8927034" title="Returns the reason why a device&#39;s connection was rejected. ">rejectReason</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0756862440ae1099a5b9ff2f8927034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a> XsDevicePtr::rejectReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reason why a device's connection was rejected. </p>
<p>This function is typically called from within the onConnectivityChanged callback when the connectivity has changed to XCS_Rejected. </p><dl class="section return"><dt>Returns</dt><dd>The reason why the connection was rejected </dd></dl>

</div>
</div>
<a class="anchor" id="a3608b05b6a94c8ff3889a1976ea42ee6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cd62e7bef270670a169b248d40f01c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::removeRef </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1. </p>
<ul>
<li>If it is a child device, it will delete itself when the reference count reaches zero. It will also remove itself from its master's child list and ask the master if it can be deleted</li>
<li>If it is a master device, it will delete itself when the reference count reaches zero and the reference count of all children is zero. </li>
</ul>

</div>
</div>
<a class="anchor" id="a48d8c44453e80d1c9fa2efc30062cd79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reopenPort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gotoConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipDeviceIdCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reopens a port Uses rescan method to redetect a device. Also if USB descriptor has changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfig</td><td>Set to true if the device should be put to config before port closure </td></tr>
    <tr><td class="paramname">skipDeviceIdCheck</td><td>Set to true if the rescan should not verify the device id (not recommended) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a3293cd63b511ab11a8a02aadd306e348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::replaceFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>profileCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> &amp;&#160;</td>
          <td class="paramname"><em>profileNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces profileCurrent by profileNew in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileCurrent</td><td>The profile that should be replaced </td></tr>
    <tr><td class="paramname">profileNew</td><td>The new profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation does nothing as this feature requires the full XDA </dd></dl>

</div>
</div>
<a class="anchor" id="a9152c38978172f78379fad1ca867653d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::representativeMotionState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the active representative motion state for the In-Run Compass Calibration. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the reprensentation motion state is active, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a44d4a15dcb2fcc76deddaf44461a77e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::requestBatteryLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the battery level from the device. </p>
<p>This is an asynchronous operation. The Awinda station or MTw sends the battery level when possible. For devices in wired mode the </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a48a4256625a1015db63ea98e3f8c6b3e" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">batteryLevel()</a> function can be called without calling this function first. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If the battery level request was successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="a39c2c57c8b14647bde28bf31ee30ca7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::requestData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request data when configured in legacy mode with infinite skip factor. </p>
<p>When configured in legacy mode and an output skip factor of 0xFFFF, the device will not send data by itself, but will instead send the latest data after receiving an explicit request. This function is that request. After the request, the normal callback mechanism will take over. </p><dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent. </dd></dl>

</div>
</div>
<a class="anchor" id="ac673fd524d04468c0d9c1eca12c59c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the device. </p>
<p>This function tells the device to reboot itself. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reset </dd></dl>

</div>
</div>
<a class="anchor" id="a454a6e78a01a27e4c59619bd84da972d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the read position of the open log file to the start of the file. </p>
<p>If software filtering is enabled, the appropriate filters will be restarted as if the file was just opened. </p><dl class="section return"><dt>Returns</dt><dd>true if the read position was successfully reset to the start of the file </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a3aeafc3cb53243db1aaea7213002d42c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::resetOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a>&#160;</td>
          <td class="paramname"><em>resetmethod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an orientation reset on the device using the given <em>resetMethod</em>. </p>
<p>This function schedules an orientation reset command to be applied in the first available orientation filter update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetmethod</td><td>The requested orientation reset method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the orientation reset was successfully scheduled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>XRM_StoreAlignmentMatrix can only be used in config mode, the others only in measurement mode </dd></dl>

</div>
</div>
<a class="anchor" id="afa7460d11e20d33afc13d828af958e32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::restoreFactoryDefaults </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the device to its factory default settings. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the settings have been successfully restored </dd></dl>

</div>
</div>
<a class="anchor" id="aa9236fcd28b24a4928faaa958b4a0eae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::rs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p><dl class="section return"><dt>Returns</dt><dd>The currently configured RS485 transmission delay </dd></dl>

</div>
</div>
<a class="anchor" id="ab46b6c4ac8b4d23b50c72d323831136b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> XsDevicePtr::runSelfTest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the self test for the device. </p>
<p>All Xsens devices have limited self-diagnostic functionality, which can be triggered by calling this function. The device automatically does some self tests during startup, but this function returns more information. </p><dl class="section return"><dt>Returns</dt><dd>Results of the test </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and can take a few 100 ms </dd></dl>

</div>
</div>
<a class="anchor" id="a9656439549ad9d4a2572aea7afaa48d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::sendCustomMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a custom message <em>messageSend</em> to the device and possibly wait for a result. </p>
<p>If <em>waitForResult</em> is true, the function will wait for a result and put it in the given <em>messageReceive</em>. Otherwise the contents of messageReceive will not be altered. If an error message is received or the wait times out, <em>messageReceive</em> will contain an error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSend</td><td>The message to send to the device </td></tr>
    <tr><td class="paramname">waitForResult</td><td>true if it is required that the function waits for the appropriate reply. A valid reply always has a message ID that is one higher than the sent message ID. </td></tr>
    <tr><td class="paramname">messageReceive</td><td>When <em>waitForResult</em> is true, the reply will be put in this object. </td></tr>
    <tr><td class="paramname">timeout</td><td>Optional timeout in ms. When 0 is supplied (the default), the default timeout is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent and when <em>waitForResult</em> is true the correct reply has been received </dd></dl>

</div>
</div>
<a class="anchor" id="ac68153cc14002d710e1c896b0ee6f1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::sendRawMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message directly to the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="a29cec49fbd44450843078f0db55eb323"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> XsDevicePtr::serialBaudRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The baud rate configured for cabled connection. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#adf5fe131e261f0126b62d36faee29b16" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function in that it will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly), whereas the <a class="el" href="struct_xs_device.html#adf5fe131e261f0126b62d36faee29b16" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function will return the baud rate of the current connection. </p><dl class="section return"><dt>Returns</dt><dd>The configured baud rate </dd></dl>

</div>
</div>
<a class="anchor" id="ac620eb9326e9c98fdd82dd597cf39cbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAccessControlMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> &amp;&#160;</td>
          <td class="paramname"><em>initialList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the access control mode of the master device. </p>
<p>The access control mode determines which connections are allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The access control mode to use, the choice is between blacklist or whitelist </td></tr>
    <tr><td class="paramname">initialList</td><td>The initial list to use for the selected access control mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the access control mode was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae1947781609b90542a9496ad371a2e47" title="Request the access control mode of the master device. ">accessControlMode()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a51fb0f69cf51ea4014dd4c0cb852d6e4" title="Request the access control list of the master device. ">currentAccessControlList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ae39415f88e591be84e34f659d887c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAlignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L' or S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">matrix</td><td>The desired alignment rotation setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c5ba2ab3c1a316f6142d2383c472daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAlignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L' or S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">quat</td><td>The desired alignment rotation setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99583e7e3b8be3c0f70454ebbf885afd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable the BlueTooth radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ab3fa6614d94f6ec21f8c4e831e9736af" title="Returns true if the device has its BlueTooth radio enabled. ">isBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6b8c2b18ad882c64b0ff3b7ad89655d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the Xbus to provide power to its child devices or not. </p>
<p>This function can be used to tell the Xbus to stop and start powering its child devices. By default when the Xbus starts up it will provide power to its child devices. Switching the power off can save a lot of energy, but powering the system up again will take some time, depending on the number of connected devices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable bus power, false to disable the bus power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus' bus power state was successfully updated. </dd></dl>

</div>
</div>
<a class="anchor" id="a48dbc784ace70b92caaefb7626d64887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setCanConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CAN configuration for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Should consist of 8 bytes baudcode and 1 bit to enable CAN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the CAN output configuration was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a53cc34af532ebc3c86a948e99f3e307d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setCanOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CAN output configuration for this device. </p>
<p>When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa1b5a95fc6cae2b3b661936dc79670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceAccepted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been successfully accepted </dd></dl>

</div>
</div>
<a class="anchor" id="acbf52735776e76c08aeb22e24b7bf78d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the device to set it's internal buffer to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>buffer size in frames </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the setting was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="aef1033b2fd38c83d64db9390c5fb2368"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceOptionFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td>
          <td class="paramname"><em>setFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td>
          <td class="paramname"><em>clearFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device option flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setFlags</td><td>The option flags that must be set. Set to XDOF_None if no flags need to be set </td></tr>
    <tr><td class="paramname">clearFlags</td><td>The option flags that must be cleared. Set to XDOF_None if no flags need to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device option flags were successfully altered </dd></dl>

</div>
</div>
<a class="anchor" id="abcd6151790a88275589be880b1aac8ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::setDeviceParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given parameter for the device. </p>
<p>Settings device parameters is only valid after initialization and before switching the device to be operational. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>a parameter object, corresponding to a row in the table below. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or unsupported with current device or firmware version (XRV_UNSUPPORTED).</dd></dl>
<p>For Awinda stations this function needs to be called before enabling the radio (<em><a class="el" href="struct_xs_device.html#a24af0dcccddf838764795b169213a9af" title="Set the radio channel to use for wireless communication. ">XsDevice::enableRadio</a></em>).</p>
<table class="doxtable">
<tr>
<th rowspan="2">XsDeviceParameterIdentifier </th><th rowspan="2">Value type/range </th><th rowspan="2">Description </th><th colspan="6">Supported devices  </th></tr>
<tr>
<th>Awinda 2 (Station, Dongle) </th><th>BodyPack </th><th>MTmk4 </th><th>MTw2 </th><th>MTx2 </th><th>SyncStation  </th></tr>
<tr>
<td>XDPI_PacketErrorRate </td><td>boolean </td><td>Report packet error rate for each child device. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_SyncLossTimeout </td><td>uint16_t </td><td>Network timeout in seconds used by connected child devices.<br />
For Awinda2: this timeout is measured by connected MTw2 devices based on received data from the station. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_UplinkTimeout </td><td>uint16_t </td><td>Network timeout in seconds used by the master devices.<br />
For Awinda2: this timeout is measured based on received data from each connected MTw2 individually. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_ExtendedBuffer </td><td>bool </td><td>If set, enables the extended buffer on connected MTw2 devices. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
</table>

</div>
</div>
<a class="anchor" id="a16cddf966e39a4abacb0bc279e31ffdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceRejected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rejects a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to reject </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been successfully rejected </dd></dl>

</div>
</div>
<a class="anchor" id="a91f03a8e30b52e38cebb8bfc3e6a7573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td>
          <td class="paramname"><em>errormode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the error mode of the device. </p>
<p>The error mode tells the device what to do if a problem occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errormode</td><td>The desired error mode of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af016f3da4aa7b43d19250080ff406875" title="Returns the error mode of the device. ">errorMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d5b98429d0b592a3395fb853619e8a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the fixed gravity value should be used or if it should be computed from the initialPositionLLA value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to use fixed gravity, false to compute from initialPositionLLA </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad96e89968e94b49b8a9aafaaa5126e0e" title="Returns if the fixed gravity value should be used or if it should be computed from the initialPositio...">isFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag. ">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a220f5fa69008190200f3845dd464f9f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setGnssPlatform </td>
          <td>(</td>
          <td class="paramtype">XsGnssPlatform&#160;</td>
          <td class="paramname"><em>gnssPlatform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device GNSS platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gnssPlatform</td><td>The GNSS platform that must be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device GNSS platform was successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="aac0ee16fe5af46d170902369671fa23f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setGotoConfigOnClose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gotoConfigOnClose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On closePort the device will go to config by default, with this function it is possible to prevent that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfigOnClose</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1aecf0f050da7d709d73917ece872436"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setGravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mag</td><td>The desired 'Gravity Magnitude' setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Gravity Magnitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default value is usually computed from the last known Lat Lon Alt value </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aa98b0d4146b969af649c8008ed471d19" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa81dc4dc4e31b9b7bf0a9e67a1139af6" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a25e374050eb6373033799b6a3acb9d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setHeadingOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the 'heading offset' setting of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The desired heading offset of the device in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a7cbb7550a81f66470d36f9b87e7b3374" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c10338c003a5f69bb5968583809de96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709" title="Set the no rotation period to duration. ">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a964dfd9c6f751ece23bc2f723d4a188a" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2de8e64303b89c2603f21f1040de71b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setInitialPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. The default gravity magnitude and earth magnetic field are computed form this value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>The desired 'Latitude Longitude Altitude' setting for the device. This should be a 3-element vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Latitude Longitude Altitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GNSS is available, this value is automatically updated with the last known position when the device is put in config mode after measurement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aa81dc4dc4e31b9b7bf0a9e67a1139af6" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd>
<dd>
labMagneticField </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa98b0d4146b969af649c8008ed471d19" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89d6968b26addd3da277435a0fbec82a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setLocationId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The desired location ID for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Location ID was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5cf71b3c0e24ebcf579d7371ee87cb54" title="Get the location ID of the device. ">locationId</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf3340a175cded1e16f4e5c87e7a6709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setNoRotation </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the no rotation period to <em>duration</em>. </p>
<p>This function can be called in both config and measurement modes. In config mode it specifies the duration that the device is considered to be stationary as soon as it enters measurement mode. In measurement mode, it specifies the duration that the device is considered to be stationary, starting immediately.</p>
<p>During the stationary period, the gyroscope biases are measured, giving better performance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The desired stationary duration in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the no rotation command was accepted by the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a964dfd9c6f751ece23bc2f723d4a188a" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96" title="Set if the device does gyroscope bias estimation when switching to measurement mode. ">setInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bbd3c53640d1f34d3990fe6349a4a40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setObjectAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the object alignment of the device to the given <em>matrix</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The desired 'object alignment matrix' setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object alignment matrix was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use setAlignmentRotationQuaternion or setAlignmentRotationMatrix instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>objectAlignmentMatrix </dd>
<dd>
<a class="el" href="struct_xs_device.html#a7cbb7550a81f66470d36f9b87e7b3374" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61" title="Set the &#39;heading offset&#39; setting of the device. ">setHeadingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a104c62ce2ddaaef1d82bb68fb8e83ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a3ceb6039061b54469e5185b740f0726c" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade3f3c7d902009957b60348047972ca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abe9d818db7d23b4fcde4e7ac3813674d" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a3ceb6039061b54469e5185b740f0726c" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3c5fb2d9a4b4f04ab99c7843fea294"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOperationalMode </td>
          <td>(</td>
          <td class="paramtype">XsOperationalMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device in the given operational mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Desired operional mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af14166aed1e4d0e30fb3e80aed55453e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable and disable processing options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. In case of conflict, <em>enable</em> supersedes <em>disable</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A logically OR'ed combination of XsOptions to enable </td></tr>
    <tr><td class="paramname">disable</td><td>A logically OR'ed combination of XsOptions to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e" title="Returns true when all the specified processing options are enabled. ">areOptionsEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41ba018ecf2f59b3e00e1471acf656ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output configuration for this device. </p>
<p>When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="ae6e60613acdb412005dd3ec00baf6622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setPortConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the port configuration of a device. </p>
<p>Configures the 2 ports of the 6x0 device The integers consist of:</p><ul>
<li>bits 0:7 XsBaudcode</li>
<li>bit 8 Enable flow control</li>
<li>bit 9 Use 2nd stop bit</li>
<li>bit 10 Use Parity bit</li>
<li>bit 11 Even/odd parity</li>
<li>bit 12:15 reserved</li>
<li>bits 16:19 bits XsProtocol <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>An array of elements containing a configuration for each port (UART and RS232) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only Mti6x0 devices supported </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port configuration was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a75a756abb13ac67e12ac4ea802903477" title="Get the current port configuration of a device. ">portConfiguration</a>, XsBaudCode </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5ba7004a5136186128bc156db997a359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setRs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>The desired delay </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a3febab304a21f08d188698aec93a97e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSerialBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the serial baudrate to <em>baudrate</em>. </p>
<p>This function is only useful when using a serial communication channel, such as a serial-USB converter or a direct COM port. It is advised to make the baud rate as high as your platform allows, to minimize latency and problems with bandwidth.</p>
<p>After setting the baudrate and communicating over the same communication channel, it is required to reset the device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The desired serial baudrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the baud rate was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a1b6d31de9b2703f3f28451413b047cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setStealthMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable stealth mode. </p>
<p>In stealth mode, the MVN hardware will be silent and all LEDs will be dimmed or disabled. Some minimal user feedback will remain enabled. The change will be applied immediately to all detected systems, resetting the mocap data stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true if you wish to enable stealth mode, false to disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the setting was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="afd4f01736d0491a404eecd35cdfee3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setStringOutputMode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>skipFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the string output mode for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to set </td></tr>
    <tr><td class="paramname">period</td><td>The period to set </td></tr>
    <tr><td class="paramname">skipFactor</td><td>The skipFactor to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the device was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a027b516c49744d85c28129b9a95c4eaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSyncSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;&#160;</td>
          <td class="paramname"><em>settingList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the synchronization settings of the device. </p>
<p>This function can be used to set all the synchronization options of the device at once. It is translated into device-specific commands by XDA, since not all devices support the same synchronization functionality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settingList</td><td>The list of synchronization settings to set. An empty list will clear all synchronization settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad00db14ca9852fbee4289a30a94c6eb2" title="Get all the current synchronization settings of the device. ">syncSettings</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43b42d6bab3640389ba5936cbd5aaa4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSyncStationMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Sync Station mode of the Awinda Station device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable Sync Station mode, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a01256f48cf926440c226c91fadc72ab8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setTransportMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transportModeEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the transport mode for the device. </p>
<p>The MTw has a "wake up by motion" feature that requires some power and can cause unnecessary wakeups when transporting the device. This function can be used to put the device in "transport mode", which effectively disables the motion wake up feature until the device is plugged into something or the transport mode is explicitly disabled by this function again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transportModeEnabled</td><td>true to enable transport mode (which disables the motion wakeup) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in transport mode (or taken out of it) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw only </dd></dl>

</div>
</div>
<a class="anchor" id="a43f1e4fe0a563c86f40a663e113b1bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setUpdateRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the legacy update rate of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>The desired legacy update rate for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the update rate was successfully set </dd></dl>
<dl class="section see"><dt>See also</dt><dd>deviceMode </dd>
<dd>
setDeviceMode </dd></dl>

</div>
</div>
<a class="anchor" id="af96019db07120f4c50b7d50fda4201a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setUtcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'UTC Time' setting of the device to the given <em>time</em>. </p>
<p>Sets the UTC time in the device. Setting this value allows for more accurate measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The current time in UTC format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the UTC Time was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GNSS is available, this value is automatically updated with the last known UTC time when the device is put in config mode after measurement. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b5777d11869ea81ba031387a00eecc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setWirelessPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wireless priority of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired wireless priority of the device in the range 0-255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wireless priority has been successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a89d32dca25c36ce8a6a65fa8767b8049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a454a6e78a01a27e4c59619bd84da972d" title="Set the read position of the open log file to the start of the file. ">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#ad37f7981d180616368a61f6d16bfafa6" title="Load a complete logfile. ">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac07ca5fae0138ecb9067ad5c7ec13b5d" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d36567f3a21009b64a26346536576c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a454a6e78a01a27e4c59619bd84da972d" title="Set the read position of the open log file to the start of the file. ">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#ad37f7981d180616368a61f6d16bfafa6" title="Load a complete logfile. ">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abc2e0762821a17597317428ef1877abe" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ac07ca5fae0138ecb9067ad5c7ec13b5d" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b49e90836b702ba8d2d3ff7e5eb27d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::startRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording incoming data. </p>
<p>To record successfully, a log file should be created by calling <a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> before this function is called. startRecording(XsString, XsDeviceId) can be used to achieve the same result. </p><dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Starting recording for a single non-main device will start a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a784f73a6a186365a5f9ce9be66a87367" title="Stop recording incoming data. ">stopRecording()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2336973e3f39f60485823043d788fe12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::startRepresentativeMotion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let the user indicate that he is starting the representative motion for the In-Run Compass Calibration. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the start indication was successfully sent to the device </dd></dl>

</div>
</div>
<a class="anchor" id="a2c8fee3beab14ee2e2f083eed710be28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::stealthMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the state of the stealth mode setting. </p>
<dl class="section return"><dt>Returns</dt><dd>the state of the stealth mode setting. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a1b6d31de9b2703f3f28451413b047cde" title="Enable or disable stealth mode. ">setStealthMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a784f73a6a186365a5f9ce9be66a87367"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::stopRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop recording incoming data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully stopped </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stopping recording for a single non-main device will stop a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2b49e90836b702ba8d2d3ff7e5eb27d9" title="Start recording incoming data. ">startRecording()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a258ca251ee2c6ef201401962a8e7fcde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_icc_rep_motion_result.html">XsIccRepMotionResult</a> XsDevicePtr::stopRepresentativeMotion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let the user indicate that he stopped the representative motion. </p>
<p>for the In-Run Compass Calibration </p><dl class="section return"><dt>Returns</dt><dd>A struct containing the results of the last In-Run Compass Calibration </dd></dl>

</div>
</div>
<a class="anchor" id="a8b09cfed26b2243eb3a9c5c179827a22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::storeFilterState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store orientation filter state in the device. </p>
<p>Use this function when the filters for the device have stabilized to store the current biases in the device. The benefit is that on the next startup the filter will stabilize quicker. However, the stored biases depend on temperature and other external parameters, so the stored values will remain correct for only a short time. </p><dl class="section return"><dt>Returns</dt><dd>true if the filter state was saved, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad1519cb9c51faf87613bf6e0809c60c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::storeIccResults </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the onboard ICC results for use by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the store was successful </dd></dl>

</div>
</div>
<a class="anchor" id="a486a6db129db6c4a9ed70c046edc4f0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringOutputType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string output type. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'string output type' setting of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setStringOutputType </dd></dl>

</div>
</div>
<a class="anchor" id="a04842d5110b59731fc465d621c181936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringSamplePeriod </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample period for string output. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'sample period' setting of the device for string output </dd></dl>

</div>
</div>
<a class="anchor" id="aceb20367769efdbca2c3a5b78acf9e9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringSkipFactor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the skipfactor for string output. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output skip factor' setting of the device for string output </dd></dl>

</div>
</div>
<a class="anchor" id="add668a523749793432961144a66ae046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::supportedStatusFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask with all the status flags supported by this device. </p>
<p>Not all devices support all status flags. When receiving an <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> with a status in it, this can affect how to interpret the flags. Especially with a flag like the self-test it's important not to conclude that a device is defective because it is not set when the device doesn't actually support this feature. </p><dl class="section return"><dt>Returns</dt><dd>The bitmask with all the status flags that this device supports </dd></dl>

</div>
</div>
<a class="anchor" id="a455925ce739da41a207990d31f10bdfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string_output_type_array.html">XsStringOutputTypeArray</a> XsDevicePtr::supportedStringOutputTypes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the device for its supported string output types. </p>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported string output types. </dd></dl>

</div>
</div>
<a class="anchor" id="aef5003fb23821cf7dfa935e6aa1932ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::supportedSyncSettings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all supported synchronization settings available on the device. </p>
<p>This function provides a list of the available synchronization settings of the device, since not all devices support the same synchronization functionality. Every <a class="el" href="struct_xs_sync_setting.html" title="A structure for storing all xsens sync settings. ">XsSyncSetting</a> element in the list defines one function and line setting, with supported parameters. If the same function support multiple settings (i.e. multiple lines), then the list will contains multiple items with the same function name, but with different line settings. For easier use, same functions must be listed next to eachother, so each function settings in the list will be grouped. Properties, others then m_function and m_line are set to 0 if not supported or 1 if supported by the device. </p><dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings supported by the device. Each settings grouped by functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a234b88d2f9cb339be3afcc22547d6ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::supportedSyncSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the supported synchronization settings for a specified <em>deviceId</em> or deviceId mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id to request the supported synchronization settings for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the supported synchronization settings for the specified deviceId </dd></dl>

</div>
</div>
<a class="anchor" id="a617e87d8f8ccf472f4f622f2e872171d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; XsDevicePtr::supportedUpdateRates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em> = <code><a class="el" href="group__enums.html#gga7f6c648c619f528344bfa0630c1f7252a0f6d9a98f741377d30c073548e64b97c">XDI_None</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the device for its supported update rates for the given <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the supported update rates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported update rates or an empty list in case of an error </dd></dl>

</div>
</div>
<a class="anchor" id="a09f36dfad04f941d4d4b8801bec0a8d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::supportsSyncSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the device specified by <em>deviceId</em> supports sync settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device specified by <em>deviceId</em> supports sync settings </dd></dl>

</div>
</div>
<a class="anchor" id="a3d2e45b77febc07c6355da108759528d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a> XsDevicePtr::syncRole </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the synchronization role of the device. </p>
<p>For synchronization purposes a device can be a master, a slave, both or neither. This function returns the way the device is currently configured. </p><dl class="section return"><dt>Returns</dt><dd>The synchronization role of the device </dd></dl>

</div>
</div>
<a class="anchor" id="ad00db14ca9852fbee4289a30a94c6eb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::syncSettings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the current synchronization settings of the device. </p>
<p>This function is a generic way of requesting the synchonization options of a device, since not all devices support the same synchronization functionality. </p><dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings configured for the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a027b516c49744d85c28129b9a95c4eaa" title="Set the synchronization settings of the device. ">setSyncSettings</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a179fc99f3e32921b758ead95141ccff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XsDevicePtr::syncSettingsTimeResolutionInMicroSeconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the time resolution in microseconds for a device with device id <em>deviceId</em> For example if the precision is 1 millisecond, 1000 is returned </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The deviceId </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34ef22d9d1e3dfd3f889966525026a85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::takeFirstDataPacketInQueue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first packet in the packet queue or an empty packet if the queue is empty. </p>
<p>This function will only return a packet when XSO_RetainLiveData or XSO_RetainBufferedData is specified for the device. It will return the first packet in the queue and remove the packet from the queue. </p><dl class="section return"><dt>Returns</dt><dd>The first packet in the queue or an empty packet if the queue is empty </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54ba89f3f793404227f9786ff57abe05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::transportMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current state of the transport mode feature. </p>
<dl class="section return"><dt>Returns</dt><dd>true if tranport mode is currently enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a01256f48cf926440c226c91fadc72ab8" title="Enable or disable the transport mode for the device. ">setTransportMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af32d16f3ff81d53a0e309dbb14dc562e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::triggerStartRecording </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording incoming data through generating a virtual input trigger. </p>
<dl class="section note"><dt>Note</dt><dd>On devices without support for a start recording input trigger this function will default to <a class="el" href="struct_xs_device.html#a2b49e90836b702ba8d2d3ff7e5eb27d9" title="Start recording incoming data. ">XsDevice::startRecording</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a784f73a6a186365a5f9ce9be66a87367" title="Stop recording incoming data. ">stopRecording()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2b49e90836b702ba8d2d3ff7e5eb27d9" title="Start recording incoming data. ">startRecording</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a20c88b3662ef409e1e3585e131106786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::updateCachedDeviceInformation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the cached device information for all devices connected to this port. </p>
<p>This function can only be called in config mode. XDA caches all device information to prevent unnecessary communication with the device. When some configuration has changed without XDA knowing about it (through <a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5" title="Send a custom message messageSend to the device and possibly wait for a result. ">sendCustomMessage()</a> for example), it may be necessary to tell XDA to refresh its cached information by calling this function. </p><dl class="section return"><dt>Returns</dt><dd>true if the cached information was updated successfully </dd></dl>

</div>
</div>
<a class="anchor" id="ad682f0f6a9d5cb6a2f6be5960e947c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the legacy update rate of the device. </p>
<p>This function is only valid for devices in legacy mode. </p><dl class="section return"><dt>Returns</dt><dd>The legacy update rate of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a81c7fbc6491350c79800b3dc20359fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRateForDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. This function only checks the output configured in the device, not possible computed data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

</div>
</div>
<a class="anchor" id="a3e588c33f4afdf18e6d4af7f4a2bcdb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRateForProcessedDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. Where updateRateForDataIdentifier only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

</div>
</div>
<a class="anchor" id="a0b92988f84be8146ca072078d731f22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::usesLegacyDeviceMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the device uses legacy device mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the legacy period, outputmode, outputsettings or string reports are used </dd></dl>

</div>
</div>
<a class="anchor" id="ab8314ecf10e85e01c0f140749cd4fde6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> XsDevicePtr::utcTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'UTC Time' setting of the device. </p>
<p>Gets the UTC time in the device. </p><dl class="section return"><dt>Returns</dt><dd>The current UTC time of the sensor </dd></dl>

</div>
</div>
<a class="anchor" id="af5a17bae6b2155db46cb690c474c35dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::waitForAllDevicesInitialized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until are known devices are initialized. </p>
<p>Container devices such as Awinda Master and Bodypack can have (slightly) delayed initialization of child devices after they have been detected. This function can be used to wait for all currently detected trackers to have been properly initialized. </p>

</div>
</div>
<a class="anchor" id="a7c449c1b70c5b8eae026bdc8c5e28c3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::waitForLoadLogFileDone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the file operation started by loadLogFile to complete. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad37f7981d180616368a61f6d16bfafa6" title="Load a complete logfile. ">loadLogFile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a48811a0c1bb107f6495b645c8163d966" title="Returns true if the file operation started by loadLogFile is still in progress. ">isLoadLogFileInProgress</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a98ccd0f755dda5966d94421036d51bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::wirelessPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wireless priority of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The wireless priority of the device or 0 if it has none. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="ac07ca5fae0138ecb9067ad5c7ec13b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevicePtr::xdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use for computing orientations on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the PC </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a3ceb6039061b54469e5185b740f0726c" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
