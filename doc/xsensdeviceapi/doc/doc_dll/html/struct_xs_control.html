<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsControl Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_xs_control-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsControl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>High level Motion Tracker (MT) management class.  
 <a href="struct_xs_control.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a383124de0bf073f72800eb1905008eee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a383124de0bf073f72800eb1905008eee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee">destruct</a> (void)</td></tr>
<tr class="memdesc:a383124de0bf073f72800eb1905008eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> object and free all memory allocated for it. <br /></td></tr>
<tr class="separator:a383124de0bf073f72800eb1905008eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079133394e619b8620e15fb2b1a3e0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a079133394e619b8620e15fb2b1a3e0d1">flushInputBuffers</a> (void)</td></tr>
<tr class="memdesc:a079133394e619b8620e15fb2b1a3e0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of all devices.  <a href="#a079133394e619b8620e15fb2b1a3e0d1">More...</a><br /></td></tr>
<tr class="separator:a079133394e619b8620e15fb2b1a3e0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036c83440d05deb5d2286c0f7da2c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7036c83440d05deb5d2286c0f7da2c0c">clearHardwareError</a> (void)</td></tr>
<tr class="memdesc:a7036c83440d05deb5d2286c0f7da2c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the last hardware error.  <a href="#a7036c83440d05deb5d2286c0f7da2c0c">More...</a><br /></td></tr>
<tr class="separator:a7036c83440d05deb5d2286c0f7da2c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0281f1055d6080734ce67526e2210fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3">close</a> (void)</td></tr>
<tr class="memdesc:a0281f1055d6080734ce67526e2210fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all ports and files.  <a href="#a0281f1055d6080734ce67526e2210fd3">More...</a><br /></td></tr>
<tr class="separator:a0281f1055d6080734ce67526e2210fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0dcd5f3427b7509b07baf64650e56dbd">openPort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname, <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:a0dcd5f3427b7509b07baf64650e56dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel on serial port with the given <em>portname</em>.  <a href="#a0dcd5f3427b7509b07baf64650e56dbd">More...</a><br /></td></tr>
<tr class="separator:a0dcd5f3427b7509b07baf64650e56dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef49e962f8f86f5fecd909958c4718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a5bef49e962f8f86f5fecd909958c4718">openPort</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo, uint32_t timeout=0, bool detectRs485=false)</td></tr>
<tr class="memdesc:a5bef49e962f8f86f5fecd909958c4718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure.  <a href="#a5bef49e962f8f86f5fecd909958c4718">More...</a><br /></td></tr>
<tr class="separator:a5bef49e962f8f86f5fecd909958c4718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd8ca1d0582d14e0e178b5ebdb0fa74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aafd8ca1d0582d14e0e178b5ebdb0fa74">openPortWithCredentials</a> (<a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo, const <a class="el" href="struct_xs_string.html">XsString</a> &amp;id, const <a class="el" href="struct_xs_string.html">XsString</a> &amp;key, uint32_t timeout=0)</td></tr>
<tr class="memdesc:aafd8ca1d0582d14e0e178b5ebdb0fa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a communication channel using the details in the supplied XsPortInfo structure using the supplied credentials.  <a href="#aafd8ca1d0582d14e0e178b5ebdb0fa74">More...</a><br /></td></tr>
<tr class="separator:aafd8ca1d0582d14e0e178b5ebdb0fa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076a44725ba5f8bbe31fdcd4865585d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d">openCustomPort</a> (int channelId, uint32_t channelLatency, bool detectRs485=false)</td></tr>
<tr class="memdesc:a6076a44725ba5f8bbe31fdcd4865585d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a custom communication channel.  <a href="#a6076a44725ba5f8bbe31fdcd4865585d">More...</a><br /></td></tr>
<tr class="separator:a6076a44725ba5f8bbe31fdcd4865585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79">closePort</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portname)</td></tr>
<tr class="memdesc:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port with the given <em>portname</em>.  <a href="#a9b3617d4a55cf48ddf7257788e1d5a79">More...</a><br /></td></tr>
<tr class="separator:a9b3617d4a55cf48ddf7257788e1d5a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2a3ac5d55588c89de12347b17304a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee2a3ac5d55588c89de12347b17304a2">closePort</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aee2a3ac5d55588c89de12347b17304a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the port that is used for communication with the given <em>deviceId</em>.  <a href="#aee2a3ac5d55588c89de12347b17304a2">More...</a><br /></td></tr>
<tr class="separator:aee2a3ac5d55588c89de12347b17304a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a16ce0525bfbd2726822d8d04306f8ba3">closePort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;portinfo)</td></tr>
<tr class="memdesc:a16ce0525bfbd2726822d8d04306f8ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the serial port that matches <em>portinfo</em>.  <a href="#a16ce0525bfbd2726822d8d04306f8ba3">More...</a><br /></td></tr>
<tr class="separator:a16ce0525bfbd2726822d8d04306f8ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfd08f3e7c65b057062bcbed1f425b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a90cfd08f3e7c65b057062bcbed1f425b">closeCustomPort</a> (int channelId)</td></tr>
<tr class="memdesc:a90cfd08f3e7c65b057062bcbed1f425b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a custom communication channel.  <a href="#a90cfd08f3e7c65b057062bcbed1f425b">More...</a><br /></td></tr>
<tr class="separator:a90cfd08f3e7c65b057062bcbed1f425b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0525d061264b6622fc2aa68aff592746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a0525d061264b6622fc2aa68aff592746">closePort</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *<a class="el" href="struct_xs_control.html#a1f9a3e46365b0381eb5bdecec5c66014">device</a>)</td></tr>
<tr class="memdesc:a0525d061264b6622fc2aa68aff592746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the device port with the given <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>.  <a href="#a0525d061264b6622fc2aa68aff592746">More...</a><br /></td></tr>
<tr class="separator:a0525d061264b6622fc2aa68aff592746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90efeebcf56612ad1b02f2991d3aca82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a90efeebcf56612ad1b02f2991d3aca82">customPortInfo</a> (int channelId) const </td></tr>
<tr class="memdesc:a90efeebcf56612ad1b02f2991d3aca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port information for a custom communication channel.  <a href="#a90efeebcf56612ad1b02f2991d3aca82">More...</a><br /></td></tr>
<tr class="separator:a90efeebcf56612ad1b02f2991d3aca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19d4bbf1c8331a77c1583800314fb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae19d4bbf1c8331a77c1583800314fb60">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:ae19d4bbf1c8331a77c1583800314fb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the log file with the given <em>filename</em>.  <a href="#ae19d4bbf1c8331a77c1583800314fb60">More...</a><br /></td></tr>
<tr class="separator:ae19d4bbf1c8331a77c1583800314fb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552d32d161eb719c0ca469385581c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f">lastResult</a> (void) const </td></tr>
<tr class="memdesc:a6552d32d161eb719c0ca469385581c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="#a6552d32d161eb719c0ca469385581c2f">More...</a><br /></td></tr>
<tr class="separator:a6552d32d161eb719c0ca469385581c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec">lastResultText</a> (void) const </td></tr>
<tr class="memdesc:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a>  <a href="#af3caf40d684b29db2c89f98b0c9cd9ec">More...</a><br /></td></tr>
<tr class="separator:af3caf40d684b29db2c89f98b0c9cd9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a5277fb09bfabdeb2a7aa67619f6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a22a5277fb09bfabdeb2a7aa67619f6a5">lastHardwareError</a> (void) const </td></tr>
<tr class="memdesc:a22a5277fb09bfabdeb2a7aa67619f6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last hardware error code.  <a href="#a22a5277fb09bfabdeb2a7aa67619f6a5">More...</a><br /></td></tr>
<tr class="separator:a22a5277fb09bfabdeb2a7aa67619f6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ee4875a2cda6a5950aebfd09ced18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a19ee4875a2cda6a5950aebfd09ced18d">lastHardwareErrorDeviceId</a> (void) const </td></tr>
<tr class="separator:a19ee4875a2cda6a5950aebfd09ced18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdbd84451e2f19f44d453c9a71835eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#abfdbd84451e2f19f44d453c9a71835eb">deviceCount</a> (void) const </td></tr>
<tr class="memdesc:abfdbd84451e2f19f44d453c9a71835eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected devices.  <a href="#abfdbd84451e2f19f44d453c9a71835eb">More...</a><br /></td></tr>
<tr class="separator:abfdbd84451e2f19f44d453c9a71835eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b6af07042af55cb056c6534ab02ae4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a02b6af07042af55cb056c6534ab02ae4">mainDeviceCount</a> (void) const </td></tr>
<tr class="memdesc:a02b6af07042af55cb056c6534ab02ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of main devices.  <a href="#a02b6af07042af55cb056c6534ab02ae4">More...</a><br /></td></tr>
<tr class="separator:a02b6af07042af55cb056c6534ab02ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fecb52cb85a7150ab3b5895f823e374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8fecb52cb85a7150ab3b5895f823e374">mainDeviceIds</a> (void) const </td></tr>
<tr class="memdesc:a8fecb52cb85a7150ab3b5895f823e374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available main devices.  <a href="#a8fecb52cb85a7150ab3b5895f823e374">More...</a><br /></td></tr>
<tr class="separator:a8fecb52cb85a7150ab3b5895f823e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dae55abd64daeb1a88cbc9f8e55777"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a94dae55abd64daeb1a88cbc9f8e55777">mtCount</a> (void) const </td></tr>
<tr class="memdesc:a94dae55abd64daeb1a88cbc9f8e55777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of connected MTs.  <a href="#a94dae55abd64daeb1a88cbc9f8e55777">More...</a><br /></td></tr>
<tr class="separator:a94dae55abd64daeb1a88cbc9f8e55777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b81e6e2056cbee49272335e93b3584d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6b81e6e2056cbee49272335e93b3584d">mtDeviceIds</a> (void) const </td></tr>
<tr class="memdesc:a6b81e6e2056cbee49272335e93b3584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of the available MTs.  <a href="#a6b81e6e2056cbee49272335e93b3584d">More...</a><br /></td></tr>
<tr class="separator:a6b81e6e2056cbee49272335e93b3584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aedfac6d3619be75bdb81855fc4a8c8ed">deviceIds</a> (void) const </td></tr>
<tr class="memdesc:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device IDs of all the connected devices.  <a href="#aedfac6d3619be75bdb81855fc4a8c8ed">More...</a><br /></td></tr>
<tr class="separator:aedfac6d3619be75bdb81855fc4a8c8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed69d14675d279a0fc6b0abb7612d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a9ed69d14675d279a0fc6b0abb7612d55">getDeviceFromLocationId</a> (uint16_t locationId) const </td></tr>
<tr class="memdesc:a9ed69d14675d279a0fc6b0abb7612d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device of the device on the given <em>locationId</em>.  <a href="#a9ed69d14675d279a0fc6b0abb7612d55">More...</a><br /></td></tr>
<tr class="separator:a9ed69d14675d279a0fc6b0abb7612d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77aaaa30c35b154fe843fa193fccb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ac77aaaa30c35b154fe843fa193fccb67">dockDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:ac77aaaa30c35b154fe843fa193fccb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of the dock device for the given <em>deviceId</em>.  <a href="#ac77aaaa30c35b154fe843fa193fccb67">More...</a><br /></td></tr>
<tr class="separator:ac77aaaa30c35b154fe843fa193fccb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644e0cd86bc9aafab800fd27770d4db4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a644e0cd86bc9aafab800fd27770d4db4">isDeviceWireless</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:a644e0cd86bc9aafab800fd27770d4db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected.  <a href="#a644e0cd86bc9aafab800fd27770d4db4">More...</a><br /></td></tr>
<tr class="separator:a644e0cd86bc9aafab800fd27770d4db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ae34eed83d36127b1eef98a3f9d5cc01d">isDeviceDocked</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given <em>deviceId</em> is docked.  <a href="#ae34eed83d36127b1eef98a3f9d5cc01d">More...</a><br /></td></tr>
<tr class="separator:ae34eed83d36127b1eef98a3f9d5cc01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e2ba28d2710417b2e321520597a14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a700e2ba28d2710417b2e321520597a14">loadFilterProfiles</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a700e2ba28d2710417b2e321520597a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load filter profile definitions from a settings file with the given <em>filename</em>.  <a href="#a700e2ba28d2710417b2e321520597a14">More...</a><br /></td></tr>
<tr class="separator:a700e2ba28d2710417b2e321520597a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d65a3666bdd1c5691153cc8ed79b184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7d65a3666bdd1c5691153cc8ed79b184">enabledOptions</a> (void) const </td></tr>
<tr class="memdesc:a7d65a3666bdd1c5691153cc8ed79b184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently enabled options.  <a href="#a7d65a3666bdd1c5691153cc8ed79b184">More...</a><br /></td></tr>
<tr class="separator:a7d65a3666bdd1c5691153cc8ed79b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dbc37c7024ff23878fc9146d60a8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af0dbc37c7024ff23878fc9146d60a8c3">disabledOptions</a> (void) const </td></tr>
<tr class="memdesc:af0dbc37c7024ff23878fc9146d60a8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently explicitly disabled options.  <a href="#af0dbc37c7024ff23878fc9146d60a8c3">More...</a><br /></td></tr>
<tr class="separator:af0dbc37c7024ff23878fc9146d60a8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161b1aab842c36ac535ef814a3883ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8">setOptions</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enable, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> disable)</td></tr>
<tr class="memdesc:a161b1aab842c36ac535ef814a3883ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable options.  <a href="#a161b1aab842c36ac535ef814a3883ec8">More...</a><br /></td></tr>
<tr class="separator:a161b1aab842c36ac535ef814a3883ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4347410af4204ad77de2f1eafba8b529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4347410af4204ad77de2f1eafba8b529">setOptionsForce</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enabled)</td></tr>
<tr class="memdesc:a4347410af4204ad77de2f1eafba8b529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peristently enable or disable options.  <a href="#a4347410af4204ad77de2f1eafba8b529">More...</a><br /></td></tr>
<tr class="separator:a4347410af4204ad77de2f1eafba8b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb04c842fdab3f1cd880e26c673e77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a3fcb04c842fdab3f1cd880e26c673e77">setInitialPositionLLA</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a3fcb04c842fdab3f1cd880e26c673e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current GNSS position of the system.  <a href="#a3fcb04c842fdab3f1cd880e26c673e77">More...</a><br /></td></tr>
<tr class="separator:a3fcb04c842fdab3f1cd880e26c673e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a3e46365b0381eb5bdecec5c66014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a1f9a3e46365b0381eb5bdecec5c66014">device</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId) const </td></tr>
<tr class="memdesc:a1f9a3e46365b0381eb5bdecec5c66014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> interface object associated with the supplied <em>deviceId</em>.  <a href="#a1f9a3e46365b0381eb5bdecec5c66014">More...</a><br /></td></tr>
<tr class="separator:a1f9a3e46365b0381eb5bdecec5c66014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca3e78e879d72befb8454e60a847f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#af4ca3e78e879d72befb8454e60a847f8">mainDevices</a> (void) const </td></tr>
<tr class="memdesc:af4ca3e78e879d72befb8454e60a847f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> interface objects.  <a href="#af4ca3e78e879d72befb8454e60a847f8">More...</a><br /></td></tr>
<tr class="separator:af4ca3e78e879d72befb8454e60a847f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b35f61d3495c685e6d58a193349db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a760b35f61d3495c685e6d58a193349db">broadcast</a> (void) const </td></tr>
<tr class="memdesc:a760b35f61d3495c685e6d58a193349db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the broadcast device.  <a href="#a760b35f61d3495c685e6d58a193349db">More...</a><br /></td></tr>
<tr class="separator:a760b35f61d3495c685e6d58a193349db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb8fa1b3dbed12399023cc1defb1066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a4bb8fa1b3dbed12399023cc1defb1066">transmissionReceived</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> &amp;data)</td></tr>
<tr class="memdesc:a4bb8fa1b3dbed12399023cc1defb1066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed data coming back from an Xsens device over a custom channel into XDA.  <a href="#a4bb8fa1b3dbed12399023cc1defb1066">More...</a><br /></td></tr>
<tr class="separator:a4bb8fa1b3dbed12399023cc1defb1066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f24c9ba286897b176f4fb8efd0f285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a30f24c9ba286897b176f4fb8efd0f285">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a30f24c9ba286897b176f4fb8efd0f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#a30f24c9ba286897b176f4fb8efd0f285">More...</a><br /></td></tr>
<tr class="separator:a30f24c9ba286897b176f4fb8efd0f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189065247d7fb3758a355c403c68866d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a189065247d7fb3758a355c403c68866d">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a189065247d7fb3758a355c403c68866d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#a189065247d7fb3758a355c403c68866d">More...</a><br /></td></tr>
<tr class="separator:a189065247d7fb3758a355c403c68866d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a8b49db27bd202e7b2f5d24468ec34bd1">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a8b49db27bd202e7b2f5d24468ec34bd1">More...</a><br /></td></tr>
<tr class="separator:a8b49db27bd202e7b2f5d24468ec34bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d16f25a3a9d8953641e908199133d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a177d16f25a3a9d8953641e908199133d">gotoConfig</a> (void)</td></tr>
<tr class="memdesc:a177d16f25a3a9d8953641e908199133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all sensors connected through a serial port into Configuration Mode.  <a href="#a177d16f25a3a9d8953641e908199133d">More...</a><br /></td></tr>
<tr class="separator:a177d16f25a3a9d8953641e908199133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e568e756863a1b90156a3edf11a6126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a7e568e756863a1b90156a3edf11a6126">gotoMeasurement</a> (void)</td></tr>
<tr class="memdesc:a7e568e756863a1b90156a3edf11a6126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place all sensors connected through a serial port into Measurement Mode.  <a href="#a7e568e756863a1b90156a3edf11a6126">More...</a><br /></td></tr>
<tr class="separator:a7e568e756863a1b90156a3edf11a6126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1622bed2a39870357796a242e40b92d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a1622bed2a39870357796a242e40b92d5">startRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;portName)</td></tr>
<tr class="memdesc:a1622bed2a39870357796a242e40b92d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts restore communication procedure.  <a href="#a1622bed2a39870357796a242e40b92d5">More...</a><br /></td></tr>
<tr class="separator:a1622bed2a39870357796a242e40b92d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a860d65c4d0bf5204dad8ba665a301"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14a860d65c4d0bf5204dad8ba665a301"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a14a860d65c4d0bf5204dad8ba665a301">stopRestoreCommunication</a> (void)</td></tr>
<tr class="memdesc:a14a860d65c4d0bf5204dad8ba665a301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops restore communication procedure. <br /></td></tr>
<tr class="separator:a14a860d65c4d0bf5204dad8ba665a301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a370ec5f19b1c42b23d9d7abd453787c4">~XsControl</a> ()</td></tr>
<tr class="memdesc:a370ec5f19b1c42b23d9d7abd453787c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it. ">destruct()</a> function to clean up object.  <a href="#a370ec5f19b1c42b23d9d7abd453787c4">More...</a><br /></td></tr>
<tr class="separator:a370ec5f19b1c42b23d9d7abd453787c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dc054a1f43f78b97ef132689df0109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6dc054a1f43f78b97ef132689df0109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#ab6dc054a1f43f78b97ef132689df0109">operator delete</a> (void *)</td></tr>
<tr class="memdesc:ab6dc054a1f43f78b97ef132689df0109"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded delete operator to allow user to use delete instead of calling <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it. ">destruct()</a> function <br /></td></tr>
<tr class="separator:ab6dc054a1f43f78b97ef132689df0109"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6c54fd6126e517381f9a063c5fb8a117"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c54fd6126e517381f9a063c5fb8a117"></a>
static <a class="el" href="struct_xs_control.html">XsControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#a6c54fd6126e517381f9a063c5fb8a117">construct</a> (void)</td></tr>
<tr class="memdesc:a6c54fd6126e517381f9a063c5fb8a117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new XsControl* object. Clean it up with the <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it. ">destruct()</a> function or delete the object. <br /></td></tr>
<tr class="separator:a6c54fd6126e517381f9a063c5fb8a117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6e97e9dad8eea2681994d9d31cd272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">resultText</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> resultCode)</td></tr>
<tr class="memdesc:aee6e97e9dad8eea2681994d9d31cd272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptive text for the given <em>resultCode</em>.  <a href="#aee6e97e9dad8eea2681994d9d31cd272">More...</a><br /></td></tr>
<tr class="separator:aee6e97e9dad8eea2681994d9d31cd272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High level Motion Tracker (MT) management class. </p>
<p>CMT version 2 and higher do not use the explicit error codes that CMT version 1 used. Most functions return a boolean indicating success, a null-object, empty lists or nothing at all. In some cases more in-depth knowledge of the last error is required. For these occasions, use <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a> or <a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the accompanying error text for the value returned by lastResult() ">lastResultText()</a> to find out what exactly went wrong.</p>
<dl class="section note"><dt>Note</dt><dd>This object cannot be copied. The copy constructor has been disabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__cinterface.html">C Interface</a> For the C interface <a class="el" href="group__functions.html">Global functions</a>. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a370ec5f19b1c42b23d9d7abd453787c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::~XsControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, calls <a class="el" href="struct_xs_control.html#a383124de0bf073f72800eb1905008eee" title="Destruct a XsControl object and free all memory allocated for it. ">destruct()</a> function to clean up object. </p>
<p>Destroy this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> object.</p>
<p>All connected devices are put in config mode. All serial ports and files are subsequently closed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3" title="Close all ports and files. ">close()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a189065247d7fb3758a355c403c68866d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a760b35f61d3495c685e6d58a193349db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::broadcast </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the broadcast device. </p>
<p>The broadcast device can be used to apply an operation to all connected devices at once (if they support it) </p><dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> pointer representing the broadcast device </dd></dl>

</div>
</div>
<a class="anchor" id="a30f24c9ba286897b176f4fb8efd0f285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all connected devices as well (true, default) or just the callback handlers of the XsControl object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7036c83440d05deb5d2286c0f7da2c0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::clearHardwareError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the last hardware error. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a22a5277fb09bfabdeb2a7aa67619f6a5" title="Get the last hardware error code. ">lastHardwareError()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a0281f1055d6080734ce67526e2210fd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close all ports and files. </p>
<p>All devices are put in config mode before the serial port is closed. </p>

</div>
</div>
<a class="anchor" id="a90cfd08f3e7c65b057062bcbed1f425b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closeCustomPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes a custom communication channel. </p>
<dl class="section note"><dt>Note</dt><dd>When closing a custom channel the device will not be switched to config mode. This must be done manually </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a9ec3280fe994031d49975f99300ee5bb" title="Put the device in config mode. ">XsDevice::gotoConfig</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the channel to close. This identifier must match with the one used to open the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d" title="Open a custom communication channel. ">openCustomPort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3617d4a55cf48ddf7257788e1d5a79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the serial port with the given <em>portname</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portname</td><td>the name of the port to close (e.g. COM1 on Windows, /dev/ttyUSB0 on Linux) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee2a3ac5d55588c89de12347b17304a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the port that is used for communication with the given <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The device ID to clos eth port for. When 0, the first available port is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When the port hosts multiple devices, this function will make all devices connected to the port invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a16ce0525bfbd2726822d8d04306f8ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the serial port that matches <em>portinfo</em>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>A port information structure that contains the name of the port to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a9b3617d4a55cf48ddf7257788e1d5a79" title="Close the serial port with the given portname. ">closePort(const XsString&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0525d061264b6622fc2aa68aff592746"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::closePort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the device port with the given <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>. </p>
<p>All connected devices are put in config mode before the port is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> obtained with the <a class="el" href="struct_xs_control.html#a1f9a3e46365b0381eb5bdecec5c66014" title="Returns the XsDevice interface object associated with the supplied deviceId. ">device()</a> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a1f9a3e46365b0381eb5bdecec5c66014" title="Returns the XsDevice interface object associated with the supplied deviceId. ">device()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a90efeebcf56612ad1b02f2991d3aca82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> XsControl::customPortInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the port information for a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The port info for the given channel </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6076a44725ba5f8bbe31fdcd4865585d" title="Open a custom communication channel. ">openCustomPort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f9a3e46365b0381eb5bdecec5c66014"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> interface object associated with the supplied <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>The ID of the device to return, 0 to return the first available main device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> attached to the <em>deviceId</em> or 0 if the device was not found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a760b35f61d3495c685e6d58a193349db" title="Returns the broadcast device. ">broadcast()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abfdbd84451e2f19f44d453c9a71835eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::deviceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of connected devices </dd></dl>

</div>
</div>
<a class="anchor" id="aedfac6d3619be75bdb81855fc4a8c8ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::deviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of all the connected devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the device IDs of all the connected devices. </dd></dl>

</div>
</div>
<a class="anchor" id="af0dbc37c7024ff23878fc9146d60a8c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsControl::disabledOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the currently explicitly disabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are set to be explicitly disabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options. ">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a7d65a3666bdd1c5691153cc8ed79b184" title="Return the currently enabled options. ">enabledOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac77aaaa30c35b154fe843fa193fccb67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::dockDeviceId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device ID of the dock device for the given <em>deviceId</em>. </p>
<p>This function returns the ID of the docking station that deviceId is plugged into. If the docking station itself is not an open port in this <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> or the device is not plugged into a docking station, the function will return a 0 id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to find the dock parent for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the device that has <em>deviceId</em> docked</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#ae34eed83d36127b1eef98a3f9d5cc01d" title="Test if the given deviceId is docked. ">isDeviceDocked</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d65a3666bdd1c5691153cc8ed79b184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsControl::enabledOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the currently enabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are set to be enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options. ">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#af0dbc37c7024ff23878fc9146d60a8c3" title="Return the currently explicitly disabled options. ">disabledOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a079133394e619b8620e15fb2b1a3e0d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::flushInputBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the inbound data buffers of all devices. </p>

</div>
</div>
<a class="anchor" id="a9ed69d14675d279a0fc6b0abb7612d55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsControl::getDeviceFromLocationId </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locationId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device of the device on the given <em>locationId</em>. </p>
<p>If the location ID is not found, the lastResult value is set and the function returns a nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationId</td><td>the location ID of the device we're looking for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the device for <em>locationId</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a177d16f25a3a9d8953641e908199133d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place all sensors connected through a serial port into Configuration Mode. </p>
<p>This function is called before <a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3" title="Close all ports and files. ">close()</a> in the destructor of the class. /sa <a class="el" href="struct_xs_control.html#a0281f1055d6080734ce67526e2210fd3" title="Close all ports and files. ">close()</a> </p>

</div>
</div>
<a class="anchor" id="a7e568e756863a1b90156a3edf11a6126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::gotoMeasurement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place all sensors connected through a serial port into Measurement Mode. </p>
<p>The function places the sensors in measurement mode in the appropriate order as they are sorted by sortBySync. </p>

</div>
</div>
<a class="anchor" id="ae34eed83d36127b1eef98a3f9d5cc01d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceDocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is docked. </p>
<p>Only wireless devices can be regarded as docked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a644e0cd86bc9aafab800fd27770d4db4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::isDeviceWireless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the given <em>deviceId</em> is an MTw and if it is wirelessly connected. </p>
<p>If the device ID is not found, the function returns false and the lastResult value is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceId</td><td>the ID of the device to investigate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is wirelessly connected, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a22a5277fb09bfabdeb2a7aa67619f6a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::lastHardwareError </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last hardware error code. </p>
<dl class="section return"><dt>Returns</dt><dd>The last hardware error </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode. ">resultText()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a19ee4875a2cda6a5950aebfd09ced18d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsControl::lastHardwareErrorDeviceId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device ID that caused the last hardware error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6552d32d161eb719c0ca469385581c2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::lastResult </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p><dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode. ">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec" title="Get the accompanying error text for the value returned by lastResult() ">lastResultText()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3caf40d684b29db2c89f98b0c9cd9ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::lastResultText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the accompanying error text for the value returned by <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a> </p>
<p>This is more than a convenience function for </p><div class="fragment"><div class="line"><a class="code" href="struct_xs_string.html">XsString</a> <a class="code" href="struct_xs_control.html#af3caf40d684b29db2c89f98b0c9cd9ec">lastResultText</a> = <a class="code" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272">XsControl::resultText</a>(xscontrol-&gt;lastResult());</div></div><!-- fragment --><p> It may provide situation-specific information instead. </p><dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#aee6e97e9dad8eea2681994d9d31cd272" title="Get a descriptive text for the given resultCode. ">resultText(XsResultValue)</a>, <a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a700e2ba28d2710417b2e321520597a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::loadFilterProfiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load filter profile definitions from a settings file with the given <em>filename</em>. </p>
<p>To use the filtering properly, XDA requires filter settings usually stored in a scenarios.xsb file. XSB is the Xsens Settings Binary format. This function allows you to specify the full path + filename to use instead of the default filter profiles embedded in the dll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The full path+filename to use for loading the parameters. When empty, the default filter profiles are loaded. On Linux this is "./scenarios.xsb", on Windows it is read from the dll resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a02b6af07042af55cb056c6534ab02ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mainDeviceCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of main devices. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of main devices </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a8fecb52cb85a7150ab3b5895f823e374" title="Get the device IDs of the available main devices. ">mainDeviceIds()</a>, mainDeviceId(const XsDeviceId&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a8fecb52cb85a7150ab3b5895f823e374"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mainDeviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of the available main devices. </p>
<p>Main devices are the devices communicating with the serial port, typically Bodypacks, Awinda Stations and stand-alone MTis or MTxs. </p><dl class="section return"><dt>Returns</dt><dd>a std::vector with the device IDs. </dd></dl>

</div>
</div>
<a class="anchor" id="af4ca3e78e879d72befb8454e60a847f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> XsControl::mainDevices </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all main <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> interface objects. </p>
<dl class="section return"><dt>Returns</dt><dd>A list containing pointers to the main device <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a94dae55abd64daeb1a88cbc9f8e55777"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsControl::mtCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of connected MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of MTs, including both main and child devices.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6b81e6e2056cbee49272335e93b3584d" title="Get the device IDs of the available MTs. ">mtDeviceIds()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b81e6e2056cbee49272335e93b3584d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &gt; XsControl::mtDeviceIds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device IDs of the available MTs. </p>
<dl class="section return"><dt>Returns</dt><dd>A std::vector with the device IDs. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a94dae55abd64daeb1a88cbc9f8e55777" title="Get the number of connected MTs. ">mtCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6076a44725ba5f8bbe31fdcd4865585d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openCustomPort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channelLatency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>User-provided identifier for the custom channel. Supplying the same channel Id more than once gives a XV_ALREADYOPEN result (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getLastResult) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelLatency</td><td>The worst-case round-trip delay in milliseconds induced by the custom channel. XDA will add this latency to its communication timeout values </td></tr>
    <tr><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port was successfully opened. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a90cfd08f3e7c65b057062bcbed1f425b" title="Closes a custom communication channel. ">closeCustomPort</a> </dd>
<dd>
<a class="el" href="struct_xs_control.html#a4bb8fa1b3dbed12399023cc1defb1066" title="Feed data coming back from an Xsens device over a custom channel into XDA. ">transmissionReceived</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae19d4bbf1c8331a77c1583800314fb60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the log file with the given <em>filename</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>True is the file was opened successfully. False if an error was encountered.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the file to open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a6552d32d161eb719c0ca469385581c2f" title="Get the result value of the last operation. ">lastResult()</a>, loadLogFile(), logFileName() </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcd5f3427b7509b07baf64650e56dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel on serial port with the given <em>portname</em>. </p>
<p>If opening the port is successful, the connected devices are available through the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> interface.</p>
<p>The expected value for <em>portname</em> on Microsoft Windows platforms is "COMx" where x is the port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">baudrate</td><td>The baudrate used on the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">portname</td><td>The name of the port. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(int, XsBaudRate, uint32_t, bool) </dd></dl>

</div>
</div>
<a class="anchor" id="a5bef49e962f8f86f5fecd909958c4718"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">portinfo</td><td>Contains the details of the port to open. The <em>portinfo</em> may be updated with a detected deviceid </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detectRs485</td><td>Enable more extended scan to detect rs485 devices. Only necessary if <em>portInfo</em> does not contain a device ID of an RS485 device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="aafd8ca1d0582d14e0e178b5ebdb0fa74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::openPortWithCredentials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a communication channel using the details in the supplied XsPortInfo structure using the supplied credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portinfo</td><td>Contains the details of the connection to open. The device ID in the structure may be updated by this function. </td></tr>
    <tr><td class="paramname">id</td><td>The user ID to be supplied for the authentication </td></tr>
    <tr><td class="paramname">key</td><td>The key to be supplied for the authentication </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum number of ms to try to put the device in config mode before giving up, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>openPort(const XsPortInfo &amp;, uint32_t, bool) </dd>
<dd>
openPort(const XsString &amp;, XsBaudRate, uint32_t) </dd></dl>

</div>
</div>
<a class="anchor" id="a8b49db27bd202e7b2f5d24468ec34bd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsControl::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to connected devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6e97e9dad8eea2681994d9d31cd272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsControl::resultText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>resultCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a descriptive text for the given <em>resultCode</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultCode</td><td>The result code to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>resultCode</em> translated into an XsString </dd></dl>

</div>
</div>
<a class="anchor" id="a3fcb04c842fdab3f1cd880e26c673e77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsControl::setInitialPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current GNSS position of the system. </p>
<p>This function will update the Latitude, Longitude and Altitude of the system and all connected devices. This differs from <a class="el" href="struct_xs_control.html#a760b35f61d3495c685e6d58a193349db" title="Returns the broadcast device. ">broadcast()</a>-&gt;<a class="el" href="struct_xs_control.html#a3fcb04c842fdab3f1cd880e26c673e77" title="Sets the current GNSS position of the system. ">setInitialPositionLLA()</a> in that the setting is persistent for the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> and will be applied to devices connected after the setting has been made. Note: this XDA data type is the setting initialPositionLLA, which is set by setInitialPositionLLA. It's value is therefore static. Use LatitudeLongitude to retrieve the live position data from the MTi. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>A vector containing the desired Latitude, Longitude and Altitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true since the function always succeeds, the boolean return value is for consistency in the interface. </dd></dl>

</div>
</div>
<a class="anchor" id="a161b1aab842c36ac535ef814a3883ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peristently enable or disable options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. In case of conflict, <em>enable</em> supersedes <em>disable</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A logically OR'ed combination of XsOptions to enable </td></tr>
    <tr><td class="paramname">disable</td><td>A logically OR'ed combination of XsOptions to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>While <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> uses these options in an additional manner, remembering whatever was enabled/disabled before, calling the <a class="el" href="struct_xs_control.html" title="High level Motion Tracker (MT) management class. ">XsControl</a> version replaces all its remembered enable/disable values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a4347410af4204ad77de2f1eafba8b529" title="Peristently enable or disable options. ">setOptionsForce</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4347410af4204ad77de2f1eafba8b529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::setOptionsForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peristently enable or disable options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. This function remembers the setting and applies it to new devices when they are created as well as broadcasting it to existing devices. Any non-enabled options are explicitly disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>A logically OR'ed combination of the desired enabled XsOptions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Contrary to <em>setOptions</em> this function will do a hard override of all options of the child devices as it will assume that any non-enabled option should be specifically disabled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_control.html#a161b1aab842c36ac535ef814a3883ec8" title="Peristently enable or disable options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1622bed2a39870357796a242e40b92d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsControl::startRestoreCommunication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>portName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts restore communication procedure. </p>
<p>Restores the communication settings to the default factory settings. </p><dl class="section note"><dt>Note</dt><dd>Works with RS422 and legacy products only. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>the name of port to which device is connected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if restore communication procedure was successfull. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bb8fa1b3dbed12399023cc1defb1066"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsControl::transmissionReceived </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Feed data coming back from an Xsens device over a custom channel into XDA. </p>
<dl class="section note"><dt>Note</dt><dd>For correct operation of XDA it is key that the transmissionReceived function is called from a separate thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user-provided identifier of the custom channel </td></tr>
    <tr><td class="paramname">data</td><td>The data to feed back into XDA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
