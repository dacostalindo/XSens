<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MtbFileCommunicator Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_mtb_file_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MtbFileCommunicator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that is used for the communcation with a mtb file.  
 <a href="class_mtb_file_communicator.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MtbFileCommunicator:</div>
<div class="dyncontent">
<div class="center"><img src="class_mtb_file_communicator__inherit__graph.png" border="0" usemap="#_mtb_file_communicator_inherit__map" alt="Inheritance graph"/></div>
<map name="_mtb_file_communicator_inherit__map" id="_mtb_file_communicator_inherit__map">
<area shape="rect" id="node2" href="struct_communicator.html" title="A base struct for a communication interface. " alt="" coords="25,229,132,256"/>
<area shape="rect" id="node3" href="class_callback_manager_xda.html" title="Class that delegates callbacks to registered XsCallbackHandlerItems. " alt="" coords="5,155,152,181"/>
<area shape="rect" id="node4" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API. " alt="" coords="34,80,123,107"/>
<area shape="rect" id="node5" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API. " alt="" coords="15,5,143,32"/>
<area shape="rect" id="node6" href="class_file_loader.html" title="A class that loads file. " alt="" coords="156,229,239,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abae513861c8502a1126f44cc380ab750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abae513861c8502a1126f44cc380ab750"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#abae513861c8502a1126f44cc380ab750">MtbFileCommunicator</a> ()</td></tr>
<tr class="memdesc:abae513861c8502a1126f44cc380ab750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:abae513861c8502a1126f44cc380ab750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9">closeLogFile</a> () override</td></tr>
<tr class="memdesc:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="#a78208205ae08de9eb3c5c6af6ec98ae9">More...</a><br /></td></tr>
<tr class="separator:a78208205ae08de9eb3c5c6af6ec98ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ba4a98023822449dae795d7ae4a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a312ba4a98023822449dae795d7ae4a72">readMessage</a> (uint8_t msgId=0) override</td></tr>
<tr class="memdesc:a312ba4a98023822449dae795d7ae4a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the open file.  <a href="#a312ba4a98023822449dae795d7ae4a72">More...</a><br /></td></tr>
<tr class="separator:a312ba4a98023822449dae795d7ae4a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86e20a386e73ddce139bb7e312e9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a3c86e20a386e73ddce139bb7e312e9fa">readMessageFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0) override</td></tr>
<tr class="memdesc:a3c86e20a386e73ddce139bb7e312e9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the start of the open file.  <a href="#a3c86e20a386e73ddce139bb7e312e9fa">More...</a><br /></td></tr>
<tr class="separator:a3c86e20a386e73ddce139bb7e312e9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8207e51e5e32f36da3c50688b75bf5"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="struct_xs_message.html">XsMessage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a9b8207e51e5e32f36da3c50688b75bf5">readMessagesFromStartOfFile</a> (uint8_t msgId, int maxMsgs=0) override</td></tr>
<tr class="memdesc:a9b8207e51e5e32f36da3c50688b75bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read multiple similar messages from the start of the open file.  <a href="#a9b8207e51e5e32f36da3c50688b75bf5">More...</a><br /></td></tr>
<tr class="separator:a9b8207e51e5e32f36da3c50688b75bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78b4b21bcfc147f7cc423c8fa6b06c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa78b4b21bcfc147f7cc423c8fa6b06c8">loadLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *device) override</td></tr>
<tr class="memdesc:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a log file with thread pool. <br /></td></tr>
<tr class="separator:aa78b4b21bcfc147f7cc423c8fa6b06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b981acbb7792e315d876866ed1912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa81b981acbb7792e315d876866ed1912">abortLoadLogFile</a> () override</td></tr>
<tr class="memdesc:aa81b981acbb7792e315d876866ed1912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a process that takes a long time to complete.  <a href="#aa81b981acbb7792e315d876866ed1912">More...</a><br /></td></tr>
<tr class="separator:aa81b981acbb7792e315d876866ed1912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c932f470af852f095a7ff41f774234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234">openLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename) override</td></tr>
<tr class="memdesc:a98c932f470af852f095a7ff41f774234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a log file for input.  <a href="#a98c932f470af852f095a7ff41f774234">More...</a><br /></td></tr>
<tr class="separator:a98c932f470af852f095a7ff41f774234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d59ed9a6ad743520cd2707ebeb878"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36d59ed9a6ad743520cd2707ebeb878"></a>
<a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa36d59ed9a6ad743520cd2707ebeb878">logFileName</a> () const override</td></tr>
<tr class="memdesc:aa36d59ed9a6ad743520cd2707ebeb878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the name of the open log file or an empty string if no log file is open. <br /></td></tr>
<tr class="separator:aa36d59ed9a6ad743520cd2707ebeb878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425a367a771a94d1e47dcb791bc3b9d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425a367a771a94d1e47dcb791bc3b9d2"></a>
<a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a425a367a771a94d1e47dcb791bc3b9d2">logFileSize</a> () const override</td></tr>
<tr class="memdesc:a425a367a771a94d1e47dcb791bc3b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of the open log file in bytes. <br /></td></tr>
<tr class="separator:a425a367a771a94d1e47dcb791bc3b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9805bfdb282c86fac2b0303a4a36bbd7"></a>
<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a9805bfdb282c86fac2b0303a4a36bbd7">logFileDate</a> () const override</td></tr>
<tr class="memdesc:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the date of the open log file. <br /></td></tr>
<tr class="separator:a9805bfdb282c86fac2b0303a4a36bbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aaebdd9ca5ea57f90521be8b1dc1965c7">logFileReadPosition</a> () const override</td></tr>
<tr class="memdesc:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the read position of the log file.  <a href="#aaebdd9ca5ea57f90521be8b1dc1965c7">More...</a><br /></td></tr>
<tr class="separator:aaebdd9ca5ea57f90521be8b1dc1965c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a28b0202be2b95f6bcc0f5d5bda35d7d8">resetLogFileReadPosition</a> (void) override</td></tr>
<tr class="memdesc:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart reading from the start of the open log file.  <a href="#a28b0202be2b95f6bcc0f5d5bda35d7d8">More...</a><br /></td></tr>
<tr class="separator:a28b0202be2b95f6bcc0f5d5bda35d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b00cea4663b9472e39499cc9e3b2602"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b00cea4663b9472e39499cc9e3b2602"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a8b00cea4663b9472e39499cc9e3b2602">isReadingFromFile</a> () const override</td></tr>
<tr class="memdesc:a8b00cea4663b9472e39499cc9e3b2602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether we are reading from file. <br /></td></tr>
<tr class="separator:a8b00cea4663b9472e39499cc9e3b2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d3ca888b5603ab469bc1f1ac79de6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ad1d3ca888b5603ab469bc1f1ac79de6e">isLoadLogFileInProgress</a> () const override</td></tr>
<tr class="separator:ad1d3ca888b5603ab469bc1f1ac79de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282c87d08be4df4711e6d98f57d3027d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a282c87d08be4df4711e6d98f57d3027d">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;msg, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv, uint32_t timeout) override</td></tr>
<tr class="memdesc:a282c87d08be4df4711e6d98f57d3027d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretend to be a live system.  <a href="#a282c87d08be4df4711e6d98f57d3027d">More...</a><br /></td></tr>
<tr class="separator:a282c87d08be4df4711e6d98f57d3027d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ce6dc7dfa92438f88c1bee18197f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a49ce6dc7dfa92438f88c1bee18197f12">gotoConfig</a> (bool detectRs485=false) override</td></tr>
<tr class="memdesc:a49ce6dc7dfa92438f88c1bee18197f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to config mode.  <a href="#a49ce6dc7dfa92438f88c1bee18197f12">More...</a><br /></td></tr>
<tr class="separator:a49ce6dc7dfa92438f88c1bee18197f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f59969ccaa52892a8484bb987267e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a345f59969ccaa52892a8484bb987267e">gotoMeasurement</a> () override</td></tr>
<tr class="memdesc:a345f59969ccaa52892a8484bb987267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to go to measurement mode.  <a href="#a345f59969ccaa52892a8484bb987267e">More...</a><br /></td></tr>
<tr class="separator:a345f59969ccaa52892a8484bb987267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfac8c5baf5899efdf13d3ab571d30f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aadfac8c5baf5899efdf13d3ab571d30f">getDeviceId</a> () override</td></tr>
<tr class="memdesc:aadfac8c5baf5899efdf13d3ab571d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a device to get device ID.  <a href="#aadfac8c5baf5899efdf13d3ab571d30f">More...</a><br /></td></tr>
<tr class="separator:aadfac8c5baf5899efdf13d3ab571d30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1645929c7d07b082781a3d242be48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ace1645929c7d07b082781a3d242be48f">setGotoConfigTimeout</a> (uint32_t timeout) override</td></tr>
<tr class="memdesc:ace1645929c7d07b082781a3d242be48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timeout for the gotoConfig function.  <a href="#ace1645929c7d07b082781a3d242be48f">More...</a><br /></td></tr>
<tr class="separator:ace1645929c7d07b082781a3d242be48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449e545f43bff28ba7971288f1f4f924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a449e545f43bff28ba7971288f1f4f924">writeMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message) override</td></tr>
<tr class="memdesc:a449e545f43bff28ba7971288f1f4f924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message to the device.  <a href="#a449e545f43bff28ba7971288f1f4f924">More...</a><br /></td></tr>
<tr class="separator:a449e545f43bff28ba7971288f1f4f924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5532cbf527b981ab5001782c422ed7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5532cbf527b981ab5001782c422ed7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ae5532cbf527b981ab5001782c422ed7b">flushPort</a> () override</td></tr>
<tr class="memdesc:ae5532cbf527b981ab5001782c422ed7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all remaining data on the open port. <br /></td></tr>
<tr class="separator:ae5532cbf527b981ab5001782c422ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ef7c7ac43ae74e766e47591e79468"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa8ef7c7ac43ae74e766e47591e79468"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aaa8ef7c7ac43ae74e766e47591e79468">closePort</a> () override</td></tr>
<tr class="memdesc:aaa8ef7c7ac43ae74e766e47591e79468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the open port. <br /></td></tr>
<tr class="separator:aaa8ef7c7ac43ae74e766e47591e79468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ab4a685db5ae979f0c5d8a711ab06b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a87ab4a685db5ae979f0c5d8a711ab06b">isPortOpen</a> () const override</td></tr>
<tr class="separator:a87ab4a685db5ae979f0c5d8a711ab06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90baa66d3f9098833531da0b8be26b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a90baa66d3f9098833531da0b8be26b4a">portInfo</a> () const override</td></tr>
<tr class="separator:a90baa66d3f9098833531da0b8be26b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49568e601aed36f9b2f1ec4da338f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ae49568e601aed36f9b2f1ec4da338f46">openPort</a> (const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;<a class="el" href="class_mtb_file_communicator.html#a90baa66d3f9098833531da0b8be26b4a">portInfo</a>, <a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool detectRs485=false) override</td></tr>
<tr class="memdesc:ae49568e601aed36f9b2f1ec4da338f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a port.  <a href="#ae49568e601aed36f9b2f1ec4da338f46">More...</a><br /></td></tr>
<tr class="separator:ae49568e601aed36f9b2f1ec4da338f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a515b5fc108dd7f5e6ff82ec8ccae08ec">reopenPort</a> (<a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a> stage=OPS_Full, bool skipDeviceIdCheck=false) override</td></tr>
<tr class="memdesc:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens the port.  <a href="#a515b5fc108dd7f5e6ff82ec8ccae08ec">More...</a><br /></td></tr>
<tr class="separator:a515b5fc108dd7f5e6ff82ec8ccae08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d55258bda7ded6b97fd244562deb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa68d55258bda7ded6b97fd244562deb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#aa68d55258bda7ded6b97fd244562deb8">isDockedAt</a> (<a class="el" href="struct_communicator.html">Communicator</a> *other) const override</td></tr>
<tr class="memdesc:aa68d55258bda7ded6b97fd244562deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <em>other</em> device is docked at this device. <br /></td></tr>
<tr class="separator:aa68d55258bda7ded6b97fd244562deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1be6bd7d143b4e1a1f2774cf21385bae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a1be6bd7d143b4e1a1f2774cf21385bae">setKeepAlive</a> (bool enable) override</td></tr>
<tr class="memdesc:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either disable or enable (default) the keep alive mechanism (if supported by the device) <br /></td></tr>
<tr class="separator:a1be6bd7d143b4e1a1f2774cf21385bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004d7d02ad4007707f78064a658dc930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a004d7d02ad4007707f78064a658dc930">addProtocolHandler</a> (<a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *handler) override</td></tr>
<tr class="memdesc:a004d7d02ad4007707f78064a658dc930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the protocol handler.  <a href="#a004d7d02ad4007707f78064a658dc930">More...</a><br /></td></tr>
<tr class="separator:a004d7d02ad4007707f78064a658dc930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d72b1fa5445ee561db946408dfc924f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0d72b1fa5445ee561db946408dfc924f">destroy</a> ()</td></tr>
<tr class="memdesc:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the communicator. <br /></td></tr>
<tr class="separator:a0d72b1fa5445ee561db946408dfc924f inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af732adc9e6e84804da996b715c83c803"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#af732adc9e6e84804da996b715c83c803">Communicator</a> (void)</td></tr>
<tr class="memdesc:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates some management objects and clears the rest by calling initialize() <br /></td></tr>
<tr class="separator:af732adc9e6e84804da996b715c83c803 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9adcf4eecb610758e57efeddd79e100f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a9adcf4eecb610758e57efeddd79e100f">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a9adcf4eecb610758e57efeddd79e100f inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54cb436aa72f757dfec1968cb50d69dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a54cb436aa72f757dfec1968cb50d69dc">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, uint32_t timeout)</td></tr>
<tr class="memdesc:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a54cb436aa72f757dfec1968cb50d69dc inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49ea360b8a63d1f9325b9ff01fffd0d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a49ea360b8a63d1f9325b9ff01fffd0d8">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv)</td></tr>
<tr class="memdesc:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message and await the reply. <br /></td></tr>
<tr class="separator:a49ea360b8a63d1f9325b9ff01fffd0d8 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e8a600fa59679e03debe2e6825a2bc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7e8a600fa59679e03debe2e6825a2bc4">setDefaultTimeout</a> (uint32_t timeout)</td></tr>
<tr class="memdesc:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a default <em>timeout</em>. <br /></td></tr>
<tr class="separator:a7e8a600fa59679e03debe2e6825a2bc4 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cabbb065e5893423d077699c0b42ce2 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7cabbb065e5893423d077699c0b42ce2">defaultTimeout</a> () const </td></tr>
<tr class="separator:a7cabbb065e5893423d077699c0b42ce2 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd9858b016cf1185258cc6161f72490 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#afbd9858b016cf1185258cc6161f72490">lastResult</a> () const </td></tr>
<tr class="memdesc:afbd9858b016cf1185258cc6161f72490 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="#afbd9858b016cf1185258cc6161f72490">More...</a><br /></td></tr>
<tr class="separator:afbd9858b016cf1185258cc6161f72490 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361d1f6ffda0eca0ea7a78e1404784a8 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a361d1f6ffda0eca0ea7a78e1404784a8">lastResultText</a> () const </td></tr>
<tr class="memdesc:a361d1f6ffda0eca0ea7a78e1404784a8 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_communicator.html#afbd9858b016cf1185258cc6161f72490" title="Get the result value of the last operation. ">lastResult()</a> It may provide situation-specific information instead.  <a href="#a361d1f6ffda0eca0ea7a78e1404784a8">More...</a><br /></td></tr>
<tr class="separator:a361d1f6ffda0eca0ea7a78e1404784a8 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a148c456f7ef9c9c2fb8c7ef4ee259e35"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a148c456f7ef9c9c2fb8c7ef4ee259e35">handleMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a <em>message</em>. <br /></td></tr>
<tr class="separator:a148c456f7ef9c9c2fb8c7ef4ee259e35 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddbcc3b1a34a83e120a4172068c489b inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#abddbcc3b1a34a83e120a4172068c489b">childDeviceCount</a> () const </td></tr>
<tr class="separator:abddbcc3b1a34a83e120a4172068c489b inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6f5d28e6dae4aa1e63ba41c1f5115 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a3ee6f5d28e6dae4aa1e63ba41c1f5115">masterDeviceId</a> () const </td></tr>
<tr class="separator:a3ee6f5d28e6dae4aa1e63ba41c1f5115 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aba83d20bf72bcfc7df91564159d2a947">addReplyObject</a> (uint8_t mid)</td></tr>
<tr class="memdesc:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_reply_object.html" title="Reply object that only checks the message identifier. ">MidReplyObject</a>.  <a href="#aba83d20bf72bcfc7df91564159d2a947">More...</a><br /></td></tr>
<tr class="separator:aba83d20bf72bcfc7df91564159d2a947 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a331d3bc7f8845fd6d8b62a64dde8f9a5">addReplyObject</a> (uint8_t mid, XsSize offset, XsSize size, uint8_t const *data)</td></tr>
<tr class="memdesc:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="class_mid_and_data_reply_object.html" title="Reply object that checks the message identifier and data in the data field. ">MidAndDataReplyObject</a>.  <a href="#a331d3bc7f8845fd6d8b62a64dde8f9a5">More...</a><br /></td></tr>
<tr class="separator:a331d3bc7f8845fd6d8b62a64dde8f9a5 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a5f7cb30f37dd08db96c76ab3c86e014b">addReplyObject</a> (<a class="el" href="class_reply_object.html">ReplyObject</a> *obj)</td></tr>
<tr class="memdesc:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom <a class="el" href="class_reply_object.html" title="Abstract reply object. Blocks on a semaphore when requesting the message until the message has been s...">ReplyObject</a>.  <a href="#a5f7cb30f37dd08db96c76ab3c86e014b">More...</a><br /></td></tr>
<tr class="separator:a5f7cb30f37dd08db96c76ab3c86e014b inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a319e07bb6858d2e4a83ccfc7591b1795"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a319e07bb6858d2e4a83ccfc7591b1795">scheduleClosePort</a> ()</td></tr>
<tr class="memdesc:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules to close the open port. <br /></td></tr>
<tr class="separator:a319e07bb6858d2e4a83ccfc7591b1795 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e00d6c9fdef19be9f93004d9f0b0cc7 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a3e00d6c9fdef19be9f93004d9f0b0cc7">allowReprocessing</a> () const </td></tr>
<tr class="separator:a3e00d6c9fdef19be9f93004d9f0b0cc7 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a96aebec75db10bb2ddf1e8d677b3adcd">setCredentials</a> (<a class="el" href="struct_xs_string.html">XsString</a> const &amp;id, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;key)</td></tr>
<tr class="memdesc:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the credentials required for using the device.  <a href="#a96aebec75db10bb2ddf1e8d677b3adcd">More...</a><br /></td></tr>
<tr class="separator:a96aebec75db10bb2ddf1e8d677b3adcd inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aaaa90287f8340f085ba2e703e34fc inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae2aaaa90287f8340f085ba2e703e34fc">sanityCheck</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;msg) const </td></tr>
<tr class="memdesc:ae2aaaa90287f8340f085ba2e703e34fc inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a sanity check on a potential message.  <a href="#ae2aaaa90287f8340f085ba2e703e34fc">More...</a><br /></td></tr>
<tr class="separator:ae2aaaa90287f8340f085ba2e703e34fc inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7ef923814a0a92a47cd747f688fd5aac">removeProtocolHandler</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type)</td></tr>
<tr class="memdesc:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a protocol handler.  <a href="#a7ef923814a0a92a47cd747f688fd5aac">More...</a><br /></td></tr>
<tr class="separator:a7ef923814a0a92a47cd747f688fd5aac inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145e4ca82b09e087083fc3f2c2930bd0 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a145e4ca82b09e087083fc3f2c2930bd0">hasProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type) const </td></tr>
<tr class="separator:a145e4ca82b09e087083fc3f2c2930bd0 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adbb314734f6189e93ff0efad49d76af0">setMasterDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *<a class="el" href="struct_communicator.html#a7bc554d27b474446529fedcc7819b314">masterDevice</a>)</td></tr>
<tr class="memdesc:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device.  <a href="#adbb314734f6189e93ff0efad49d76af0">More...</a><br /></td></tr>
<tr class="separator:adbb314734f6189e93ff0efad49d76af0 inherit pub_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_callback_manager_xda"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_callback_manager_xda')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a></td></tr>
<tr class="memitem:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1409c965b88efc664a2ef7d36e5490f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a1409c965b88efc664a2ef7d36e5490f4">onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState) override</td></tr>
<tr class="memdesc:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0" title="Called when a device&#39;s state has changed (ie config mode, measurement mode, recording mode) ...">XsCallback::onDeviceStateChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebd995bd1dc83e69822f874eabb0c4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aebd995bd1dc83e69822f874eabb0c4fa">onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet) override</td></tr>
<tr class="memdesc:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e64d70ce299958605b6149049e045ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ae15c19c791af165c842441993660c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a79ae15c19c791af165c842441993660c">onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last) override</td></tr>
<tr class="memdesc:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e" title="Called when XDA detects that packets have been missed. ">XsCallback::onMissedPackets()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7738059783802ad5e1278108a467ccc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7738059783802ad5e1278108a467ccc2">onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId) override</td></tr>
<tr class="memdesc:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645" title="Called when XDA detects that data is forever unavailable. ">XsCallback::onDataUnavailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7471f499ee52bb189ef4e3917a20e5d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7471f499ee52bb189ef4e3917a20e5d0">onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) override</td></tr>
<tr class="memdesc:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a" title="Called when a wakeup message has been received from a device. This indicates that the device has just...">XsCallback::onWakeupReceived()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840ce749572d8997e33ee8f860db97c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7">onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier) override</td></tr>
<tr class="memdesc:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59" title="Called when a long-duration operation has made some progress or has completed. Examples include loadL...">XsCallback::onProgressUpdated()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad510877b529df7a85fbc5d601c2fad76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message) override</td></tr>
<tr class="memdesc:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file. ">XsCallback::onWriteMessageToLogFile()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c8eb08edd64025b3e9405415b38834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399" title="Called when XDA has a data packet that could be written to a log file. ">XsCallback::onBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2827956387a56712723e9200882179c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312575546ab44f788dd3961477ba0e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState) override</td></tr>
<tr class="memdesc:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40" title="Called when XDA has detected a change in the connectivity state of a device. ">XsCallback::onConnectivityChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01afaba0ea9f47b5c4f490ee7dba7364"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request) override</td></tr>
<tr class="memdesc:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5" title="Called when an information request has resulted in a response. ">XsCallback::onInfoResponse()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a65ae9866cb7a9e8ab11dcfeca1572f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error) override</td></tr>
<tr class="memdesc:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onError() callback forwarding function. <br /></td></tr>
<tr class="separator:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdeff1e1697266d82f232642aef0cae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onNonDataMessage() callback forwarding function. <br /></td></tr>
<tr class="separator:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af81b39fa94f8086d9682df2e53ea5e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage) override</td></tr>
<tr class="memdesc:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a760e93d7f7142fd22c7e134c4cea5f72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ec10bd8e7cf2df6b4136ad0ac9701e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageSentToDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc815adc25af17f24207573afa9c94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f103ff688afdeef381eedd6100331d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6beccc0e4760b652b7be01e859e465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14" title="Called when new data has been received from a device in a recording state or read from a file...">XsCallback::onRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c0aa7e3be74595cef490b98d1520d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6" title="Called when new data has been received for devices connected to the same main device in a recording s...">XsCallback::onAllRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data) override</td></tr>
<tr class="memdesc:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="#a503e4e781f975b8591f344c14dc6b764">More...</a><br /></td></tr>
<tr class="separator:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91bb23b63beb62d085182044abb30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result) override</td></tr>
<tr class="memdesc:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onRestoreCommunication callback forwarding function. <br /></td></tr>
<tr class="separator:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae286810bd0b4d20678987b354fa13d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ae286810bd0b4d20678987b354fa13d29">CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the callback list. <br /></td></tr>
<tr class="separator:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5910d161433653494a59986643233cf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5910d161433653494a59986643233cf6">~CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, clears the callback list. <br /></td></tr>
<tr class="separator:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback list.  <a href="#ac213910a49d4e0ccb2f64d3e25f7e1d4">More...</a><br /></td></tr>
<tr class="separator:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to the list.  <a href="#af2bc14879f1dad8db57a3cf9e2f61940">More...</a><br /></td></tr>
<tr class="separator:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#adeb706dafbcbd6a92f2a475814d18d89">More...</a><br /></td></tr>
<tr class="separator:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7c60244a13f84ca7cc06efa50d9685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acb7c60244a13f84ca7cc06efa50d9685">clearChainedManagers</a> ()</td></tr>
<tr class="memdesc:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the chained manager list. <br /></td></tr>
<tr class="separator:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">addChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a chained manager to the list.  <a href="#ad333b769cce921ccc725f1f9a6151ef6">More...</a><br /></td></tr>
<tr class="separator:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">removeChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove achained manager from the list.  <a href="#a41d22397b46a96de6b3a6a131fd296ed">More...</a><br /></td></tr>
<tr class="separator:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">copyCallbackHandlersTo</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from this manager into <em>cm</em>.  <a href="#a790347a9b6b752b9d0945ba1d956bbc1">More...</a><br /></td></tr>
<tr class="separator:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">copyCallbackHandlersFrom</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from <em>cm</em> into this manager.  <a href="#aaa87742f16fbdb230eaf79cc5ade5bb4">More...</a><br /></td></tr>
<tr class="separator:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3649aca54d1c3e0879b6ccf5dfd5d554 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3649aca54d1c3e0879b6ccf5dfd5d554">haveCallback</a> (size_t functionOffset) const </td></tr>
<tr class="separator:a3649aca54d1c3e0879b6ccf5dfd5d554 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_xs_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_xs_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_xs_callback.html">XsCallback</a></td></tr>
<tr class="memitem:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a491695016a32d02a31e2f4bda826ef47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a491695016a32d02a31e2f4bda826ef47">XsCallback</a> ()</td></tr>
<tr class="memdesc:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">~XsCallback</a> ()</td></tr>
<tr class="memdesc:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5c30ab32ed0e8ffc398672117afdd758">More...</a><br /></td></tr>
<tr class="separator:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af99a77f54a94cdbee6f8257cb339351d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99a77f54a94cdbee6f8257cb339351d"></a>
static <a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#af99a77f54a94cdbee6f8257cb339351d">construct</a> ()</td></tr>
<tr class="memdesc:af99a77f54a94cdbee6f8257cb339351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs new <a class="el" href="class_mtb_file_communicator.html" title="A class that is used for the communcation with a mtb file. ">MtbFileCommunicator</a>. <br /></td></tr>
<tr class="separator:af99a77f54a94cdbee6f8257cb339351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf315317a87ae6b114b152c1685b9ea5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#adf315317a87ae6b114b152c1685b9ea5">createUniquePtr</a> ()</td></tr>
<tr class="memdesc:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="struct_communicator.html" title="A base struct for a communication interface. ">Communicator</a> of type T and returns it as a UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:adf315317a87ae6b114b152c1685b9ea5 inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6a25ccfb89ac0b8c3d556b27ef33dcc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ac6a25ccfb89ac0b8c3d556b27ef33dcc">createUniquePtr</a> (T *communicator)</td></tr>
<tr class="memdesc:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a UniquePtr&lt;T&gt; from a Communicator*. <br /></td></tr>
<tr class="separator:ac6a25ccfb89ac0b8c3d556b27ef33dcc inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fad6bfc470a21b9165d3ed1825bc29 inherit pub_static_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab6fad6bfc470a21b9165d3ed1825bc29">configurationMessageSearchLimit</a> ()</td></tr>
<tr class="separator:ab6fad6bfc470a21b9165d3ed1825bc29 inherit pub_static_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a63ae6d289682f9f859be492f71fe7063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ae6d289682f9f859be492f71fe7063"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a63ae6d289682f9f859be492f71fe7063">MtbFileCommunicator</a> (std::shared_ptr&lt; <a class="el" href="class_io_interface_file.html">IoInterfaceFile</a> &gt; ioInterfaceFile)</td></tr>
<tr class="memdesc:a63ae6d289682f9f859be492f71fe7063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that uses <em>ioInterfaceFile</em>. <br /></td></tr>
<tr class="separator:a63ae6d289682f9f859be492f71fe7063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d80fc4d26de6b4d9c3f99b7e340f65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a03d80fc4d26de6b4d9c3f99b7e340f65">~MtbFileCommunicator</a> ()</td></tr>
<tr class="separator:a03d80fc4d26de6b4d9c3f99b7e340f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46ff0da1fa71175cd2ca5bd0c60a9cfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a46ff0da1fa71175cd2ca5bd0c60a9cfa">prepareForDestruction</a> () override</td></tr>
<tr class="memdesc:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares for the destruction. <br /></td></tr>
<tr class="separator:a46ff0da1fa71175cd2ca5bd0c60a9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f7c132f9cd8608723628afa6ccb152"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a61f7c132f9cd8608723628afa6ccb152">readLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *device) override</td></tr>
<tr class="memdesc:a61f7c132f9cd8608723628afa6ccb152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a log file into cache.  <a href="#a61f7c132f9cd8608723628afa6ccb152">More...</a><br /></td></tr>
<tr class="separator:a61f7c132f9cd8608723628afa6ccb152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb1ea7f701b999619906a9d15978ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a23cb1ea7f701b999619906a9d15978ec">readSinglePacketFromFile</a> () override</td></tr>
<tr class="memdesc:a23cb1ea7f701b999619906a9d15978ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from an open log file.  <a href="#a23cb1ea7f701b999619906a9d15978ec">More...</a><br /></td></tr>
<tr class="separator:a23cb1ea7f701b999619906a9d15978ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63788ee066d43dc26c275d4440ea4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#ab63788ee066d43dc26c275d4440ea4d3">waitForLastTaskCompletion</a> () override</td></tr>
<tr class="memdesc:ab63788ee066d43dc26c275d4440ea4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the last processing task to complete in the threadpool.  <a href="#ab63788ee066d43dc26c275d4440ea4d3">More...</a><br /></td></tr>
<tr class="separator:ab63788ee066d43dc26c275d4440ea4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81507126b264871d0a5538ad4c9a9865"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mtb_file_communicator.html#a81507126b264871d0a5538ad4c9a9865">readNextMessage</a> ()</td></tr>
<tr class="memdesc:a81507126b264871d0a5538ad4c9a9865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next message from the open file.  <a href="#a81507126b264871d0a5538ad4c9a9865">More...</a><br /></td></tr>
<tr class="separator:a81507126b264871d0a5538ad4c9a9865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ced5362bf7438924f8d7f1b0c5ec391"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4ced5362bf7438924f8d7f1b0c5ec391">~Communicator</a> ()</td></tr>
<tr class="memdesc:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, waits for the last scheduled task to complete and then cleans up the object by calling clear() <br /></td></tr>
<tr class="separator:a4ced5362bf7438924f8d7f1b0c5ec391 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc554d27b474446529fedcc7819b314 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a7bc554d27b474446529fedcc7819b314">masterDevice</a> () const </td></tr>
<tr class="separator:a7bc554d27b474446529fedcc7819b314 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19014cbac67ce24cfc843afa22668826 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a19014cbac67ce24cfc843afa22668826">protocolManager</a> () const </td></tr>
<tr class="separator:a19014cbac67ce24cfc843afa22668826 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfdfddafe2ff9b617e2db9e3eff7515 inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#abbfdfddafe2ff9b617e2db9e3eff7515">setLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#afbd9858b016cf1185258cc6161f72490">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const </td></tr>
<tr class="memdesc:abbfdfddafe2ff9b617e2db9e3eff7515 inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result.  <a href="#abbfdfddafe2ff9b617e2db9e3eff7515">More...</a><br /></td></tr>
<tr class="separator:abbfdfddafe2ff9b617e2db9e3eff7515 inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f29d5bb8e19f1fdc522bc07f6f51cd inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab1f29d5bb8e19f1fdc522bc07f6f51cd">setAndReturnLastResult</a> (<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> <a class="el" href="struct_communicator.html#afbd9858b016cf1185258cc6161f72490">lastResult</a>, <a class="el" href="struct_xs_string.html">XsString</a> const &amp;text=<a class="el" href="struct_xs_string.html">XsString</a>()) const </td></tr>
<tr class="memdesc:ab1f29d5bb8e19f1fdc522bc07f6f51cd inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the last result and returns it.  <a href="#ab1f29d5bb8e19f1fdc522bc07f6f51cd">More...</a><br /></td></tr>
<tr class="separator:ab1f29d5bb8e19f1fdc522bc07f6f51cd inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aeba6a5ee540ee88b2a7c8d7a92ab4bad">setMasterDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;deviceId)</td></tr>
<tr class="memdesc:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master device ID.  <a href="#aeba6a5ee540ee88b2a7c8d7a92ab4bad">More...</a><br /></td></tr>
<tr class="separator:aeba6a5ee540ee88b2a7c8d7a92ab4bad inherit pro_methods_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b38fd3197a742fdb2ff68ac4fcd4b0f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a0b38fd3197a742fdb2ff68ac4fcd4b0f">UniquePtr</a> = std::unique_ptr&lt; T, <a class="el" href="struct_communicator_1_1_deleter.html">Deleter</a> &gt;</td></tr>
<tr class="memdesc:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes of UniquePtr&lt;T&gt; <br /></td></tr>
<tr class="separator:a0b38fd3197a742fdb2ff68ac4fcd4b0f inherit pub_types_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_struct_xs_callback_plain_c"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct_xs_callback_plain_c')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a></td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga829650872a3b6d36a5e31a2eec5d2e2c">m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#ga829650872a3b6d36a5e31a2eec5d2e2c">More...</a><br /></td></tr>
<tr class="separator:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf0613e7c8f4082ab408fd75f97828eb7">m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#gaf0613e7c8f4082ab408fd75f97828eb7">More...</a><br /></td></tr>
<tr class="separator:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga394de49100504b50d64fd2b46ed344ab">m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga394de49100504b50d64fd2b46ed344ab">More...</a><br /></td></tr>
<tr class="separator:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga68c5f0ea480527fb420607449fc21ae2">m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#ga68c5f0ea480527fb420607449fc21ae2">More...</a><br /></td></tr>
<tr class="separator:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occured.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_struct_communicator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_struct_communicator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="struct_communicator.html">Communicator</a></td></tr>
<tr class="memitem:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ec352c0ac50f5c333baff1943e87d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#aa0ec352c0ac50f5c333baff1943e87d7">m_preparedForDestruction</a></td></tr>
<tr class="memdesc:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepared for destruction boolean variable. <br /></td></tr>
<tr class="separator:aa0ec352c0ac50f5c333baff1943e87d7 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e99c203184a28f906cda4bea0498e8b"></a>
<a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4e99c203184a28f906cda4bea0498e8b">m_masterInfo</a></td></tr>
<tr class="memdesc:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device object. <br /></td></tr>
<tr class="separator:a4e99c203184a28f906cda4bea0498e8b inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4720fef928a6aaab1dc7ec743f53a173"></a>
std::shared_ptr&lt; <a class="el" href="class_protocol_manager.html">ProtocolManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a4720fef928a6aaab1dc7ec743f53a173">m_protocolManager</a></td></tr>
<tr class="memdesc:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shared pointer to protocl manager. <br /></td></tr>
<tr class="separator:a4720fef928a6aaab1dc7ec743f53a173 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0afe5fa12dec79e590dc1dbcde56281"></a>
<a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab0afe5fa12dec79e590dc1dbcde56281">m_masterDeviceId</a></td></tr>
<tr class="memdesc:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A master device ID. <br /></td></tr>
<tr class="separator:ab0afe5fa12dec79e590dc1dbcde56281 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6345ad9fb045e3d1de7c2370deaeef63"></a>
std::unique_ptr&lt; <a class="el" href="classxsens_1_1_reply_monitor.html">xsens::ReplyMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a6345ad9fb045e3d1de7c2370deaeef63">m_replyMonitor</a></td></tr>
<tr class="memdesc:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unique pointer to a reply monitor. <br /></td></tr>
<tr class="separator:a6345ad9fb045e3d1de7c2370deaeef63 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a852b00fd08541b3fc1a7ff12684b75f9"></a>
<a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a852b00fd08541b3fc1a7ff12684b75f9">m_lastResult</a></td></tr>
<tr class="memdesc:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result variable. <br /></td></tr>
<tr class="separator:a852b00fd08541b3fc1a7ff12684b75f9 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab65c6bae276812a005291e60b9d2c47b"></a>
<a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ab65c6bae276812a005291e60b9d2c47b">m_lastResultText</a></td></tr>
<tr class="memdesc:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last result string. <br /></td></tr>
<tr class="separator:ab65c6bae276812a005291e60b9d2c47b inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90164a6964ce680a2bb6c750e3121437"></a>
<a class="el" href="classxsens_1_1_mutex.html">xsens::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#a90164a6964ce680a2bb6c750e3121437">m_handleMux</a></td></tr>
<tr class="memdesc:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle mutex. <br /></td></tr>
<tr class="separator:a90164a6964ce680a2bb6c750e3121437 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae97ac949b7898d0d52cd1e7e4db8f7a6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_communicator.html#ae97ac949b7898d0d52cd1e7e4db8f7a6">m_defaultTimeout</a></td></tr>
<tr class="memdesc:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default timeout variable. <br /></td></tr>
<tr class="separator:ae97ac949b7898d0d52cd1e7e4db8f7a6 inherit pro_attribs_struct_communicator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that is used for the communcation with a mtb file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a03d80fc4d26de6b4d9c3f99b7e340f65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MtbFileCommunicator::~MtbFileCommunicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa81b981acbb7792e315d876866ed1912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::abortLoadLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort a process that takes a long time to complete. </p>
<p>This currently only includes <a class="el" href="class_mtb_file_communicator.html#a61f7c132f9cd8608723628afa6ccb152" title="Read a log file into cache. ">readLogFile()</a> </p>

<p>Implements <a class="el" href="struct_communicator.html#adae4ff2e76a332cb0106c373f342bc79">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a004d7d02ad4007707f78064a658dc930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::addProtocolHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_protocol_handler.html">IProtocolHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the protocol handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>: The protocol hanlder to add </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="struct_communicator.html#ab9133a96d8f5d3f602981bcf1d8b74ac">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a78208205ae08de9eb3c5c6af6ec98ae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::closeLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a40bb7b535e5fbcb2657a1aa09d0ccd9e">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a282c87d08be4df4711e6d98f57d3027d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretend to be a live system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to send </td></tr>
    <tr><td class="paramname">rcv</td><td>The message to receive </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout in ms</td></tr>
  </table>
  </dd>
</dl>
<p>This one is nowhere near finished, but it does the trick for simple systems if a reply is available. </p><dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ab5c7243e499160cc244138727cc9fc3c">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="aadfac8c5baf5899efdf13d3ab571d30f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::getDeviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to get device ID. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ad8bae91c2bbbfd74e56ff0ee1bdb27d5">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a49ce6dc7dfa92438f88c1bee18197f12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::gotoConfig </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to config mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detectRs485</td><td>when set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a7e183d2fdad136d39d96bb69da118dc4">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a345f59969ccaa52892a8484bb987267e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::gotoMeasurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a device to go to measurement mode. </p>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if succeeded </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a29fecb5f975db28879d7e8cdb600ddc3">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="ad1d3ca888b5603ab469bc1f1ac79de6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::isLoadLogFileInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if load log file is in progress </dd></dl>

<p>Reimplemented from <a class="el" href="struct_communicator.html#afbc714763a92aa26b328998f1f760d64">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a87ab4a685db5ae979f0c5d8a711ab06b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::isPortOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the port is open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a5e3961efd576ab1736b51b6675a28fb3">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="aaebdd9ca5ea57f90521be8b1dc1965c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> MtbFileCommunicator::logFileReadPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the read position of the log file. </p>
<p>This function will return the current read position in the open log file in bytes from the start. </p><dl class="section note"><dt>Note</dt><dd>The read and write positions of log files are completely independent of each other. </dd>
<dd>
There is a look-ahead cache in place so even when the read position is already at the end of the file, there may still be some messages left to be read. For this reason, this function will at most return filesize-1 until the message queue is empty. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>To reset the read position, use resetLogFileReadPosition. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a28b0202be2b95f6bcc0f5d5bda35d7d8" title="Restart reading from the start of the open log file. ">resetLogFileReadPosition</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file read position </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a1d2a49e9a8ff16018c5b8d5631c63e97">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a98c932f470af852f095a7ff41f774234"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::openLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a log file for input. </p>
<p>This function opens the supplied log file for reading. The function will fail if a serial connection is currently open. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to open. It is recommended to use a fully qualified path+filename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only available in configuration mode. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a78208205ae08de9eb3c5c6af6ec98ae9" title="Close the log file. ">closeLogFile</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ab869c9bf1289e05b4289060cb3d113b2">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="ae49568e601aed36f9b2f1ec4da338f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::openPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_port_info.html">XsPortInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>portInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detectRs485</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portInfo</td><td>A port information that you want to open </td></tr>
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">detectRs485</td><td>When set to true it will try to detect and use an RS485 interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully open </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aa111ea807518c31210865dc0343a3b22">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a90baa66d3f9098833531da0b8be26b4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> MtbFileCommunicator::portInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_xs_port_info.html" title="Contains a descriptor for opening a communication port to an Xsens device. ">XsPortInfo</a> of the current port </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a1a4ba050c31e70abd4565dd505d6387c">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a61f7c132f9cd8608723628afa6ccb152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::readLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a log file into cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>: The device to read log from</td></tr>
  </table>
  </dd>
</dl>
<p>Read all data for <em>inf</em> into the cache </p><dl class="section see"><dt>See also</dt><dd>XsControl::loadLogFile </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>XRV_OK if successful </dd></dl>

<p>Implements <a class="el" href="class_file_loader.html#a84bf0c0d55da2cc3e6e8ec12496d8cd6">FileLoader</a>.</p>

</div>
</div>
<a class="anchor" id="a312ba4a98023822449dae795d7ae4a72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the open file. </p>
<p>This function will attempt to read a full message from the open device (file or COM port or USB port). If msgId is non-0, the function will look for a specific message ID. The function will read from the device, but it won't wait for data to become available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>Either 0 to read the first available message or non-0 to look for a specific message with this ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or if no matching message was found a cleared message. </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#a692484e8c4f7a588f49a3cb1123a962f">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a3c86e20a386e73ddce139bb7e312e9fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readMessageFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a message from the start of the open file. </p>
<p>This function will reset the read position in the file to the start and will then search for the message with the given message ID. After the message has been found (or not) the read position will be restored to its original position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>The ID of the message to search for </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>Optional parameter to limit the maximum number of messages to search. When 0, the function will continue until the message has been found or the end of the file has been reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The messsage that was read </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#af2651a48958605e80d6e3e4519f438d6">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a9b8207e51e5e32f36da3c50688b75bf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; <a class="el" href="struct_xs_message.html">XsMessage</a> &gt; MtbFileCommunicator::readMessagesFromStartOfFile </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMsgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read multiple similar messages from the start of the open file. </p>
<p>This function will reset the read position in the file to the start and will then search for all messages with the given message ID. Afterwards the read position will be restored to its original position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgId</td><td>The ID of the message to search for. </td></tr>
    <tr><td class="paramname">maxMsgs</td><td>Optional parameter to limit the maximum number of messages to search. When 0, the function will continue until the end of the file has been reached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The messsage that was read </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aeba8fe953887ceea6a42ae27f80d58d7">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a81507126b264871d0a5538ad4c9a9865"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> MtbFileCommunicator::readNextMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next message from the open file. </p>
<dl class="section return"><dt>Returns</dt><dd>The message that was read or an empty message if no message was found (end-of-file for example). </dd></dl>

</div>
</div>
<a class="anchor" id="a23cb1ea7f701b999619906a9d15978ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> MtbFileCommunicator::readSinglePacketFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from an open log file. </p>
<p>Read a single <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> from the log file and place it in the correct data cache(s) </p><dl class="section return"><dt>Returns</dt><dd>XRV_OK if successful </dd></dl>

<p>Implements <a class="el" href="class_file_loader.html#a1938a67d2692ba9052d94c73901debbc">FileLoader</a>.</p>

</div>
</div>
<a class="anchor" id="a515b5fc108dd7f5e6ff82ec8ccae08ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::reopenPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga8aca4a566630f3eb379a68b36db9ed17">OpenPortStage</a>&#160;</td>
          <td class="paramname"><em>stage</em> = <code>OPS_Full</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipDeviceIdCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reopens the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>A openning stage of a communication port </td></tr>
    <tr><td class="paramname">skipDeviceIdCheck</td><td>When set to true it will skip device ID check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is successfully reopened </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aa96111aa187a632a62242b5d3dd08787">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a28b0202be2b95f6bcc0f5d5bda35d7d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart reading from the start of the open log file. </p>
<p>This function resets the read position to the start of the open log file. Only the read position is affected, the write position remains the same. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_mtb_file_communicator.html#a98c932f470af852f095a7ff41f774234" title="Open a log file for input. ">openLogFile</a> </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#aacf0fb26ffe0677d133ee15b2c630f51">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="ace1645929c7d07b082781a3d242be48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::setGotoConfigTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timeout for the gotoConfig function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The desired timeout value in ms, if 0 the default value is used </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="struct_communicator.html#ac2fe2ba5aa3e4d0b89fa9cf7379444d3">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="ab63788ee066d43dc26c275d4440ea4d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MtbFileCommunicator::waitForLastTaskCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the last processing task to complete in the threadpool. </p>
<p>This function is usually called after abort() to make sure that no more processing is going on. </p>

<p>Implements <a class="el" href="struct_communicator.html#aa9dfe2fd5d802d47bfd5281bd5da471a">Communicator</a>.</p>

</div>
</div>
<a class="anchor" id="a449e545f43bff28ba7971288f1f4f924"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MtbFileCommunicator::writeMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>a message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on successful write, false otherwise. This doesn't guarantee proper delivery of the message. Use doTransaction for that </dd></dl>

<p>Implements <a class="el" href="struct_communicator.html#ad4ba37c181a66e917085a31ab09205fc">Communicator</a>.</p>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
