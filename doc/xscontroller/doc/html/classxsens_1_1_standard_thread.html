<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>xsens::StandardThread Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>xsens</b></li><li class="navelem"><a class="el" href="classxsens_1_1_standard_thread.html">StandardThread</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classxsens_1_1_standard_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xsens::StandardThread Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for a standard thread that has to perform the same action repeatedly.  
 <a href="classxsens_1_1_standard_thread.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for xsens::StandardThread:</div>
<div class="dyncontent">
<div class="center"><img src="classxsens_1_1_standard_thread__inherit__graph.png" border="0" usemap="#xsens_1_1_standard_thread_inherit__map" alt="Inheritance graph"/></div>
<map name="xsens_1_1_standard_thread_inherit__map" id="xsens_1_1_standard_thread_inherit__map">
<area shape="rect" id="node2" href="class_data_parser.html" title="A class for the data parsing on a separete thread. " alt="" coords="254,31,342,57"/>
<area shape="rect" id="node7" href="class_data_poller.html" title="A class implementing some basic data poller behavior. " alt="" coords="257,81,339,108"/>
<area shape="rect" id="node9" href="class_packet_error_rate_estimator.html" title="Thread to periodically estimate packet error rate based on expected packet rate. " alt="" coords="211,132,385,159"/>
<area shape="rect" id="node10" href="class_restore_communication.html" title="Performs restore communication procedure with a provided COM port. " alt="" coords="219,183,377,209"/>
<area shape="rect" id="node11" title="A class that contains a thread that runs in a ThreadPool to execute tasks. " alt="" coords="225,233,371,260"/>
<area shape="rect" id="node12" href="classxsens_1_1_task_thread.html" title="Class for handling small tasks. " alt="" coords="231,284,365,311"/>
<area shape="rect" id="node3" href="class_serial_communicator.html" title="A class that uses serial communication. " alt="" coords="433,31,573,57"/>
<area shape="rect" id="node4" href="class_proxy_communicator.html" title="ProxyCommunicator" alt="" coords="633,5,774,32"/>
<area shape="rect" id="node5" href="class_serial_port_communicator.html" title="A class that uses serial port to communicate. " alt="" coords="621,56,785,83"/>
<area shape="rect" id="node6" href="class_usb_communicator.html" title="A class that uses USB to communicate. " alt="" coords="833,56,964,83"/>
<area shape="rect" id="node8" href="class_mt_thread.html" title="A class that implements thread for MT. " alt="" coords="465,81,542,108"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a250180c102a9924ec3568b1e81a41203"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a250180c102a9924ec3568b1e81a41203">StandardThread</a> ()</td></tr>
<tr class="separator:a250180c102a9924ec3568b1e81a41203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff911e8e8833aa3d899572140bbfc8a3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#aff911e8e8833aa3d899572140bbfc8a3">~StandardThread</a> ()</td></tr>
<tr class="separator:aff911e8e8833aa3d899572140bbfc8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c89de3128f30408494c3dc3b90619"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a291c89de3128f30408494c3dc3b90619">startThread</a> (const char *name=NULL)</td></tr>
<tr class="memdesc:a291c89de3128f30408494c3dc3b90619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread.  <a href="#a291c89de3128f30408494c3dc3b90619">More...</a><br /></td></tr>
<tr class="separator:a291c89de3128f30408494c3dc3b90619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6944533ed32bb2c328a8ee6559c73b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6944533ed32bb2c328a8ee6559c73b17"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a6944533ed32bb2c328a8ee6559c73b17">signalStopThread</a> (void)</td></tr>
<tr class="memdesc:a6944533ed32bb2c328a8ee6559c73b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the thread to stop but does not wait for it to end. <br /></td></tr>
<tr class="separator:a6944533ed32bb2c328a8ee6559c73b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4ce5c12e072bd240c93d0c9d565cb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4ce5c12e072bd240c93d0c9d565cb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#abe4ce5c12e072bd240c93d0c9d565cb0">stopThread</a> (void) noexcept</td></tr>
<tr class="memdesc:abe4ce5c12e072bd240c93d0c9d565cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the thread to stop and waits for it to end. <br /></td></tr>
<tr class="separator:abe4ce5c12e072bd240c93d0c9d565cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37da828e3ff2ce01ac62d4ad23fe67c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a37da828e3ff2ce01ac62d4ad23fe67c5">isAlive</a> (void) volatileconst noexcept</td></tr>
<tr class="separator:a37da828e3ff2ce01ac62d4ad23fe67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade226e040d70aa698818e1bc4d2b9a6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade226e040d70aa698818e1bc4d2b9a6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#ade226e040d70aa698818e1bc4d2b9a6b">isRunning</a> (void) volatileconst noexcept</td></tr>
<tr class="memdesc:ade226e040d70aa698818e1bc4d2b9a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is currently running. <br /></td></tr>
<tr class="separator:ade226e040d70aa698818e1bc4d2b9a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4061440edb7d6dd0706a0535fefd0c01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a4061440edb7d6dd0706a0535fefd0c01">setPriority</a> (<a class="el" href="group__enums.html#gaa3140b510b8517280a7759511195ae7e">XsThreadPriority</a> pri)</td></tr>
<tr class="memdesc:a4061440edb7d6dd0706a0535fefd0c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority of the thread.  <a href="#a4061440edb7d6dd0706a0535fefd0c01">More...</a><br /></td></tr>
<tr class="separator:a4061440edb7d6dd0706a0535fefd0c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c4ab49013e266bd842d5993d56cd6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c4ab49013e266bd842d5993d56cd6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a96c4ab49013e266bd842d5993d56cd6e">isTerminating</a> () volatileconst noexcept</td></tr>
<tr class="memdesc:a96c4ab49013e266bd842d5993d56cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread should (have) terminate(d) <br /></td></tr>
<tr class="separator:a96c4ab49013e266bd842d5993d56cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633d18fa8edb0bfa3c63ce227fa881db"><td class="memItemLeft" align="right" valign="top">XsThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a633d18fa8edb0bfa3c63ce227fa881db">getThreadId</a> (void) const </td></tr>
<tr class="separator:a633d18fa8edb0bfa3c63ce227fa881db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7a882593b45e1c96f08aa965fd0850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e7a882593b45e1c96f08aa965fd0850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a2e7a882593b45e1c96f08aa965fd0850">terminateThread</a> ()</td></tr>
<tr class="memdesc:a2e7a882593b45e1c96f08aa965fd0850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kill the thread now. <br /></td></tr>
<tr class="separator:a2e7a882593b45e1c96f08aa965fd0850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab001997b8a8308583c1c6a62dbd7dcf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab001997b8a8308583c1c6a62dbd7dcf6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#ab001997b8a8308583c1c6a62dbd7dcf6">initFunction</a> (void)</td></tr>
<tr class="memdesc:ab001997b8a8308583c1c6a62dbd7dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual initialization function. <br /></td></tr>
<tr class="separator:ab001997b8a8308583c1c6a62dbd7dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2c6dbfd5fd617859216bd68cb7d55b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae2c6dbfd5fd617859216bd68cb7d55b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#aae2c6dbfd5fd617859216bd68cb7d55b">exitFunction</a> (void)</td></tr>
<tr class="memdesc:aae2c6dbfd5fd617859216bd68cb7d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual exit function. <br /></td></tr>
<tr class="separator:aae2c6dbfd5fd617859216bd68cb7d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12625f2c90b5ce3d64fe9b79f91c1a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab12625f2c90b5ce3d64fe9b79f91c1a2"></a>
virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#ab12625f2c90b5ce3d64fe9b79f91c1a2">innerFunction</a> (void)</td></tr>
<tr class="memdesc:ab12625f2c90b5ce3d64fe9b79f91c1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual inner function. <br /></td></tr>
<tr class="separator:ab12625f2c90b5ce3d64fe9b79f91c1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111c998b0afcf9d2325db1b7b6693977"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a111c998b0afcf9d2325db1b7b6693977"></a>
XsThread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a111c998b0afcf9d2325db1b7b6693977">threadHandle</a> () const </td></tr>
<tr class="memdesc:a111c998b0afcf9d2325db1b7b6693977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread handle. <br /></td></tr>
<tr class="separator:a111c998b0afcf9d2325db1b7b6693977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a41c8ce6716dc0dece08ee8a3641ad201"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c8ce6716dc0dece08ee8a3641ad201"></a>
volatile std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a41c8ce6716dc0dece08ee8a3641ad201">m_stop</a></td></tr>
<tr class="memdesc:a41c8ce6716dc0dece08ee8a3641ad201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread should stop. Derived classes should check <a class="el" href="classxsens_1_1_standard_thread.html#a96c4ab49013e266bd842d5993d56cd6e" title="Returns whether the thread should (have) terminate(d) ">isTerminating()</a> instead of directly polling this value when checking if the thread should stop. However, there are some cases (tests, SignallingThread) where direct access from within the class is desired, which is why the vlaue is protected instead of private. <br /></td></tr>
<tr class="separator:a41c8ce6716dc0dece08ee8a3641ad201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d2d8a2ac12a5b80b8b2187c9f5221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579d2d8a2ac12a5b80b8b2187c9f5221"></a>
volatile std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a579d2d8a2ac12a5b80b8b2187c9f5221">m_yieldOnZeroSleep</a></td></tr>
<tr class="memdesc:a579d2d8a2ac12a5b80b8b2187c9f5221"><td class="mdescLeft">&#160;</td><td class="mdescRight">When true, a sleep value of 0 returned by innerFunction will trigger a thread yield operation. When false, the next cycle is started immediately. <br /></td></tr>
<tr class="separator:a579d2d8a2ac12a5b80b8b2187c9f5221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc7edbcb03bd387b08fc9b3927bfd54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fc7edbcb03bd387b08fc9b3927bfd54"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a3fc7edbcb03bd387b08fc9b3927bfd54">m_stopHandle</a></td></tr>
<tr class="memdesc:a3fc7edbcb03bd387b08fc9b3927bfd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates m_stop functionality for external dependent classes such as <a class="el" href="classxsens_1_1_semaphore.html" title="A semaphore class. ">Semaphore</a>. <br /></td></tr>
<tr class="separator:a3fc7edbcb03bd387b08fc9b3927bfd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392e5e56e3c5e29c436090173c9a2cd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a392e5e56e3c5e29c436090173c9a2cd6"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxsens_1_1_standard_thread.html#a392e5e56e3c5e29c436090173c9a2cd6">m_running</a></td></tr>
<tr class="memdesc:a392e5e56e3c5e29c436090173c9a2cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the thread is running. <br /></td></tr>
<tr class="separator:a392e5e56e3c5e29c436090173c9a2cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for a standard thread that has to perform the same action repeatedly. </p>
<p>The class has three virtual functions, of which the innerFunction is the most important. innerFunction gets called repeatedly and is expected to return so that <a class="el" href="classxsens_1_1_standard_thread.html" title="A class for a standard thread that has to perform the same action repeatedly. ">StandardThread</a> can check for thread termination. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a250180c102a9924ec3568b1e81a41203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xsens::StandardThread::StandardThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor, creates the necessary signals. Does NOT start the thread. </p>

</div>
</div>
<a class="anchor" id="aff911e8e8833aa3d899572140bbfc8a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xsens::StandardThread::~StandardThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, stops the thread if it was running and cleans up afterwards. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a633d18fa8edb0bfa3c63ce227fa881db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsThreadId xsens::StandardThread::getThreadId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The thread ID </dd></dl>

</div>
</div>
<a class="anchor" id="a37da828e3ff2ce01ac62d4ad23fe67c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xsens::StandardThread::isAlive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const volatile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the thread is alive </dd></dl>

</div>
</div>
<a class="anchor" id="a4061440edb7d6dd0706a0535fefd0c01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xsens::StandardThread::setPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gaa3140b510b8517280a7759511195ae7e">XsThreadPriority</a>&#160;</td>
          <td class="paramname"><em>pri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the priority of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pri</td><td>The thread priority to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a291c89de3128f30408494c3dc3b90619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xsens::StandardThread::startThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the thread as shown in the debugger, may be NULL in which case the system determines the name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
