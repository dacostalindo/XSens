<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Callback functions.</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Callback functions.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24d179eecbcde2ca2f3206cb6f7c05f0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0">XsCallback::onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode) <br /></td></tr>
<tr class="separator:ga24d179eecbcde2ca2f3206cb6f7c05f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf94a5a76c3a443255fc53f7a2bf9e076"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076">XsCallback::onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. <br /></td></tr>
<tr class="separator:gaf94a5a76c3a443255fc53f7a2bf9e076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32f20ce601f007ba4e571e40a4f8f71e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e">XsCallback::onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed. <br /></td></tr>
<tr class="separator:ga32f20ce601f007ba4e571e40a4f8f71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac8d7f94d6cb77f5fe56effaa36752e4a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a">XsCallback::onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in. <br /></td></tr>
<tr class="separator:gac8d7f94d6cb77f5fe56effaa36752e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70ff4796b9bb5e3d79eac2c7cd870e59"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59">XsCallback::onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed. <br /></td></tr>
<tr class="separator:ga70ff4796b9bb5e3d79eac2c7cd870e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d34298b034dda9f344f3eb9fc132290"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290">XsCallback::onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:ga5d34298b034dda9f344f3eb9fc132290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="#ga5d34298b034dda9f344f3eb9fc132290">More...</a><br /></td></tr>
<tr class="separator:ga5d34298b034dda9f344f3eb9fc132290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397146fde21cd36a801206e9b73d8399"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399">XsCallback::onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga397146fde21cd36a801206e9b73d8399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="#ga397146fde21cd36a801206e9b73d8399">More...</a><br /></td></tr>
<tr class="separator:ga397146fde21cd36a801206e9b73d8399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40">XsCallback::onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:gacad6280b5dc0c8e458b22e26a50bad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="#gacad6280b5dc0c8e458b22e26a50bad40">More...</a><br /></td></tr>
<tr class="separator:gacad6280b5dc0c8e458b22e26a50bad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5">XsCallback::onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="#ga224586f8f7e0e9f0b57091b7d9a24bc5">More...</a><br /></td></tr>
<tr class="separator:ga224586f8f7e0e9f0b57091b7d9a24bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4a31e495dde9ee053c070fbf06cbe89f">XsCallback::onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="#ga4a31e495dde9ee053c070fbf06cbe89f">More...</a><br /></td></tr>
<tr class="separator:ga4a31e495dde9ee053c070fbf06cbe89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656b04fa94f7b374dcbda27dba20b835"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga656b04fa94f7b374dcbda27dba20b835">XsCallback::onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga656b04fa94f7b374dcbda27dba20b835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="#ga656b04fa94f7b374dcbda27dba20b835">More...</a><br /></td></tr>
<tr class="separator:ga656b04fa94f7b374dcbda27dba20b835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed964edc07fece9546cdd67f64e29f24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaed964edc07fece9546cdd67f64e29f24">XsCallback::onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:gaed964edc07fece9546cdd67f64e29f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="#gaed964edc07fece9546cdd67f64e29f24">More...</a><br /></td></tr>
<tr class="separator:gaed964edc07fece9546cdd67f64e29f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf7cc6f779fca5b3ced0480a731991b18">XsCallback::onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gaf7cc6f779fca5b3ced0480a731991b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="#gaf7cc6f779fca5b3ced0480a731991b18">More...</a><br /></td></tr>
<tr class="separator:gaf7cc6f779fca5b3ced0480a731991b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae0b5c78ecbf3e01a754d4591cb88294f">XsCallback::onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="#gae0b5c78ecbf3e01a754d4591cb88294f">More...</a><br /></td></tr>
<tr class="separator:gae0b5c78ecbf3e01a754d4591cb88294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95">XsCallback::onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga4e7bf7c16f2f8bf70da7150f8a68ac95">More...</a><br /></td></tr>
<tr class="separator:ga4e7bf7c16f2f8bf70da7150f8a68ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03">XsCallback::onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga270ee8957dac53bdf04aee0ba40b3c03">More...</a><br /></td></tr>
<tr class="separator:ga270ee8957dac53bdf04aee0ba40b3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d308afd509c0325b4cdb622fd9e645"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89d308afd509c0325b4cdb622fd9e645"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645">XsCallback::onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga89d308afd509c0325b4cdb622fd9e645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable. <br /></td></tr>
<tr class="separator:ga89d308afd509c0325b4cdb622fd9e645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a65730e9aa35fe9c52c92807741f088"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088">XsCallback::onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga9a65730e9aa35fe9c52c92807741f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga9a65730e9aa35fe9c52c92807741f088">More...</a><br /></td></tr>
<tr class="separator:ga9a65730e9aa35fe9c52c92807741f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4e17817075f23aa461ecf92bb997ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba">XsCallback::onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaeb4e17817075f23aa461ecf92bb997ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#gaeb4e17817075f23aa461ecf92bb997ba">More...</a><br /></td></tr>
<tr class="separator:gaeb4e17817075f23aa461ecf92bb997ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga882b4ffadbc4ac28c78a9763de623c14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14">XsCallback::onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga882b4ffadbc4ac28c78a9763de623c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga882b4ffadbc4ac28c78a9763de623c14">More...</a><br /></td></tr>
<tr class="separator:ga882b4ffadbc4ac28c78a9763de623c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6">XsCallback::onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga6c054ebc03662aa3bc88d36916d8d3f6">More...</a><br /></td></tr>
<tr class="separator:ga6c054ebc03662aa3bc88d36916d8d3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa584015b7c370591fc66f354968a9ca8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa584015b7c370591fc66f354968a9ca8">XsCallback::onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa584015b7c370591fc66f354968a9ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="#gaa584015b7c370591fc66f354968a9ca8">More...</a><br /></td></tr>
<tr class="separator:gaa584015b7c370591fc66f354968a9ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadad70ca84a25f9e01507dde5972262b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gadad70ca84a25f9e01507dde5972262b8">XsCallback::onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:gadad70ca84a25f9e01507dde5972262b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occured.  <a href="#gadad70ca84a25f9e01507dde5972262b8">More...</a><br /></td></tr>
<tr class="separator:gadad70ca84a25f9e01507dde5972262b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">XsCallbackPlainC::m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">XsCallbackPlainC::m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">XsCallbackPlainC::m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">XsCallbackPlainC::m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">XsCallbackPlainC::m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">XsCallbackPlainC::m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">XsCallbackPlainC::m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">XsCallbackPlainC::m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">XsCallbackPlainC::m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">XsCallbackPlainC::m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829650872a3b6d36a5e31a2eec5d2e2c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga829650872a3b6d36a5e31a2eec5d2e2c">XsCallbackPlainC::m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga829650872a3b6d36a5e31a2eec5d2e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="#ga829650872a3b6d36a5e31a2eec5d2e2c">More...</a><br /></td></tr>
<tr class="separator:ga829650872a3b6d36a5e31a2eec5d2e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0613e7c8f4082ab408fd75f97828eb7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf0613e7c8f4082ab408fd75f97828eb7">XsCallbackPlainC::m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:gaf0613e7c8f4082ab408fd75f97828eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="#gaf0613e7c8f4082ab408fd75f97828eb7">More...</a><br /></td></tr>
<tr class="separator:gaf0613e7c8f4082ab408fd75f97828eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394de49100504b50d64fd2b46ed344ab"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga394de49100504b50d64fd2b46ed344ab">XsCallbackPlainC::m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga394de49100504b50d64fd2b46ed344ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="#ga394de49100504b50d64fd2b46ed344ab">More...</a><br /></td></tr>
<tr class="separator:ga394de49100504b50d64fd2b46ed344ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c5f0ea480527fb420607449fc21ae2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga68c5f0ea480527fb420607449fc21ae2">XsCallbackPlainC::m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga68c5f0ea480527fb420607449fc21ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="#ga68c5f0ea480527fb420607449fc21ae2">More...</a><br /></td></tr>
<tr class="separator:ga68c5f0ea480527fb420607449fc21ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">XsCallbackPlainC::m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">XsCallbackPlainC::m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">XsCallbackPlainC::m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">XsCallbackPlainC::m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">XsCallbackPlainC::m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">XsCallbackPlainC::m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">XsCallbackPlainC::m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">XsCallbackPlainC::m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">XsCallbackPlainC::m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occured.  <a href="#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga270ee8957dac53bdf04aee0ba40b3c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllBufferedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. This stream will only interpolate data that is knon to be permanently unavailable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb4e17817075f23aa461ecf92bb997ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e7bf7c16f2f8bf70da7150f8a68ac95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllLiveDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. This stream will interpolate missing data to provide the fastest data output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c054ebc03662aa3bc88d36916d8d3f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onAllRecordedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *&#160;</td>
          <td class="paramname"><em>devs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *&#160;</td>
          <td class="paramname"><em>packets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga397146fde21cd36a801206e9b73d8399"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onBufferedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file. ">onWriteMessageToLogFile</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gacad6280b5dc0c8e458b22e26a50bad40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onConnectivityChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td>
          <td class="paramname"><em>newState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a65730e9aa35fe9c52c92807741f088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a31e495dde9ee053c070fbf06cbe89f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga224586f8f7e0e9f0b57091b7d9a24bc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onInfoResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a>&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response. </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#a12837e1d6d6e4016206023905a920457" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gaed964edc07fece9546cdd67f64e29f24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageDetected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *&#160;</td>
          <td class="paramname"><em>rawMessage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a message is detected in raw data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">type</td><td>The protocol type that detected a message </td></tr>
    <tr><td class="paramname">rawMessage</td><td>The raw message that has been detected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This message can be invalid, since it wasn't checked for sanity </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7cc6f779fca5b3ced0480a731991b18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageReceivedFromDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gae0b5c78ecbf3e01a754d4591cb88294f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onMessageSentToDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga656b04fa94f7b374dcbda27dba20b835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onNonDataMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga882b4ffadbc4ac28c78a9763de623c14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onRecordedDataAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllDataAvailable</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gadad70ca84a25f9e01507dde5972262b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onRestoreCommunication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> *&#160;</td>
          <td class="paramname"><em>portName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when restore communication is completed, stopped or an error occured. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>A name of port to which device is attached. </td></tr>
    <tr><td class="paramname">result</td><td>The result code. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="gaa584015b7c370591fc66f354968a9ca8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void XsCallback::onTransmissionRequest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA needs to send raw data to a device connected using a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user provided identifier associated with the custom channel. </td></tr>
    <tr><td class="paramname">data</td><td>The array of bytes that must be forwarded to the device </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">CallbackManagerXda</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d34298b034dda9f344f3eb9fc132290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int XsCallback::onWriteMessageToLogFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This includes data packets. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>m_onWriteDataToLogFile </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>

<p>Reimplemented in <a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">CallbackManagerXda</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga530314b978cfc8e67a428ef5977e387c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllBufferedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. This stream will only interpolate data that is knon to be permanently unavailable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2ecd8acc66bddf7d1ee079836e0ce36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c2a40680bf18c67190bf81439c4e19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllLiveDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. This stream will interpolate missing data to provide the fastest data output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onAllDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a class="anchor" id="gaccdcbea991503b517e4f84f39ee116a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onAllRecordedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devs</td><td>A managed array of devices for which data is available. The array will be cleaned up by XDA after the callback returns. </td></tr>
    <tr><td class="paramname">packets</td><td>A plain array of pointers to data packets matching the order of <em>devs</em>. The array will be cleaned up by XDA after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae186ea85d702212393fc4da478088a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onBufferedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a data packet that could be written to a log file. </p>
<p>This callback is for the Buffered stream, which will attempt to retransmit missed data when in Recording mode. So there should be no gaps (when recording), but the data arrival may be delayed a bit. When not recording, the behaviour is identical to the Live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>onWriteMessageToLogFile </dd>
<dd>
<a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a2d3d70d8db257a5e97887576eed19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onConnectivityChanged) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has detected a change in the connectivity state of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">newState</td><td>The new connectivity state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf35dbb77b7b08bc8b8e23e6b64c5e87e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is dynamically attached to either the Live or the Buffered stream and behaves accordingly. When reading from a device, it will be attached to the Live stream, while it will be attached to the Buffered stream when reading from a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllDataAvailable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga422f718cc9c4af42b868b998d106eb7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDataUnavailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA detects that data is forever unavailable. </p>
<p>This differs from onMissedPackets, since missed packets may be retransmitted, while unavailable data can no longer be retransmitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packetId</td><td>The sample counter / packet identifier of the unavailable sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8246e1d43087d9a1d559b4015cc5a828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onDeviceStateChanged) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a device's state has changed (ie config mode, measurement mode, recording mode) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. This may be 0 in some cases. </td></tr>
    <tr><td class="paramname">newState</td><td>The new device state </td></tr>
    <tr><td class="paramname">oldState</td><td>The old device state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e6a9805f05f1d3128064be4bc08413b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onError) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an error has occurred while handling incoming data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">error</td><td>The error code that specifies exactly what problem occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91d8b003d9966a2e3ad3a46d0732a97c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onInfoResponse) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when an information request has resulted in a response. </p>
<p>When the information request has completed, the data can be retrieved through the usual functions. Ie. when a requestBatteryLevel() resulted in an onInfoResponse(.., XIR_BatteryLevel), the <a class="el" href="struct_xs_device.html#a12837e1d6d6e4016206023905a920457" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">XsDevice::batteryLevel</a> function will return the received battery level. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">request</td><td>The type of request that was completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4e69823b97ba679d3937ddc140bbc15c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onLiveDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is for the Live stream, so there may be gaps in the data, but it will always contain the latest data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For most applications, attaching to the m_onDataAvailable callback is sufficient, the specific stream callbacks are only provided for exceptional cases </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onDataAvailable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0613e7c8f4082ab408fd75f97828eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageDetected) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a message is detected in raw data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">type</td><td>The protocol type that detected a message </td></tr>
    <tr><td class="paramname">rawMessage</td><td>The raw message that has been detected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This message can be invalid, since it wasn't checked for sanity </dd></dl>

</div>
</div>
<a class="anchor" id="ga394de49100504b50d64fd2b46ed344ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageReceivedFromDevice) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a valid message (after parsing) is received from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that sent the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga68c5f0ea480527fb420607449fc21ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMessageSentToDevice) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called just after a message is sent to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that will receive the message </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga406bc7b8493223ddd47c439d0a5b50f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onMissedPackets) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA detects that packets have been missed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">count</td><td>The number of samples that were missed </td></tr>
    <tr><td class="paramname">first</td><td>The sample counter / packet identifier of the first missed sample </td></tr>
    <tr><td class="paramname">last</td><td>The sample counter / packet identifier of the last missed sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga829650872a3b6d36a5e31a2eec5d2e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onNonDataMessage) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a non data, non reply message has been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that generated the error message </td></tr>
    <tr><td class="paramname">message</td><td>The message that has been received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0131fcde042d419e07dd2144b5d2d36e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onProgressUpdated) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">current</td><td>The current progress. </td></tr>
    <tr><td class="paramname">total</td><td>The total work to be done. When <em>current</em> equals <em>total</em>, the task is completed. </td></tr>
    <tr><td class="paramname">identifier</td><td>An identifier for the task. This may for example be a filename for file read operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b8c139d2c3c55805d73511457956005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onRecordedDataAvailable) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. </p>
<p>This callback is attached to the Buffered stream and behaves accordingly, it will only be called with data that should be recorded. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">packet</td><td>The data packet that has been received (and processed). This may be 0 when the callback originates from a non-device, such as the XsDataBundler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">m_onLiveDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05" title="Called when XDA has a data packet that could be written to a log file. ">m_onBufferedDataAvailable</a> </dd>
<dd>
<a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">m_onAllDataAvailable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga140e7bfb9bfadef2a1f22671f936ff14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onRestoreCommunication) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when restore communication is completed, stopped or an error occured. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portName</td><td>A name of port to which device is attached. </td></tr>
    <tr><td class="paramname">result</td><td>The result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa5d90a461c21f3e14756360027e6658b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onTransmissionRequest) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA needs to send raw data to a device connected using a custom communication channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelId</td><td>The user provided identifier associated with the custom channel. </td></tr>
    <tr><td class="paramname">data</td><td>The array of bytes that must be forwarded to the device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f14d44ea1773133b68b01ae53af8ab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* XsCallbackPlainC::m_onWakeupReceived) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc866d3a718e0351a9d23a2d1ec2586a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* XsCallbackPlainC::m_onWriteMessageToLogFile) (struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when XDA has a message that could be written to a log file. </p>
<dl class="section return"><dt>Returns</dt><dd>0 to prevent the message from being written, non-0 to allow the write. This includes data packets. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message that is ready to be written to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>m_onWriteDataToLogFile </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device that initiated the callback. </td></tr>
    <tr><td class="paramname">message</td><td>The message that will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the write to file should be allowed. Note that if ANY callback decides that the write is not allowed, it will be disallowed. </dd></dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
