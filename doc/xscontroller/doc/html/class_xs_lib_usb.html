<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsLibUsb Class Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_xs_lib_usb-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsLibUsb Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for dynamic loading of winusb.  
 <a href="class_xs_lib_usb.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab3b2b3f91794dade79e7e50eac2567f9"><td class="memItemLeft" align="right" valign="top">libUSB_init&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#ab3b2b3f91794dade79e7e50eac2567f9">init</a></td></tr>
<tr class="memdesc:ab3b2b3f91794dade79e7e50eac2567f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize libusb. This function must be called before calling any other libusb function.  <a href="#ab3b2b3f91794dade79e7e50eac2567f9">More...</a><br /></td></tr>
<tr class="separator:ab3b2b3f91794dade79e7e50eac2567f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8461f10b2fa01b0a9527dfa59d3d57"><td class="memItemLeft" align="right" valign="top">libUSB_exit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a1b8461f10b2fa01b0a9527dfa59d3d57">exit</a></td></tr>
<tr class="memdesc:a1b8461f10b2fa01b0a9527dfa59d3d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize libusb. Should be called after closing all open devices and before your application terminates.  <a href="#a1b8461f10b2fa01b0a9527dfa59d3d57">More...</a><br /></td></tr>
<tr class="separator:a1b8461f10b2fa01b0a9527dfa59d3d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601f8c6d443e6edff0eea2b1c5020abe"><td class="memItemLeft" align="right" valign="top">libUSB_open&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a601f8c6d443e6edff0eea2b1c5020abe">open</a></td></tr>
<tr class="memdesc:a601f8c6d443e6edff0eea2b1c5020abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a device and obtain a device handle. A handle allows you to perform I/O on the device in question.  <a href="#a601f8c6d443e6edff0eea2b1c5020abe">More...</a><br /></td></tr>
<tr class="separator:a601f8c6d443e6edff0eea2b1c5020abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186254f1a5dc9a1ec4a111fe0c412447"><td class="memItemLeft" align="right" valign="top">libUSB_close&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a186254f1a5dc9a1ec4a111fe0c412447">close</a></td></tr>
<tr class="memdesc:a186254f1a5dc9a1ec4a111fe0c412447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a device handle. Should be called on all open handles before your application exits. Internally, this function destroys the reference that was added by libusb_open() on the given device.  <a href="#a186254f1a5dc9a1ec4a111fe0c412447">More...</a><br /></td></tr>
<tr class="separator:a186254f1a5dc9a1ec4a111fe0c412447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c29088eee24800cf5b6dc5fc26c6ba4"><td class="memItemLeft" align="right" valign="top">libUSB_kernel_driver_active&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a1c29088eee24800cf5b6dc5fc26c6ba4">kernel_driver_active</a></td></tr>
<tr class="memdesc:a1c29088eee24800cf5b6dc5fc26c6ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a kernel driver is active on an interface. If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O.  <a href="#a1c29088eee24800cf5b6dc5fc26c6ba4">More...</a><br /></td></tr>
<tr class="separator:a1c29088eee24800cf5b6dc5fc26c6ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f7e311184f366dfa14b8872015186e"><td class="memItemLeft" align="right" valign="top">libUSB_attach_kernel_driver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a63f7e311184f366dfa14b8872015186e">attach_kernel_driver</a></td></tr>
<tr class="memdesc:a63f7e311184f366dfa14b8872015186e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-attach an interface's kernel driver, which was previously detached using libusb_detach_kernel_driver(). This call is only effective on Linux and returns LIBUSB_ERROR_NOT_SUPPORTED on all other platforms.  <a href="#a63f7e311184f366dfa14b8872015186e">More...</a><br /></td></tr>
<tr class="separator:a63f7e311184f366dfa14b8872015186e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa171b447a26e0ea30eb9ab7a2da7c52f"><td class="memItemLeft" align="right" valign="top">libUSB_detach_kernel_driver&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#aa171b447a26e0ea30eb9ab7a2da7c52f">detach_kernel_driver</a></td></tr>
<tr class="memdesc:aa171b447a26e0ea30eb9ab7a2da7c52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a kernel driver from an interface. If successful, you will then be able to claim the interface and perform I/O.  <a href="#aa171b447a26e0ea30eb9ab7a2da7c52f">More...</a><br /></td></tr>
<tr class="separator:aa171b447a26e0ea30eb9ab7a2da7c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b52b976fa093434a72f481c1601186"><td class="memItemLeft" align="right" valign="top">libUSB_ref_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#ad3b52b976fa093434a72f481c1601186">ref_device</a></td></tr>
<tr class="memdesc:ad3b52b976fa093434a72f481c1601186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count of a device.  <a href="#ad3b52b976fa093434a72f481c1601186">More...</a><br /></td></tr>
<tr class="separator:ad3b52b976fa093434a72f481c1601186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c15f15d305c839594738dc402c56793"><td class="memItemLeft" align="right" valign="top">libUSB_unref_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a3c15f15d305c839594738dc402c56793">unref_device</a></td></tr>
<tr class="memdesc:a3c15f15d305c839594738dc402c56793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count of a device. If the decrement operation causes the reference count to reach zero, the device shall be destroyed.  <a href="#a3c15f15d305c839594738dc402c56793">More...</a><br /></td></tr>
<tr class="separator:a3c15f15d305c839594738dc402c56793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93686eccc1747804efbd884e6b494c66"><td class="memItemLeft" align="right" valign="top">libUSB_claim_interface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a93686eccc1747804efbd884e6b494c66">claim_interface</a></td></tr>
<tr class="memdesc:a93686eccc1747804efbd884e6b494c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim an interface on a given device handle. You must claim the interface you wish to use before you can perform I/O on any of its endpoints.  <a href="#a93686eccc1747804efbd884e6b494c66">More...</a><br /></td></tr>
<tr class="separator:a93686eccc1747804efbd884e6b494c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9551b095a157d2b2f7acc7a9a2ba29"><td class="memItemLeft" align="right" valign="top">libUSB_release_interface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#abd9551b095a157d2b2f7acc7a9a2ba29">release_interface</a></td></tr>
<tr class="memdesc:abd9551b095a157d2b2f7acc7a9a2ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an interface previously claimed with libusb_claim_interface(). You should release all claimed interfaces before closing a device handle.  <a href="#abd9551b095a157d2b2f7acc7a9a2ba29">More...</a><br /></td></tr>
<tr class="separator:abd9551b095a157d2b2f7acc7a9a2ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265aa3c5a9642d1d44afd41f40ba87aa"><td class="memItemLeft" align="right" valign="top">libUSB_get_active_config_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a265aa3c5a9642d1d44afd41f40ba87aa">get_active_config_descriptor</a></td></tr>
<tr class="memdesc:a265aa3c5a9642d1d44afd41f40ba87aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the USB configuration descriptor for the currently active configuration.  <a href="#a265aa3c5a9642d1d44afd41f40ba87aa">More...</a><br /></td></tr>
<tr class="separator:a265aa3c5a9642d1d44afd41f40ba87aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6de6e705d2a2c88e613217efc456a0"><td class="memItemLeft" align="right" valign="top">libUSB_free_config_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#afa6de6e705d2a2c88e613217efc456a0">free_config_descriptor</a></td></tr>
<tr class="memdesc:afa6de6e705d2a2c88e613217efc456a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a configuration descriptor obtained from libusb_get_active_config_descriptor() or libusb_get_config_descriptor().  <a href="#afa6de6e705d2a2c88e613217efc456a0">More...</a><br /></td></tr>
<tr class="separator:afa6de6e705d2a2c88e613217efc456a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff83b63e39032132306c14ba8688b3f0"><td class="memItemLeft" align="right" valign="top">libUSB_get_bus_number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#aff83b63e39032132306c14ba8688b3f0">get_bus_number</a></td></tr>
<tr class="memdesc:aff83b63e39032132306c14ba8688b3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of the bus that a device is connected to.  <a href="#aff83b63e39032132306c14ba8688b3f0">More...</a><br /></td></tr>
<tr class="separator:aff83b63e39032132306c14ba8688b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf120c17ff09eeefa07a2dfe7085de"><td class="memItemLeft" align="right" valign="top">libUSB_get_device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a1faf120c17ff09eeefa07a2dfe7085de">get_device</a></td></tr>
<tr class="memdesc:a1faf120c17ff09eeefa07a2dfe7085de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying device for a handle.  <a href="#a1faf120c17ff09eeefa07a2dfe7085de">More...</a><br /></td></tr>
<tr class="separator:a1faf120c17ff09eeefa07a2dfe7085de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f71d3c4c8d45f8a4aecf5be4c9c0c48"><td class="memItemLeft" align="right" valign="top">libUSB_get_device_address&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a4f71d3c4c8d45f8a4aecf5be4c9c0c48">get_device_address</a></td></tr>
<tr class="memdesc:a4f71d3c4c8d45f8a4aecf5be4c9c0c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the device on the bus it is connected to.  <a href="#a4f71d3c4c8d45f8a4aecf5be4c9c0c48">More...</a><br /></td></tr>
<tr class="separator:a4f71d3c4c8d45f8a4aecf5be4c9c0c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c03b6c6b2f2c3a5734374a8c6578c5"><td class="memItemLeft" align="right" valign="top">libUSB_get_device_descriptor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#ae6c03b6c6b2f2c3a5734374a8c6578c5">get_device_descriptor</a></td></tr>
<tr class="memdesc:ae6c03b6c6b2f2c3a5734374a8c6578c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the USB device descriptor for a given device.  <a href="#ae6c03b6c6b2f2c3a5734374a8c6578c5">More...</a><br /></td></tr>
<tr class="separator:ae6c03b6c6b2f2c3a5734374a8c6578c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415e57bfd0df44ca373806a807f32dfa"><td class="memItemLeft" align="right" valign="top">libUSB_get_device_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a415e57bfd0df44ca373806a807f32dfa">get_device_list</a></td></tr>
<tr class="memdesc:a415e57bfd0df44ca373806a807f32dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of USB devices currently attached to the system. This is your entry point into finding a USB device to operate.  <a href="#a415e57bfd0df44ca373806a807f32dfa">More...</a><br /></td></tr>
<tr class="separator:a415e57bfd0df44ca373806a807f32dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd06f7b6d744921261cea2cd0734bf0"><td class="memItemLeft" align="right" valign="top">libUSB_free_device_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#afcd06f7b6d744921261cea2cd0734bf0">free_device_list</a></td></tr>
<tr class="memdesc:afcd06f7b6d744921261cea2cd0734bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a list of devices previously discovered using libusb_get_device_list(). If the unref_devices parameter is set, the reference count of each device in the list is decremented by 1.  <a href="#afcd06f7b6d744921261cea2cd0734bf0">More...</a><br /></td></tr>
<tr class="separator:afcd06f7b6d744921261cea2cd0734bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b4715809e38ebc76df38e21c05f0f"><td class="memItemLeft" align="right" valign="top">libUSB_get_string_descriptor_ascii&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#ad28b4715809e38ebc76df38e21c05f0f">get_string_descriptor_ascii</a></td></tr>
<tr class="memdesc:ad28b4715809e38ebc76df38e21c05f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string descriptor in C style ASCII.  <a href="#ad28b4715809e38ebc76df38e21c05f0f">More...</a><br /></td></tr>
<tr class="separator:ad28b4715809e38ebc76df38e21c05f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae167617662623ba66bb9d5d9c5da484a"><td class="memItemLeft" align="right" valign="top">libUSB_bulk_transfer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#ae167617662623ba66bb9d5d9c5da484a">bulk_transfer</a></td></tr>
<tr class="memdesc:ae167617662623ba66bb9d5d9c5da484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a USB bulk transfer. The direction of the transfer is inferred from the direction bits of the endpoint address.  <a href="#ae167617662623ba66bb9d5d9c5da484a">More...</a><br /></td></tr>
<tr class="separator:ae167617662623ba66bb9d5d9c5da484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2927577fa0dfc0b7e4f582fa6943fc"><td class="memItemLeft" align="right" valign="top">libUSB_set_debug&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_lib_usb.html#a0f2927577fa0dfc0b7e4f582fa6943fc">set_debug</a></td></tr>
<tr class="memdesc:a0f2927577fa0dfc0b7e4f582fa6943fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set message verbosity.  <a href="#a0f2927577fa0dfc0b7e4f582fa6943fc">More...</a><br /></td></tr>
<tr class="separator:a0f2927577fa0dfc0b7e4f582fa6943fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for dynamic loading of winusb. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a63f7e311184f366dfa14b8872015186e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::attach_kernel_driver</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-attach an interface's kernel driver, which was previously detached using libusb_detach_kernel_driver(). This call is only effective on Linux and returns LIBUSB_ERROR_NOT_SUPPORTED on all other platforms. </p>
<p>This functionality is not available on Darwin or Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to attach the driver from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
LIBUSB_ERROR_BUSY if the driver cannot be attached because the interface is claimed by a program or driver </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd>libusb_kernel_driver_active() </dd></dl>

</div>
</div>
<a class="anchor" id="ae167617662623ba66bb9d5d9c5da484a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::bulk_transfer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a USB bulk transfer. The direction of the transfer is inferred from the direction bits of the endpoint address. </p>
<p>For bulk reads, the <em>length</em> field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the <em>transferred</em> output parameter.</p>
<p>You should also check the <em>transferred</em> parameter for bulk writes. Not all of the data may have been written.</p>
<p>Also check <em>transferred</em> when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a handle for the device to communicate with </td></tr>
    <tr><td class="paramname">endpoint</td><td>the address of a valid endpoint to communicate with </td></tr>
    <tr><td class="paramname">data</td><td>a suitably-sized data buffer for either input or output (depending on endpoint) </td></tr>
    <tr><td class="paramname">length</td><td>for bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer. </td></tr>
    <tr><td class="paramname">transferred</td><td>output location for the number of bytes actually transferred. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (and populates <em>transferred</em>) </dd>
<dd>
LIBUSB_ERROR_TIMEOUT if the transfer timed out (and populates <em>transferred</em>) </dd>
<dd>
LIBUSB_ERROR_PIPE if the endpoint halted </dd>
<dd>
LIBUSB_ERROR_OVERFLOW if the device offered more data </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failures </dd></dl>

</div>
</div>
<a class="anchor" id="a93686eccc1747804efbd884e6b494c66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::claim_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim an interface on a given device handle. You must claim the interface you wish to use before you can perform I/O on any of its endpoints. </p>
<p>It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</p>
<p>Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</p>
<p>This is a non-blocking function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <em>bInterfaceNumber</em> of the interface you wish to claim </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the requested interface does not exist </dd>
<dd>
LIBUSB_ERROR_BUSY if another program or driver has claimed the interface </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
a LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="a186254f1a5dc9a1ec4a111fe0c412447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::close</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a device handle. Should be called on all open handles before your application exits. Internally, this function destroys the reference that was added by libusb_open() on the given device. </p>
<p>This is a non-blocking function; no requests are sent over the bus. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>the handle to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa171b447a26e0ea30eb9ab7a2da7c52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::detach_kernel_driver</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a kernel driver from an interface. If successful, you will then be able to claim the interface and perform I/O. </p>
<p>This functionality is not available on Darwin or Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to detach the driver from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </dd>
<dd>
LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd>libusb_kernel_driver_active() </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8461f10b2fa01b0a9527dfa59d3d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::exit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize libusb. Should be called after closing all open devices and before your application terminates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to deinitialize, or NULL for the default context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa6de6e705d2a2c88e613217efc456a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::free_config_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a configuration descriptor obtained from libusb_get_active_config_descriptor() or libusb_get_config_descriptor(). </p>
<p>It is safe to call this function with a NULL config parameter, in which case the function simply returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>the configuration descriptor to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcd06f7b6d744921261cea2cd0734bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::free_device_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a list of devices previously discovered using libusb_get_device_list(). If the unref_devices parameter is set, the reference count of each device in the list is decremented by 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to free </td></tr>
    <tr><td class="paramname">unref_devices</td><td>whether to unref the devices in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a265aa3c5a9642d1d44afd41f40ba87aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::get_active_config_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the USB configuration descriptor for the currently active configuration. </p>
<p>This is a non-blocking function which does not involve any requests being sent to the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
    <tr><td class="paramname">config</td><td>output location for the USB configuration descriptor. Only valid if 0 was returned. Must be freed with libusb_free_config_descriptor() after use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the device is in unconfigured state </dd>
<dd>
another LIBUSB_ERROR code on error </dd></dl>
<dl class="section see"><dt>See also</dt><dd>libusb_get_config_descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="aff83b63e39032132306c14ba8688b3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsLibUsb::get_bus_number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of the bus that a device is connected to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus number </dd></dl>

</div>
</div>
<a class="anchor" id="a1faf120c17ff09eeefa07a2dfe7085de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libusb_device * XsLibUsb::get_device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the underlying device for a handle. </p>
<p>This function does not modify the reference count of the returned device, so do not feel compelled to unreference it when you are done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_handle</td><td>a device handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying device </dd></dl>

</div>
</div>
<a class="anchor" id="a4f71d3c4c8d45f8a4aecf5be4c9c0c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t XsLibUsb::get_device_address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of the device on the bus it is connected to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device address </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c03b6c6b2f2c3a5734374a8c6578c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::get_device_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the USB device descriptor for a given device. </p>
<p>This is a non-blocking function; the device descriptor is cached in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device </td></tr>
    <tr><td class="paramname">desc</td><td>output location for the descriptor data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a415e57bfd0df44ca373806a807f32dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t XsLibUsb::get_device_list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of USB devices currently attached to the system. This is your entry point into finding a USB device to operate. </p>
<p>You are expected to unreference all the devices when you are done with them, and then free the list with libusb_free_device_list(). Note that libusb_free_device_list() can unref all the devices for you. Be careful not to unreference a device you are about to open until after you have opened it.</p>
<p>This return value of this function indicates the number of devices in the resultant list. The list is actually one element larger, as it is NULL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">list</td><td>output location for a list of devices. Must be later freed with libusb_free_device_list(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of devices in the outputted list, or any LIBUSB_ERROR code to errors encountered by the backend. </dd></dl>

</div>
</div>
<a class="anchor" id="ad28b4715809e38ebc76df38e21c05f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::get_string_descriptor_ascii</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a string descriptor in C style ASCII. </p>
<p>Wrapper around libusb_get_string_descriptor(). Uses the first language supported by the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">desc_index</td><td>the index of the descriptor to retrieve </td></tr>
    <tr><td class="paramname">data</td><td>output buffer for ASCII string descriptor </td></tr>
    <tr><td class="paramname">length</td><td>size of data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes returned in data, or LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab3b2b3f91794dade79e7e50eac2567f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::init</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize libusb. This function must be called before calling any other libusb function. </p>
<p>If you do not provide an output location for a context pointer, a default context will be created. If there was already a default context, it will be reused (and nothing will be initialized/reinitialized).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Optional output location for context pointer. Only valid on return code 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a LIBUSB_ERROR code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1c29088eee24800cf5b6dc5fc26c6ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::kernel_driver_active</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a kernel driver is active on an interface. If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O. </p>
<p>This functionality is not available on Windows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the interface to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no kernel driver is active </dd>
<dd>
1 if a kernel driver is active </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd>libusb_detach_kernel_driver() </dd></dl>

</div>
</div>
<a class="anchor" id="a601f8c6d443e6edff0eea2b1c5020abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::open</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a device and obtain a device handle. A handle allows you to perform I/O on the device in question. </p>
<p>Internally, this function adds a reference to the device and makes it available to you through libusb_get_device(). This reference is removed during libusb_close().</p>
<p>This is a non-blocking function; no requests are sent over the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to open </td></tr>
    <tr><td class="paramname">handle</td><td>output location for the returned device handle pointer. Only populated when the return code is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NO_MEM on memory allocation failure </dd>
<dd>
LIBUSB_ERROR_ACCESS if the user has insufficient permissions </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad3b52b976fa093434a72f481c1601186"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libusb_device * XsLibUsb::ref_device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the reference count of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the same device </dd></dl>

</div>
</div>
<a class="anchor" id="abd9551b095a157d2b2f7acc7a9a2ba29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsLibUsb::release_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an interface previously claimed with libusb_claim_interface(). You should release all claimed interfaces before closing a device handle. </p>
<p>This is a blocking function. A SET_INTERFACE control request will be sent to the device, resetting interface state to the first alternate setting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>a device handle </td></tr>
    <tr><td class="paramname">interface_number</td><td>the <em>bInterfaceNumber</em> of the previously-claimed interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
LIBUSB_ERROR_NOT_FOUND if the interface was not claimed </dd>
<dd>
LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </dd>
<dd>
another LIBUSB_ERROR code on other failure </dd></dl>

</div>
</div>
<a class="anchor" id="a0f2927577fa0dfc0b7e4f582fa6943fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::set_debug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set message verbosity. </p>
<ul>
<li>Level 0: no messages ever printed by the library (default)</li>
<li>Level 1: error messages are printed to stderr</li>
<li>Level 2: warning and error messages are printed to stderr</li>
<li>Level 3: informational messages are printed to stdout, warning and error messages are printed to stderr</li>
</ul>
<p>The default level is 0, which means no messages are ever printed. If you choose to increase the message verbosity level, ensure that your application does not close the stdout/stderr file descriptors.</p>
<p>You are advised to set level 3. libusb is conservative with its message logging and most of the time, will only log messages that explain error conditions and other oddities. This will help you debug your software.</p>
<p>If the LIBUSB_DEBUG environment variable was set when libusb was initialized, this function does nothing: the message verbosity is fixed to the value in the environment variable.</p>
<p>If libusb was compiled without any message logging, this function does nothing: you'll never get any messages.</p>
<p>If libusb was compiled with verbose debug message logging, this function does nothing: you'll always get messages from all levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context to operate on, or NULL for the default context </td></tr>
    <tr><td class="paramname">level</td><td>debug level to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c15f15d305c839594738dc402c56793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsLibUsb::unref_device</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the reference count of a device. If the decrement operation causes the reference count to reach zero, the device shall be destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>the device to unreference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
