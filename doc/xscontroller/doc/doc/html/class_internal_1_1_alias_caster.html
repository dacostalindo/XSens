<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Internal::AliasCaster&lt; U, V &gt; Class Template Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Internal</b></li><li class="navelem"><a class="el" href="class_internal_1_1_alias_caster.html">AliasCaster</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_internal_1_1_alias_caster-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Internal::AliasCaster&lt; U, V &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa0bc720f799285c1ced2649dd3eaad04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0bc720f799285c1ced2649dd3eaad04"></a>
typedef U&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_internal_1_1_alias_caster.html#aa0bc720f799285c1ced2649dd3eaad04">to_type</a></td></tr>
<tr class="memdesc:aa0bc720f799285c1ced2649dd3eaad04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pointer to type. <br /></td></tr>
<tr class="separator:aa0bc720f799285c1ced2649dd3eaad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9549268747a91fed696e064b5189a2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9549268747a91fed696e064b5189a2c"></a>
typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_internal_1_1_alias_caster.html#ab9549268747a91fed696e064b5189a2c">from_type</a></td></tr>
<tr class="memdesc:ab9549268747a91fed696e064b5189a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pointer from type. <br /></td></tr>
<tr class="separator:ab9549268747a91fed696e064b5189a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0dd3921fbc4303a71c3325f44f4ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0b0dd3921fbc4303a71c3325f44f4ab"></a>
typedef std::remove_pointer&lt; <a class="el" href="class_internal_1_1_alias_caster.html#aa0bc720f799285c1ced2649dd3eaad04">to_type</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_internal_1_1_alias_caster.html#aa0b0dd3921fbc4303a71c3325f44f4ab">base_to_type</a></td></tr>
<tr class="memdesc:aa0b0dd3921fbc4303a71c3325f44f4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base pointer to type. <br /></td></tr>
<tr class="separator:aa0b0dd3921fbc4303a71c3325f44f4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e010bbcc0170ee828ebd506c3107d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36e010bbcc0170ee828ebd506c3107d0"></a>
typedef std::remove_pointer&lt; <a class="el" href="class_internal_1_1_alias_caster.html#ab9549268747a91fed696e064b5189a2c">from_type</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_internal_1_1_alias_caster.html#a36e010bbcc0170ee828ebd506c3107d0">base_from_type</a></td></tr>
<tr class="memdesc:a36e010bbcc0170ee828ebd506c3107d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base pointer from type. <br /></td></tr>
<tr class="separator:a36e010bbcc0170ee828ebd506c3107d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a70c0f1406e572a6827ef8e8d6bf05598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c0f1406e572a6827ef8e8d6bf05598"></a>
static <a class="el" href="class_internal_1_1_alias_caster.html#aa0bc720f799285c1ced2649dd3eaad04">to_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_internal_1_1_alias_caster.html#a70c0f1406e572a6827ef8e8d6bf05598">cast</a> (<a class="el" href="class_internal_1_1_alias_caster.html#ab9549268747a91fed696e064b5189a2c">from_type</a> from)</td></tr>
<tr class="memdesc:a70c0f1406e572a6827ef8e8d6bf05598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pointer type cast. <br /></td></tr>
<tr class="separator:a70c0f1406e572a6827ef8e8d6bf05598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename U, typename V&gt;<br />
class Internal::AliasCaster&lt; U, V &gt;</h3>

<p>Alias caster can be used to reinterpret a memory locatation as a different type without breaking strict aliasing rules. For example casting a pointer to a struct to a pointer to a uint16_t. <a class="el" href="class_internal_1_1_alias_caster.html">AliasCaster</a> only supports casting pointers. Example: MyStruct myStruct; uint16_t* myUint16ptr = AliasCaster&lt;uint16_t*, MyStruct&gt;(&amp;myStruct); uint16_t firstUint = *myUint16ptr; The helper function alias_cast (see below) is provided for easier usage </p><dl class="section note"><dt>Note</dt><dd>Strictly speaking, according to the standard, assigning to alias.from and the reading alias.to is undefined behaviour </dd>
<dd>
Putting only pointers in the union an invalid solution according to the link below <a href="http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html">http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html</a> <a href="http://blog.regehr.org/archives/959">http://blog.regehr.org/archives/959</a></dd></dl>
<p>The chosen solution is to cast the source pointer to a pointer to a union of the 'base' types of the source and destination pointers and then return the adress of the destination field of the union. </p>
</div></div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
