<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XsDevicePtr Struct Reference</title>
<link href="xsens.css" rel="stylesheet" type="text/css"/>
</head><body>
<img class="logo" src="xsenslogo.jpg" alt="Xsens Logo" />
	<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_xs_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XsDevicePtr Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> object.  
 <a href="struct_xs_device.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for XsDevicePtr:</div>
<div class="dyncontent">
<div class="center"><img src="struct_xs_device__inherit__graph.png" border="0" usemap="#_xs_device_ptr_inherit__map" alt="Inheritance graph"/></div>
<map name="_xs_device_ptr_inherit__map" id="_xs_device_ptr_inherit__map">
<area shape="rect" id="node5" href="class_broadcast_device.html" title="Intimately entangled class with XsControl that allows broadcasting to all main devices. " alt="" coords="203,304,325,331"/>
<area shape="rect" id="node6" href="struct_xs_device_ex.html" title="An abstract internal struct of a device. " alt="" coords="350,304,445,331"/>
<area shape="rect" id="node2" href="class_callback_manager_xda.html" title="Class that delegates callbacks to registered XsCallbackHandlerItems. " alt="" coords="257,155,404,181"/>
<area shape="rect" id="node3" href="class_xs_callback.html" title="Structure that contains callback functions for the Xsens Device API. " alt="" coords="286,80,375,107"/>
<area shape="rect" id="node4" href="struct_xs_callback_plain_c.html" title="Structure that contains callback functions for the Xsens Device API. " alt="" coords="267,5,395,32"/>
<area shape="rect" id="node7" href="class_mt_device.html" title="MT device base class. " alt="" coords="358,379,437,405"/>
<area shape="rect" id="node8" href="struct_mt_device_ex.html" title="An abstract struct of MT device. " alt="" coords="350,453,445,480"/>
<area shape="rect" id="node9" href="class_mti_base_device.html" title="The generic class for MTi devices. " alt="" coords="342,528,453,555"/>
<area shape="rect" id="node10" href="struct_mti_base_device_ex.html" title="The internal base class for MTi devices. " alt="" coords="334,603,461,629"/>
<area shape="rect" id="node11" href="class_mti6_x0_device.html" title="The MTi device used for the 6X0&#45;series. " alt="" coords="27,677,131,704"/>
<area shape="rect" id="node13" href="class_mti7_device.html" title="The MTi device used for the 7&#45;series. " alt="" coords="169,677,257,704"/>
<area shape="rect" id="node15" href="class_mtig_device.html" title="The MTi device used for the 7X0&#45;series. " alt="" coords="289,677,377,704"/>
<area shape="rect" id="node17" href="class_mti_x00_device.html" title="The MTi device used for the X00&#45;series. " alt="" coords="409,677,513,704"/>
<area shape="rect" id="node19" href="class_mti_x0_device.html" title="The MTi device used for the X0&#45;series. " alt="" coords="550,677,647,704"/>
<area shape="rect" id="node21" href="class_mti_x_device.html" title="The MTi device used for the X&#45;series. " alt="" coords="685,677,776,704"/>
<area shape="rect" id="node12" href="struct_mti6_x0_device_ex.html" title="The internal base class for MTi&#45;6X0 series devices. " alt="" coords="5,752,125,779"/>
<area shape="rect" id="node14" href="struct_mti7_device_ex.html" title="The internal base class for MTi&#45;7 series devices. " alt="" coords="149,752,253,779"/>
<area shape="rect" id="node16" href="struct_mtig_device_ex.html" title="The internal base class for MTi&#45;7X0 series devices. " alt="" coords="277,752,381,779"/>
<area shape="rect" id="node18" href="struct_mti_x00_device_ex.html" title="The internal base class for MTi&#45;X00 series devices. " alt="" coords="405,752,525,779"/>
<area shape="rect" id="node20" href="struct_mti_x0_device_ex.html" title="The internal base class for MTi&#45;X0 series devices. " alt="" coords="550,752,663,779"/>
<area shape="rect" id="node22" href="struct_mti_x_device_ex.html" title="The internal base class for MTi&#45;X series devices. " alt="" coords="688,752,795,779"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56853f133ab4c8d7d53c19f2b40f5937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56853f133ab4c8d7d53c19f2b40f5937"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a56853f133ab4c8d7d53c19f2b40f5937">addRef</a> ()</td></tr>
<tr class="memdesc:a56853f133ab4c8d7d53c19f2b40f5937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference count of <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> pointer <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> pointers stay alive while reference counter is not zero Also increases the reference count of each child device with 1. <br /></td></tr>
<tr class="separator:a56853f133ab4c8d7d53c19f2b40f5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb0839e2acab62b9cdc6e8c82896743"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5eb0839e2acab62b9cdc6e8c82896743">removeRef</a> ()</td></tr>
<tr class="memdesc:a5eb0839e2acab62b9cdc6e8c82896743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1.  <a href="#a5eb0839e2acab62b9cdc6e8c82896743">More...</a><br /></td></tr>
<tr class="separator:a5eb0839e2acab62b9cdc6e8c82896743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaedf3418630bbee55eb952d87bebe8"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acbaedf3418630bbee55eb952d87bebe8">refCounter</a> () const </td></tr>
<tr class="memdesc:acbaedf3418630bbee55eb952d87bebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current reference counter.  <a href="#acbaedf3418630bbee55eb952d87bebe8">More...</a><br /></td></tr>
<tr class="separator:acbaedf3418630bbee55eb952d87bebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6706c445acd02d690ce8e4058d81bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#add6706c445acd02d690ce8e4058d81bb">master</a> () const </td></tr>
<tr class="memdesc:add6706c445acd02d690ce8e4058d81bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the master device of this device.  <a href="#add6706c445acd02d690ce8e4058d81bb">More...</a><br /></td></tr>
<tr class="separator:add6706c445acd02d690ce8e4058d81bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aad6fe5d2f33fbf8ba32a299cd47e56b8">findDevice</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid)</td></tr>
<tr class="memdesc:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.  <a href="#aad6fe5d2f33fbf8ba32a299cd47e56b8">More...</a><br /></td></tr>
<tr class="separator:aad6fe5d2f33fbf8ba32a299cd47e56b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device.html">XsDevice</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3327b3ab9c38e6d7146268cbb5f5074f">findDeviceConst</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> deviceid) const </td></tr>
<tr class="memdesc:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the child device with <em>deviceid</em>.  <a href="#a3327b3ab9c38e6d7146268cbb5f5074f">More...</a><br /></td></tr>
<tr class="separator:a3327b3ab9c38e6d7146268cbb5f5074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b990350dc62b2c39bf6cb9a829810"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9f1b990350dc62b2c39bf6cb9a829810">busId</a> () const </td></tr>
<tr class="memdesc:a9f1b990350dc62b2c39bf6cb9a829810"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bus ID for this device.  <a href="#a9f1b990350dc62b2c39bf6cb9a829810">More...</a><br /></td></tr>
<tr class="separator:a9f1b990350dc62b2c39bf6cb9a829810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4816ad6761de87cb49a96ce1807864f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a> () const </td></tr>
<tr class="memdesc:a4816ad6761de87cb49a96ce1807864f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device ID of the device.  <a href="#a4816ad6761de87cb49a96ce1807864f7">More...</a><br /></td></tr>
<tr class="separator:a4816ad6761de87cb49a96ce1807864f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4711198a842b98d6b80ab6070241ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acf4711198a842b98d6b80ab6070241ad">firmwareVersion</a> () const </td></tr>
<tr class="memdesc:acf4711198a842b98d6b80ab6070241ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the firmware version.  <a href="#acf4711198a842b98d6b80ab6070241ad">More...</a><br /></td></tr>
<tr class="separator:acf4711198a842b98d6b80ab6070241ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487254bfbbb279e8e63de5e9ac5164fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a487254bfbbb279e8e63de5e9ac5164fa">isMasterDevice</a> () const </td></tr>
<tr class="memdesc:a487254bfbbb279e8e63de5e9ac5164fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is the master device (not a child of another device)  <a href="#a487254bfbbb279e8e63de5e9ac5164fa">More...</a><br /></td></tr>
<tr class="separator:a487254bfbbb279e8e63de5e9ac5164fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaa56e797f84dcf7bdf3bd4a1461410"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adbaa56e797f84dcf7bdf3bd4a1461410">isContainerDevice</a> () const </td></tr>
<tr class="memdesc:adbaa56e797f84dcf7bdf3bd4a1461410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this device can have child devices.  <a href="#adbaa56e797f84dcf7bdf3bd4a1461410">More...</a><br /></td></tr>
<tr class="separator:adbaa56e797f84dcf7bdf3bd4a1461410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195a4440598a15ee45b9ab484559f593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a195a4440598a15ee45b9ab484559f593">isInitialized</a> () const </td></tr>
<tr class="memdesc:a195a4440598a15ee45b9ab484559f593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the device is initialized.  <a href="#a195a4440598a15ee45b9ab484559f593">More...</a><br /></td></tr>
<tr class="separator:a195a4440598a15ee45b9ab484559f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2eff7868f2a6a3a27a0926cbc02ac6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa2eff7868f2a6a3a27a0926cbc02ac6f">isStandaloneDevice</a> () const </td></tr>
<tr class="memdesc:aa2eff7868f2a6a3a27a0926cbc02ac6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a standalone device (not a child of another device and not a container device)  <a href="#aa2eff7868f2a6a3a27a0926cbc02ac6f">More...</a><br /></td></tr>
<tr class="separator:aa2eff7868f2a6a3a27a0926cbc02ac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6d6e422d8ccf6316a33f29be3259ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aac6d6e422d8ccf6316a33f29be3259ed">deviceAtBusIdConst</a> (int busid) const </td></tr>
<tr class="memdesc:aac6d6e422d8ccf6316a33f29be3259ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#aac6d6e422d8ccf6316a33f29be3259ed">More...</a><br /></td></tr>
<tr class="separator:aac6d6e422d8ccf6316a33f29be3259ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5252f1f85a52eeef4ac2c5af789c24e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af5252f1f85a52eeef4ac2c5af789c24e">deviceAtBusId</a> (int busid)</td></tr>
<tr class="memdesc:af5252f1f85a52eeef4ac2c5af789c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device with bus ID <em>busid</em>.  <a href="#af5252f1f85a52eeef4ac2c5af789c24e">More...</a><br /></td></tr>
<tr class="separator:af5252f1f85a52eeef4ac2c5af789c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ee16fe5af46d170902369671fa23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aac0ee16fe5af46d170902369671fa23f">setGotoConfigOnClose</a> (bool gotoConfigOnClose)</td></tr>
<tr class="memdesc:aac0ee16fe5af46d170902369671fa23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">On closePort the device will go to config by default, with this function it is possible to prevent that.  <a href="#aac0ee16fe5af46d170902369671fa23f">More...</a><br /></td></tr>
<tr class="separator:aac0ee16fe5af46d170902369671fa23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4">createLogFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a log file for logging.  <a href="#a8afe4b27a5df14e02c8a1c6a7dfcb3c4">More...</a><br /></td></tr>
<tr class="separator:a8afe4b27a5df14e02c8a1c6a7dfcb3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfa1a413439dfce3ebb21a29af9aab9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1bfa1a413439dfce3ebb21a29af9aab9">closeLogFile</a> ()</td></tr>
<tr class="memdesc:a1bfa1a413439dfce3ebb21a29af9aab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the log file.  <a href="#a1bfa1a413439dfce3ebb21a29af9aab9">More...</a><br /></td></tr>
<tr class="separator:a1bfa1a413439dfce3ebb21a29af9aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b63e3e26701545a3081140726492e8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab2b63e3e26701545a3081140726492e8">isMeasuring</a> () const </td></tr>
<tr class="memdesc:ab2b63e3e26701545a3081140726492e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a measuring state.  <a href="#ab2b63e3e26701545a3081140726492e8">More...</a><br /></td></tr>
<tr class="separator:ab2b63e3e26701545a3081140726492e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea0a1dfe75b07d0f45949058e8214b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2ea0a1dfe75b07d0f45949058e8214b6">isRecording</a> () const </td></tr>
<tr class="memdesc:a2ea0a1dfe75b07d0f45949058e8214b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is currently in a recording state.  <a href="#a2ea0a1dfe75b07d0f45949058e8214b6">More...</a><br /></td></tr>
<tr class="separator:a2ea0a1dfe75b07d0f45949058e8214b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e4585d1ac37b9575c68ee0d6c1b36c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad8e4585d1ac37b9575c68ee0d6c1b36c">isReadingFromFile</a> () const </td></tr>
<tr class="memdesc:ad8e4585d1ac37b9575c68ee0d6c1b36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device is reading from a file.  <a href="#ad8e4585d1ac37b9575c68ee0d6c1b36c">More...</a><br /></td></tr>
<tr class="separator:ad8e4585d1ac37b9575c68ee0d6c1b36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa7cb1bde396c32660f01eb43a0c06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03aa7cb1bde396c32660f01eb43a0c06"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a03aa7cb1bde396c32660f01eb43a0c06">restartFilter</a> ()</td></tr>
<tr class="memdesc:a03aa7cb1bde396c32660f01eb43a0c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the software filter used by this device. <br /></td></tr>
<tr class="separator:a03aa7cb1bde396c32660f01eb43a0c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a34dbe6f9723875ff4889eef428b743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8a34dbe6f9723875ff4889eef428b743">lastResult</a> () const </td></tr>
<tr class="memdesc:a8a34dbe6f9723875ff4889eef428b743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result value of the last operation.  <a href="#a8a34dbe6f9723875ff4889eef428b743">More...</a><br /></td></tr>
<tr class="separator:a8a34dbe6f9723875ff4889eef428b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad365d14f454d0a9490fc6e2345a0d369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad365d14f454d0a9490fc6e2345a0d369">lastResultText</a> () const </td></tr>
<tr class="memdesc:ad365d14f454d0a9490fc6e2345a0d369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accompanying error text for the value returned by <a class="el" href="struct_xs_device.html#a8a34dbe6f9723875ff4889eef428b743" title="Get the result value of the last operation. ">lastResult()</a> It may provide situation-specific information instead.  <a href="#ad365d14f454d0a9490fc6e2345a0d369">More...</a><br /></td></tr>
<tr class="separator:ad365d14f454d0a9490fc6e2345a0d369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927ffd1b2a769e7955573990fe6b75e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a927ffd1b2a769e7955573990fe6b75e6">recordingQueueLength</a> () const </td></tr>
<tr class="memdesc:a927ffd1b2a769e7955573990fe6b75e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of packets currently waiting in the slow data cache for the device based.  <a href="#a927ffd1b2a769e7955573990fe6b75e6">More...</a><br /></td></tr>
<tr class="separator:a927ffd1b2a769e7955573990fe6b75e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044139a7a86a5f132ecc261cf2f0c0bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a044139a7a86a5f132ecc261cf2f0c0bb">cacheSize</a> () const </td></tr>
<tr class="memdesc:a044139a7a86a5f132ecc261cf2f0c0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently in the slow data cache for the device.  <a href="#a044139a7a86a5f132ecc261cf2f0c0bb">More...</a><br /></td></tr>
<tr class="separator:a044139a7a86a5f132ecc261cf2f0c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b46e5ef7a7b4fc81d6fac9664f6bf82"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7b46e5ef7a7b4fc81d6fac9664f6bf82">deviceState</a> () const </td></tr>
<tr class="memdesc:a7b46e5ef7a7b4fc81d6fac9664f6bf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of this device.  <a href="#a7b46e5ef7a7b4fc81d6fac9664f6bf82">More...</a><br /></td></tr>
<tr class="separator:a7b46e5ef7a7b4fc81d6fac9664f6bf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208157faba015c166f2878e070cfad94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a208157faba015c166f2878e070cfad94">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:a208157faba015c166f2878e070cfad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback handler list.  <a href="#a208157faba015c166f2878e070cfad94">More...</a><br /></td></tr>
<tr class="separator:a208157faba015c166f2878e070cfad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affecdda0f378e2193c75a3e01055eecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#affecdda0f378e2193c75a3e01055eecc">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:affecdda0f378e2193c75a3e01055eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a callback handler to the list.  <a href="#affecdda0f378e2193c75a3e01055eecc">More...</a><br /></td></tr>
<tr class="separator:affecdda0f378e2193c75a3e01055eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3608b05b6a94c8ff3889a1976ea42ee6">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#a3608b05b6a94c8ff3889a1976ea42ee6">More...</a><br /></td></tr>
<tr class="separator:a3608b05b6a94c8ff3889a1976ea42ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c0e4998bdbeeaefdc959c225e5bb0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a31c0e4998bdbeeaefdc959c225e5bb0b">operator&lt;</a> (const <a class="el" href="struct_xs_device.html">XsDevice</a> &amp;dev) const </td></tr>
<tr class="memdesc:a31c0e4998bdbeeaefdc959c225e5bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare device ID with that of <em>dev</em>.  <a href="#a31c0e4998bdbeeaefdc959c225e5bb0b">More...</a><br /></td></tr>
<tr class="separator:a31c0e4998bdbeeaefdc959c225e5bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a2266f0ccdac4d4bbd0f89d01eb461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a42a2266f0ccdac4d4bbd0f89d01eb461">operator==</a> (const <a class="el" href="struct_xs_device.html">XsDevice</a> &amp;dev) const </td></tr>
<tr class="memdesc:a42a2266f0ccdac4d4bbd0f89d01eb461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare device ID with that of <em>dev</em>.  <a href="#a42a2266f0ccdac4d4bbd0f89d01eb461">More...</a><br /></td></tr>
<tr class="separator:a42a2266f0ccdac4d4bbd0f89d01eb461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d698f3fa096130a504276a607f70c78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6d698f3fa096130a504276a607f70c78">operator&lt;</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> devId) const </td></tr>
<tr class="memdesc:a6d698f3fa096130a504276a607f70c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare device ID with <em>devId</em>.  <a href="#a6d698f3fa096130a504276a607f70c78">More...</a><br /></td></tr>
<tr class="separator:a6d698f3fa096130a504276a607f70c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f421f4262f4edb3c1d0f2ed5eff7076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7f421f4262f4edb3c1d0f2ed5eff7076">operator==</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> devId) const </td></tr>
<tr class="memdesc:a7f421f4262f4edb3c1d0f2ed5eff7076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare device ID with <em>devId</em>.  <a href="#a7f421f4262f4edb3c1d0f2ed5eff7076">More...</a><br /></td></tr>
<tr class="separator:a7f421f4262f4edb3c1d0f2ed5eff7076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec9a12b9eeae25242483bb6e7eb734a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9ec9a12b9eeae25242483bb6e7eb734a">deviceConfiguration</a> () const </td></tr>
<tr class="memdesc:a9ec9a12b9eeae25242483bb6e7eb734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device configuration.  <a href="#a9ec9a12b9eeae25242483bb6e7eb734a">More...</a><br /></td></tr>
<tr class="separator:a9ec9a12b9eeae25242483bb6e7eb734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12837e1d6d6e4016206023905a920457"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a12837e1d6d6e4016206023905a920457">batteryLevel</a> () const </td></tr>
<tr class="memdesc:a12837e1d6d6e4016206023905a920457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication.  <a href="#a12837e1d6d6e4016206023905a920457">More...</a><br /></td></tr>
<tr class="separator:a12837e1d6d6e4016206023905a920457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c7fbc6491350c79800b3dc20359fa3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3">updateRateForDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a81c7fbc6491350c79800b3dc20359fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a81c7fbc6491350c79800b3dc20359fa3">More...</a><br /></td></tr>
<tr class="separator:a81c7fbc6491350c79800b3dc20359fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3e588c33f4afdf18e6d4af7f4a2bcdb5">updateRateForProcessedDataIdentifier</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured update rate for the supplied <em>dataType</em>.  <a href="#a3e588c33f4afdf18e6d4af7f4a2bcdb5">More...</a><br /></td></tr>
<tr class="separator:a3e588c33f4afdf18e6d4af7f4a2bcdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617e87d8f8ccf472f4f622f2e872171d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a617e87d8f8ccf472f4f622f2e872171d">supportedUpdateRates</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType=<a class="el" href="group__enums.html#gga7f6c648c619f528344bfa0630c1f7252a0f6d9a98f741377d30c073548e64b97c">XDI_None</a>) const </td></tr>
<tr class="memdesc:a617e87d8f8ccf472f4f622f2e872171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported update rates for the given <em>dataType</em>.  <a href="#a617e87d8f8ccf472f4f622f2e872171d">More...</a><br /></td></tr>
<tr class="separator:a617e87d8f8ccf472f4f622f2e872171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf962a05593c38b4c628fad4d406adb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adf962a05593c38b4c628fad4d406adb1">maximumUpdateRate</a> () const </td></tr>
<tr class="memdesc:adf962a05593c38b4c628fad4d406adb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum update rate for the device.  <a href="#adf962a05593c38b4c628fad4d406adb1">More...</a><br /></td></tr>
<tr class="separator:adf962a05593c38b4c628fad4d406adb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24c84fbcf4691c7c31b76dc276c275"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275">hasDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:aee24c84fbcf4691c7c31b76dc276c275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em>.  <a href="#aee24c84fbcf4691c7c31b76dc276c275">More...</a><br /></td></tr>
<tr class="separator:aee24c84fbcf4691c7c31b76dc276c275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d8f53878808179a778b98e229e8242"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a76d8f53878808179a778b98e229e8242">hasProcessedDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:a76d8f53878808179a778b98e229e8242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the currently configured output contains <em>dataType</em> after processing on the host.  <a href="#a76d8f53878808179a778b98e229e8242">More...</a><br /></td></tr>
<tr class="separator:a76d8f53878808179a778b98e229e8242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcc8623208ee515981bc32efbacd4d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9fcc8623208ee515981bc32efbacd4d4">productCode</a> () const </td></tr>
<tr class="memdesc:a9fcc8623208ee515981bc32efbacd4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product code of the device.  <a href="#a9fcc8623208ee515981bc32efbacd4d4">More...</a><br /></td></tr>
<tr class="separator:a9fcc8623208ee515981bc32efbacd4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab990c3b52e6186d14d1112d0cf6459c3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab990c3b52e6186d14d1112d0cf6459c3">portName</a> () const </td></tr>
<tr class="memdesc:ab990c3b52e6186d14d1112d0cf6459c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port name of the connection.  <a href="#ab990c3b52e6186d14d1112d0cf6459c3">More...</a><br /></td></tr>
<tr class="separator:ab990c3b52e6186d14d1112d0cf6459c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9384e46ddc1c6c2ae4a3c17ec34dcd67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_port_info.html">XsPortInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9384e46ddc1c6c2ae4a3c17ec34dcd67">portInfo</a> () const </td></tr>
<tr class="memdesc:a9384e46ddc1c6c2ae4a3c17ec34dcd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The port information of the connection.  <a href="#a9384e46ddc1c6c2ae4a3c17ec34dcd67">More...</a><br /></td></tr>
<tr class="separator:a9384e46ddc1c6c2ae4a3c17ec34dcd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42156bdd1fa0f8b62ba9ae90cf41ddb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae42156bdd1fa0f8b62ba9ae90cf41ddb">baudRate</a> () const </td></tr>
<tr class="memdesc:ae42156bdd1fa0f8b62ba9ae90cf41ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected.  <a href="#ae42156bdd1fa0f8b62ba9ae90cf41ddb">More...</a><br /></td></tr>
<tr class="separator:ae42156bdd1fa0f8b62ba9ae90cf41ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e9fcca145bf4d9adf719c131dbf669"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae2e9fcca145bf4d9adf719c131dbf669">serialBaudRate</a> () const </td></tr>
<tr class="memdesc:ae2e9fcca145bf4d9adf719c131dbf669"><td class="mdescLeft">&#160;</td><td class="mdescRight">The baud rate configured for cabled connection.  <a href="#ae2e9fcca145bf4d9adf719c131dbf669">More...</a><br /></td></tr>
<tr class="separator:ae2e9fcca145bf4d9adf719c131dbf669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fc02227c6b58ef282cf9a3518badf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a511fc02227c6b58ef282cf9a3518badf">hardwareVersion</a> () const </td></tr>
<tr class="memdesc:a511fc02227c6b58ef282cf9a3518badf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hardware version of the device.  <a href="#a511fc02227c6b58ef282cf9a3518badf">More...</a><br /></td></tr>
<tr class="separator:a511fc02227c6b58ef282cf9a3518badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4e406b650ee865f52bb08984f68b75"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aab4e406b650ee865f52bb08984f68b75">portNumber</a> () const </td></tr>
<tr class="memdesc:aab4e406b650ee865f52bb08984f68b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the port number of the connection.  <a href="#aab4e406b650ee865f52bb08984f68b75">More...</a><br /></td></tr>
<tr class="separator:aab4e406b650ee865f52bb08984f68b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab803abd63d1355ed48f88782528e8772"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab803abd63d1355ed48f88782528e8772">startRecording</a> ()</td></tr>
<tr class="memdesc:ab803abd63d1355ed48f88782528e8772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data.  <a href="#ab803abd63d1355ed48f88782528e8772">More...</a><br /></td></tr>
<tr class="separator:ab803abd63d1355ed48f88782528e8772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999546432f1a4685acd2aab13795b7d9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a999546432f1a4685acd2aab13795b7d9">triggerStartRecording</a> ()</td></tr>
<tr class="memdesc:a999546432f1a4685acd2aab13795b7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording incoming data through generating a virtual input trigger.  <a href="#a999546432f1a4685acd2aab13795b7d9">More...</a><br /></td></tr>
<tr class="separator:a999546432f1a4685acd2aab13795b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dadcbf2a3d4748e464945d2c52030bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9dadcbf2a3d4748e464945d2c52030bd">stopRecording</a> ()</td></tr>
<tr class="memdesc:a9dadcbf2a3d4748e464945d2c52030bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording incoming data.  <a href="#a9dadcbf2a3d4748e464945d2c52030bd">More...</a><br /></td></tr>
<tr class="separator:a9dadcbf2a3d4748e464945d2c52030bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f45c09c173508322dc87769c153ea1"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad6f45c09c173508322dc87769c153ea1">getStartRecordingPacketId</a> () const </td></tr>
<tr class="memdesc:ad6f45c09c173508322dc87769c153ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ID of the first packet that should be recorded.  <a href="#ad6f45c09c173508322dc87769c153ea1">More...</a><br /></td></tr>
<tr class="separator:ad6f45c09c173508322dc87769c153ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace56912ce6c8ce53fd030ab126ab6f3a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ace56912ce6c8ce53fd030ab126ab6f3a">getStopRecordingPacketId</a> () const </td></tr>
<tr class="memdesc:ace56912ce6c8ce53fd030ab126ab6f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ID of the last packet that should be recorded.  <a href="#ace56912ce6c8ce53fd030ab126ab6f3a">More...</a><br /></td></tr>
<tr class="separator:ace56912ce6c8ce53fd030ab126ab6f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14166aed1e4d0e30fb3e80aed55453e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e">setOptions</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> enable, <a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> disable)</td></tr>
<tr class="memdesc:af14166aed1e4d0e30fb3e80aed55453e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and disable processing options.  <a href="#af14166aed1e4d0e30fb3e80aed55453e">More...</a><br /></td></tr>
<tr class="separator:af14166aed1e4d0e30fb3e80aed55453e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c443be103003479799fa888ada5216e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e">areOptionsEnabled</a> (<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> options) const </td></tr>
<tr class="memdesc:a8c443be103003479799fa888ada5216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when all the specified processing options are enabled.  <a href="#a8c443be103003479799fa888ada5216e">More...</a><br /></td></tr>
<tr class="separator:a8c443be103003479799fa888ada5216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4e4d771a85d93c00a4685f1e2b910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8de4e4d771a85d93c00a4685f1e2b910">getOptions</a> () const </td></tr>
<tr class="memdesc:a8de4e4d771a85d93c00a4685f1e2b910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the currently enabled options.  <a href="#a8de4e4d771a85d93c00a4685f1e2b910">More...</a><br /></td></tr>
<tr class="separator:a8de4e4d771a85d93c00a4685f1e2b910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9656439549ad9d4a2572aea7afaa48d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5">sendCustomMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageSend, bool waitForResult, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;messageReceive, int timeout=0)</td></tr>
<tr class="memdesc:a9656439549ad9d4a2572aea7afaa48d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a custom message <em>messageSend</em> to the device and possibly wait for a result.  <a href="#a9656439549ad9d4a2572aea7afaa48d5">More...</a><br /></td></tr>
<tr class="separator:a9656439549ad9d4a2572aea7afaa48d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68153cc14002d710e1c896b0ee6f1f9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac68153cc14002d710e1c896b0ee6f1f9">sendRawMessage</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:ac68153cc14002d710e1c896b0ee6f1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message directly to the communicator.  <a href="#ac68153cc14002d710e1c896b0ee6f1f9">More...</a><br /></td></tr>
<tr class="separator:ac68153cc14002d710e1c896b0ee6f1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf7faf0b7d3bb756df0b6a6cce5417c"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3bf7faf0b7d3bb756df0b6a6cce5417c">addReplyObject</a> (<a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a> messageId, uint8_t data)</td></tr>
<tr class="memdesc:a3bf7faf0b7d3bb756df0b6a6cce5417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a reply object to the communicator to wait for a specific message.  <a href="#a3bf7faf0b7d3bb756df0b6a6cce5417c">More...</a><br /></td></tr>
<tr class="separator:a3bf7faf0b7d3bb756df0b6a6cce5417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3febab304a21f08d188698aec93a97e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3febab304a21f08d188698aec93a97e2">setSerialBaudRate</a> (<a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> baudrate)</td></tr>
<tr class="memdesc:a3febab304a21f08d188698aec93a97e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the serial baudrate to <em>baudrate</em>.  <a href="#a3febab304a21f08d188698aec93a97e2">More...</a><br /></td></tr>
<tr class="separator:a3febab304a21f08d188698aec93a97e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298e2e614995a5bd65603152db701fe1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_int_array.html">XsIntArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a298e2e614995a5bd65603152db701fe1">portConfiguration</a> () const </td></tr>
<tr class="memdesc:a298e2e614995a5bd65603152db701fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current port configuration of a device.  <a href="#a298e2e614995a5bd65603152db701fe1">More...</a><br /></td></tr>
<tr class="separator:a298e2e614995a5bd65603152db701fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e60613acdb412005dd3ec00baf6622"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae6e60613acdb412005dd3ec00baf6622">setPortConfiguration</a> (<a class="el" href="struct_xs_int_array.html">XsIntArray</a> &amp;config)</td></tr>
<tr class="memdesc:ae6e60613acdb412005dd3ec00baf6622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the port configuration of a device.  <a href="#ae6e60613acdb412005dd3ec00baf6622">More...</a><br /></td></tr>
<tr class="separator:ae6e60613acdb412005dd3ec00baf6622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ee50e8e8bf46f27d705e609f99fa4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a281ee50e8e8bf46f27d705e609f99fa4">isMotionTracker</a> () const </td></tr>
<tr class="memdesc:a281ee50e8e8bf46f27d705e609f99fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a motion tracker.  <a href="#a281ee50e8e8bf46f27d705e609f99fa4">More...</a><br /></td></tr>
<tr class="separator:a281ee50e8e8bf46f27d705e609f99fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a26b4ee59a9235ce6b8c3bb23573ca"><td class="memItemLeft" align="right" valign="top">virtual XsOperationalMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af1a26b4ee59a9235ce6b8c3bb23573ca">operationalMode</a> () const </td></tr>
<tr class="memdesc:af1a26b4ee59a9235ce6b8c3bb23573ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operational mode.  <a href="#af1a26b4ee59a9235ce6b8c3bb23573ca">More...</a><br /></td></tr>
<tr class="separator:af1a26b4ee59a9235ce6b8c3bb23573ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1f3c5fb2d9a4b4f04ab99c7843fea294">setOperationalMode</a> (XsOperationalMode mode)</td></tr>
<tr class="memdesc:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device in the given operational mode.  <a href="#a1f3c5fb2d9a4b4f04ab99c7843fea294">More...</a><br /></td></tr>
<tr class="separator:a1f3c5fb2d9a4b4f04ab99c7843fea294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0414d3545864edc597331a861f8da04a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0414d3545864edc597331a861f8da04a">updateRate</a> () const </td></tr>
<tr class="memdesc:a0414d3545864edc597331a861f8da04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the legacy update rate of the device.  <a href="#a0414d3545864edc597331a861f8da04a">More...</a><br /></td></tr>
<tr class="separator:a0414d3545864edc597331a861f8da04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43f1e4fe0a563c86f40a663e113b1bbf">setUpdateRate</a> (int rate)</td></tr>
<tr class="memdesc:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the legacy update rate of the device.  <a href="#a43f1e4fe0a563c86f40a663e113b1bbf">More...</a><br /></td></tr>
<tr class="separator:a43f1e4fe0a563c86f40a663e113b1bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c5dbf8351d4d05c7dc0868a4ac7464"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae3c5dbf8351d4d05c7dc0868a4ac7464">deviceOptionFlags</a> () const </td></tr>
<tr class="memdesc:ae3c5dbf8351d4d05c7dc0868a4ac7464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device option flags.  <a href="#ae3c5dbf8351d4d05c7dc0868a4ac7464">More...</a><br /></td></tr>
<tr class="separator:ae3c5dbf8351d4d05c7dc0868a4ac7464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1033b2fd38c83d64db9390c5fb2368"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aef1033b2fd38c83d64db9390c5fb2368">setDeviceOptionFlags</a> (<a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> setFlags, <a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> clearFlags)</td></tr>
<tr class="memdesc:aef1033b2fd38c83d64db9390c5fb2368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device option flags.  <a href="#aef1033b2fd38c83d64db9390c5fb2368">More...</a><br /></td></tr>
<tr class="separator:aef1033b2fd38c83d64db9390c5fb2368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407e30aab29f1033873cce8d411fae83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a407e30aab29f1033873cce8d411fae83">outputConfiguration</a> () const </td></tr>
<tr class="memdesc:a407e30aab29f1033873cce8d411fae83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured output of the device.  <a href="#a407e30aab29f1033873cce8d411fae83">More...</a><br /></td></tr>
<tr class="separator:a407e30aab29f1033873cce8d411fae83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2728ffa190332b465cae18f7d0497d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9a2728ffa190332b465cae18f7d0497d">processedOutputConfiguration</a> () const </td></tr>
<tr class="memdesc:a9a2728ffa190332b465cae18f7d0497d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full output configuration including post processing outputs.  <a href="#a9a2728ffa190332b465cae18f7d0497d">More...</a><br /></td></tr>
<tr class="separator:a9a2728ffa190332b465cae18f7d0497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ba018ecf2f59b3e00e1471acf656ab"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a41ba018ecf2f59b3e00e1471acf656ab">setOutputConfiguration</a> (<a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;config)</td></tr>
<tr class="memdesc:a41ba018ecf2f59b3e00e1471acf656ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output configuration for this device.  <a href="#a41ba018ecf2f59b3e00e1471acf656ab">More...</a><br /></td></tr>
<tr class="separator:a41ba018ecf2f59b3e00e1471acf656ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5a6a04ca9857d9b0433c5f3bb8bc95"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1a5a6a04ca9857d9b0433c5f3bb8bc95">isInStringOutputMode</a> () const </td></tr>
<tr class="memdesc:a1a5a6a04ca9857d9b0433c5f3bb8bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device is outputting data in string mode.  <a href="#a1a5a6a04ca9857d9b0433c5f3bb8bc95">More...</a><br /></td></tr>
<tr class="separator:a1a5a6a04ca9857d9b0433c5f3bb8bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5de72dcccb8a595dca2a7babf20cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43f5de72dcccb8a595dca2a7babf20cb">canOutputConfiguration</a> () const </td></tr>
<tr class="memdesc:a43f5de72dcccb8a595dca2a7babf20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured CAN output of the device.  <a href="#a43f5de72dcccb8a595dca2a7babf20cb">More...</a><br /></td></tr>
<tr class="separator:a43f5de72dcccb8a595dca2a7babf20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cc34af532ebc3c86a948e99f3e307d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a53cc34af532ebc3c86a948e99f3e307d">setCanOutputConfiguration</a> (<a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> &amp;config)</td></tr>
<tr class="memdesc:a53cc34af532ebc3c86a948e99f3e307d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CAN output configuration for this device.  <a href="#a53cc34af532ebc3c86a948e99f3e307d">More...</a><br /></td></tr>
<tr class="separator:a53cc34af532ebc3c86a948e99f3e307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace981af9fb801acc89d459ac405eee42"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ace981af9fb801acc89d459ac405eee42">canConfiguration</a> () const </td></tr>
<tr class="memdesc:ace981af9fb801acc89d459ac405eee42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently configured CAN configuration of the device.  <a href="#ace981af9fb801acc89d459ac405eee42">More...</a><br /></td></tr>
<tr class="separator:ace981af9fb801acc89d459ac405eee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dbc784ace70b92caaefb7626d64887"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48dbc784ace70b92caaefb7626d64887">setCanConfiguration</a> (uint32_t config)</td></tr>
<tr class="memdesc:a48dbc784ace70b92caaefb7626d64887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CAN configuration for this device.  <a href="#a48dbc784ace70b92caaefb7626d64887">More...</a><br /></td></tr>
<tr class="separator:a48dbc784ace70b92caaefb7626d64887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae314c8eb8ae65b19b5eb82c24460c864"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae314c8eb8ae65b19b5eb82c24460c864">usesLegacyDeviceMode</a> () const </td></tr>
<tr class="memdesc:ae314c8eb8ae65b19b5eb82c24460c864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the device uses legacy device mode.  <a href="#ae314c8eb8ae65b19b5eb82c24460c864">More...</a><br /></td></tr>
<tr class="separator:ae314c8eb8ae65b19b5eb82c24460c864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a9346db6249006090854b4a0d7abf1"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a54a9346db6249006090854b4a0d7abf1">stringOutputType</a> () const </td></tr>
<tr class="memdesc:a54a9346db6249006090854b4a0d7abf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string output type.  <a href="#a54a9346db6249006090854b4a0d7abf1">More...</a><br /></td></tr>
<tr class="separator:a54a9346db6249006090854b4a0d7abf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3075a046f7402ba595692570e28786"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abc3075a046f7402ba595692570e28786">stringSamplePeriod</a> () const </td></tr>
<tr class="memdesc:abc3075a046f7402ba595692570e28786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample period for string output.  <a href="#abc3075a046f7402ba595692570e28786">More...</a><br /></td></tr>
<tr class="separator:abc3075a046f7402ba595692570e28786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8a74ecf8e68edc03225810b450ed4e"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ada8a74ecf8e68edc03225810b450ed4e">stringSkipFactor</a> () const </td></tr>
<tr class="memdesc:ada8a74ecf8e68edc03225810b450ed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skipfactor for string output.  <a href="#ada8a74ecf8e68edc03225810b450ed4e">More...</a><br /></td></tr>
<tr class="separator:ada8a74ecf8e68edc03225810b450ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f01736d0491a404eecd35cdfee3fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afd4f01736d0491a404eecd35cdfee3fc">setStringOutputMode</a> (uint16_t type, uint16_t period, uint16_t skipFactor)</td></tr>
<tr class="memdesc:afd4f01736d0491a404eecd35cdfee3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the string output mode for this device.  <a href="#afd4f01736d0491a404eecd35cdfee3fc">More...</a><br /></td></tr>
<tr class="separator:afd4f01736d0491a404eecd35cdfee3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eefe6a5b872d1d460c80901bd8ef95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_string_output_type_array.html">XsStringOutputTypeArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad6eefe6a5b872d1d460c80901bd8ef95">supportedStringOutputTypes</a> () const </td></tr>
<tr class="memdesc:ad6eefe6a5b872d1d460c80901bd8ef95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the device for its supported string output types.  <a href="#ad6eefe6a5b872d1d460c80901bd8ef95">More...</a><br /></td></tr>
<tr class="separator:ad6eefe6a5b872d1d460c80901bd8ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca70e4aa0cddfde706708f5037baa6df"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aca70e4aa0cddfde706708f5037baa6df">dataLength</a> () const </td></tr>
<tr class="memdesc:aca70e4aa0cddfde706708f5037baa6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the data in the legacy MTData packets that the device will send in measurement mode.  <a href="#aca70e4aa0cddfde706708f5037baa6df">More...</a><br /></td></tr>
<tr class="separator:aca70e4aa0cddfde706708f5037baa6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a280a0b4593ad684e84edcbdac51e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a36a280a0b4593ad684e84edcbdac51e8">syncSettings</a> () const </td></tr>
<tr class="memdesc:a36a280a0b4593ad684e84edcbdac51e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the current synchronization settings of the device.  <a href="#a36a280a0b4593ad684e84edcbdac51e8">More...</a><br /></td></tr>
<tr class="separator:a36a280a0b4593ad684e84edcbdac51e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027b516c49744d85c28129b9a95c4eaa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a027b516c49744d85c28129b9a95c4eaa">setSyncSettings</a> (const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;settingList)</td></tr>
<tr class="memdesc:a027b516c49744d85c28129b9a95c4eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the synchronization settings of the device.  <a href="#a027b516c49744d85c28129b9a95c4eaa">More...</a><br /></td></tr>
<tr class="separator:a027b516c49744d85c28129b9a95c4eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad82485ecd1d88316a1e7098d720c5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a81ad82485ecd1d88316a1e7098d720c5">isSyncMaster</a> () const </td></tr>
<tr class="memdesc:a81ad82485ecd1d88316a1e7098d720c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a master role regarding the device synchronization  <a href="#a81ad82485ecd1d88316a1e7098d720c5">More...</a><br /></td></tr>
<tr class="separator:a81ad82485ecd1d88316a1e7098d720c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496b1aa7178a7059b4dc0788f594309a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a496b1aa7178a7059b4dc0788f594309a">isSyncSlave</a> () const </td></tr>
<tr class="memdesc:a496b1aa7178a7059b4dc0788f594309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this device is in a slave role regarding the device synchronization  <a href="#a496b1aa7178a7059b4dc0788f594309a">More...</a><br /></td></tr>
<tr class="separator:a496b1aa7178a7059b4dc0788f594309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0e9feb7a03ef39bc8c1f4d706b3032"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9c0e9feb7a03ef39bc8c1f4d706b3032">supportedSyncSettings</a> () const </td></tr>
<tr class="memdesc:a9c0e9feb7a03ef39bc8c1f4d706b3032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all supported synchronization settings available on the device.  <a href="#a9c0e9feb7a03ef39bc8c1f4d706b3032">More...</a><br /></td></tr>
<tr class="separator:a9c0e9feb7a03ef39bc8c1f4d706b3032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4877bf929d1f0e44b7f82db60bbdb1da"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4877bf929d1f0e44b7f82db60bbdb1da">gotoMeasurement</a> ()</td></tr>
<tr class="memdesc:a4877bf929d1f0e44b7f82db60bbdb1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put this device in measurement mode.  <a href="#a4877bf929d1f0e44b7f82db60bbdb1da">More...</a><br /></td></tr>
<tr class="separator:a4877bf929d1f0e44b7f82db60bbdb1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a1fd038c9b569596e2ff48aaad39be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a64a1fd038c9b569596e2ff48aaad39be">gotoConfig</a> ()</td></tr>
<tr class="memdesc:a64a1fd038c9b569596e2ff48aaad39be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in config mode.  <a href="#a64a1fd038c9b569596e2ff48aaad39be">More...</a><br /></td></tr>
<tr class="separator:a64a1fd038c9b569596e2ff48aaad39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c4968f733da476e3e80bb024f01e4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae2c4968f733da476e3e80bb024f01e4c">restoreFactoryDefaults</a> ()</td></tr>
<tr class="memdesc:ae2c4968f733da476e3e80bb024f01e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the device to its factory default settings.  <a href="#ae2c4968f733da476e3e80bb024f01e4c">More...</a><br /></td></tr>
<tr class="separator:ae2c4968f733da476e3e80bb024f01e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2cc69f91abac03f00f631cb530d9db"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8d2cc69f91abac03f00f631cb530d9db">reset</a> ()</td></tr>
<tr class="memdesc:a8d2cc69f91abac03f00f631cb530d9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the device.  <a href="#a8d2cc69f91abac03f00f631cb530d9db">More...</a><br /></td></tr>
<tr class="separator:a8d2cc69f91abac03f00f631cb530d9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d8c44453e80d1c9fa2efc30062cd79"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a48d8c44453e80d1c9fa2efc30062cd79">reopenPort</a> (bool <a class="el" href="struct_xs_device.html#a64a1fd038c9b569596e2ff48aaad39be">gotoConfig</a>, bool skipDeviceIdCheck=false)</td></tr>
<tr class="memdesc:a48d8c44453e80d1c9fa2efc30062cd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens a port Uses rescan method to redetect a device. Also if USB descriptor has changed.  <a href="#a48d8c44453e80d1c9fa2efc30062cd79">More...</a><br /></td></tr>
<tr class="separator:a48d8c44453e80d1c9fa2efc30062cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5a51c0a47c94ec087f69abc04c7582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5a51c0a47c94ec087f69abc04c7582"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5c5a51c0a47c94ec087f69abc04c7582">writeDeviceSettingsToFile</a> ()</td></tr>
<tr class="memdesc:a5c5a51c0a47c94ec087f69abc04c7582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the emts/wms/xms of the device and all its children to the open logfile. <br /></td></tr>
<tr class="separator:a5c5a51c0a47c94ec087f69abc04c7582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793735c051bda0beba589f4c72060e4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793735c051bda0beba589f4c72060e4f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a793735c051bda0beba589f4c72060e4f">flushInputBuffers</a> ()</td></tr>
<tr class="memdesc:a793735c051bda0beba589f4c72060e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the inbound data buffers of the device. <br /></td></tr>
<tr class="separator:a793735c051bda0beba589f4c72060e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6148702cdd98e4085fe4f4ca399bdd10"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6148702cdd98e4085fe4f4ca399bdd10">syncRole</a> () const </td></tr>
<tr class="memdesc:a6148702cdd98e4085fe4f4ca399bdd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the synchronization role of the device.  <a href="#a6148702cdd98e4085fe4f4ca399bdd10">More...</a><br /></td></tr>
<tr class="separator:a6148702cdd98e4085fe4f4ca399bdd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb3d5926ba88aace3a6c7bc2317487d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8cb3d5926ba88aace3a6c7bc2317487d">loadLogFile</a> ()</td></tr>
<tr class="memdesc:a8cb3d5926ba88aace3a6c7bc2317487d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a complete logfile.  <a href="#a8cb3d5926ba88aace3a6c7bc2317487d">More...</a><br /></td></tr>
<tr class="separator:a8cb3d5926ba88aace3a6c7bc2317487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8759ef4e201718a78333b39f26e0a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5d8759ef4e201718a78333b39f26e0a8">abortLoadLogFile</a> ()</td></tr>
<tr class="memdesc:a5d8759ef4e201718a78333b39f26e0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts loading a logfile.  <a href="#a5d8759ef4e201718a78333b39f26e0a8">More...</a><br /></td></tr>
<tr class="separator:a5d8759ef4e201718a78333b39f26e0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dd574076bb067b83bfd3dac5e3a969"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_string.html">XsString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a92dd574076bb067b83bfd3dac5e3a969">logFileName</a> () const </td></tr>
<tr class="memdesc:a92dd574076bb067b83bfd3dac5e3a969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the log file the device is reading from.  <a href="#a92dd574076bb067b83bfd3dac5e3a969">More...</a><br /></td></tr>
<tr class="separator:a92dd574076bb067b83bfd3dac5e3a969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeafc3cb53243db1aaea7213002d42c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3aeafc3cb53243db1aaea7213002d42c">resetOrientation</a> (<a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a> resetmethod)</td></tr>
<tr class="memdesc:a3aeafc3cb53243db1aaea7213002d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an orientation reset on the device using the given <em>resetMethod</em>.  <a href="#a3aeafc3cb53243db1aaea7213002d42c">More...</a><br /></td></tr>
<tr class="separator:a3aeafc3cb53243db1aaea7213002d42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96eff95f19b7f77be17dbbb28478aa63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a96eff95f19b7f77be17dbbb28478aa63">resetLogFileReadPosition</a> ()</td></tr>
<tr class="memdesc:a96eff95f19b7f77be17dbbb28478aa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read position of the open log file to the start of the file.  <a href="#a96eff95f19b7f77be17dbbb28478aa63">More...</a><br /></td></tr>
<tr class="separator:a96eff95f19b7f77be17dbbb28478aa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343de9131eeb1088d9f0df2f38321a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a343de9131eeb1088d9f0df2f38321a29">logFileSize</a> () const </td></tr>
<tr class="memdesc:a343de9131eeb1088d9f0df2f38321a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the log file the device is reading from.  <a href="#a343de9131eeb1088d9f0df2f38321a29">More...</a><br /></td></tr>
<tr class="separator:a343de9131eeb1088d9f0df2f38321a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48f3bd1691f9e6ac5d5d35ecf5d160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acc48f3bd1691f9e6ac5d5d35ecf5d160">logFileReadPosition</a> () const </td></tr>
<tr class="memdesc:acc48f3bd1691f9e6ac5d5d35ecf5d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current read position of the open log file.  <a href="#acc48f3bd1691f9e6ac5d5d35ecf5d160">More...</a><br /></td></tr>
<tr class="separator:acc48f3bd1691f9e6ac5d5d35ecf5d160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3395680c39ebf615f62dc30a4cac5b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9b3395680c39ebf615f62dc30a4cac5b">updateCachedDeviceInformation</a> ()</td></tr>
<tr class="memdesc:a9b3395680c39ebf615f62dc30a4cac5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the cached device information for all devices connected to this port.  <a href="#a9b3395680c39ebf615f62dc30a4cac5b">More...</a><br /></td></tr>
<tr class="separator:a9b3395680c39ebf615f62dc30a4cac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026c49500ad437124d9d4f3d8734f6d9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9">enableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:a026c49500ad437124d9d4f3d8734f6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an additional communication protocol when reading messages.  <a href="#a026c49500ad437124d9d4f3d8734f6d9">More...</a><br /></td></tr>
<tr class="separator:a026c49500ad437124d9d4f3d8734f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a12cb16caa27b67d8c5e6b6f534acb5f4">disableProtocol</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol)</td></tr>
<tr class="memdesc:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9" title="Enable an additional communication protocol when reading messages. ">XsDevice::enableProtocol</a>.  <a href="#a12cb16caa27b67d8c5e6b6f534acb5f4">More...</a><br /></td></tr>
<tr class="separator:a12cb16caa27b67d8c5e6b6f534acb5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda57eca1b67c459bb0aa44f9c3130fe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aeda57eca1b67c459bb0aa44f9c3130fe">isProtocolEnabled</a> (<a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> protocol) const </td></tr>
<tr class="separator:aeda57eca1b67c459bb0aa44f9c3130fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a614d1be1baed8fd5041d4ce2768478"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1a614d1be1baed8fd5041d4ce2768478">deviceBufferSize</a> ()</td></tr>
<tr class="memdesc:a1a614d1be1baed8fd5041d4ce2768478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the size of the interal buffer.  <a href="#a1a614d1be1baed8fd5041d4ce2768478">More...</a><br /></td></tr>
<tr class="separator:a1a614d1be1baed8fd5041d4ce2768478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf52735776e76c08aeb22e24b7bf78d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#acbf52735776e76c08aeb22e24b7bf78d">setDeviceBufferSize</a> (uint32_t frames)</td></tr>
<tr class="memdesc:acbf52735776e76c08aeb22e24b7bf78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the device to set it's internal buffer to the specified size.  <a href="#acbf52735776e76c08aeb22e24b7bf78d">More...</a><br /></td></tr>
<tr class="separator:acbf52735776e76c08aeb22e24b7bf78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8270c2ec0fe8edc9663209c91c564680"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8270c2ec0fe8edc9663209c91c564680">connectivityState</a> () const </td></tr>
<tr class="memdesc:a8270c2ec0fe8edc9663209c91c564680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connectivity state of the device.  <a href="#a8270c2ec0fe8edc9663209c91c564680">More...</a><br /></td></tr>
<tr class="separator:a8270c2ec0fe8edc9663209c91c564680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9bfac62bee437be07164dac860049b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aad9bfac62bee437be07164dac860049b">waitForAllDevicesInitialized</a> ()</td></tr>
<tr class="memdesc:aad9bfac62bee437be07164dac860049b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until are known devices are initialized.  <a href="#aad9bfac62bee437be07164dac860049b">More...</a><br /></td></tr>
<tr class="separator:aad9bfac62bee437be07164dac860049b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a4f4c47e120d7a93738acadf2d305"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="struct_xs_device.html">XsDevice</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4a0a4f4c47e120d7a93738acadf2d305">children</a> () const </td></tr>
<tr class="memdesc:a4a0a4f4c47e120d7a93738acadf2d305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a managed array containing the child-devices this device has. For standalone devices this is always an empty array.  <a href="#a4a0a4f4c47e120d7a93738acadf2d305">More...</a><br /></td></tr>
<tr class="separator:a4a0a4f4c47e120d7a93738acadf2d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be5c50cfcd3f79a90ed281bb739b1c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a00be5c50cfcd3f79a90ed281bb739b1c">childCount</a> () const </td></tr>
<tr class="memdesc:a00be5c50cfcd3f79a90ed281bb739b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of child-devices this device has. For standalone devices this is always 0.  <a href="#a00be5c50cfcd3f79a90ed281bb739b1c">More...</a><br /></td></tr>
<tr class="separator:a00be5c50cfcd3f79a90ed281bb739b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af0dcccddf838764795b169213a9af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a24af0dcccddf838764795b169213a9af">enableRadio</a> (int channel)</td></tr>
<tr class="memdesc:a24af0dcccddf838764795b169213a9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the radio channel to use for wireless communication.  <a href="#a24af0dcccddf838764795b169213a9af">More...</a><br /></td></tr>
<tr class="separator:a24af0dcccddf838764795b169213a9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0bc12c41ea7ffc8f69a3cd619716f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afd0bc12c41ea7ffc8f69a3cd619716f4">disableRadio</a> ()</td></tr>
<tr class="memdesc:afd0bc12c41ea7ffc8f69a3cd619716f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the radio for this station, resetting all children to disconnected state.  <a href="#afd0bc12c41ea7ffc8f69a3cd619716f4">More...</a><br /></td></tr>
<tr class="separator:afd0bc12c41ea7ffc8f69a3cd619716f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93842091b4abc3a96c7e5b6a2a5d4ea3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a93842091b4abc3a96c7e5b6a2a5d4ea3">radioChannel</a> () const </td></tr>
<tr class="memdesc:a93842091b4abc3a96c7e5b6a2a5d4ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the radio channel used for wireless communication.  <a href="#a93842091b4abc3a96c7e5b6a2a5d4ea3">More...</a><br /></td></tr>
<tr class="separator:a93842091b4abc3a96c7e5b6a2a5d4ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4ff180af0c4501cbe0a51c7d54ccc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a10d4ff180af0c4501cbe0a51c7d54ccc">isRadioEnabled</a> () const </td></tr>
<tr class="memdesc:a10d4ff180af0c4501cbe0a51c7d54ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the radio is enabled.  <a href="#a10d4ff180af0c4501cbe0a51c7d54ccc">More...</a><br /></td></tr>
<tr class="separator:a10d4ff180af0c4501cbe0a51c7d54ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a5477b86747083efca644b80355ea8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a25a5477b86747083efca644b80355ea8">makeOperational</a> ()</td></tr>
<tr class="memdesc:a25a5477b86747083efca644b80355ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Awinda station to operational state.  <a href="#a25a5477b86747083efca644b80355ea8">More...</a><br /></td></tr>
<tr class="separator:a25a5477b86747083efca644b80355ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c3e71ff320ed86a7accc0db5891159"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac3c3e71ff320ed86a7accc0db5891159">isOperational</a> () const </td></tr>
<tr class="separator:ac3c3e71ff320ed86a7accc0db5891159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0184dcf9a8c03941b3232c5e15dfa2a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa0184dcf9a8c03941b3232c5e15dfa2a">isInSyncStationMode</a> ()</td></tr>
<tr class="separator:aa0184dcf9a8c03941b3232c5e15dfa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a43b42d6bab3640389ba5936cbd5aaa4d">setSyncStationMode</a> (bool enabled)</td></tr>
<tr class="memdesc:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Sync Station mode of the Awinda Station device.  <a href="#a43b42d6bab3640389ba5936cbd5aaa4d">More...</a><br /></td></tr>
<tr class="separator:a43b42d6bab3640389ba5936cbd5aaa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5165731cc588681c960db5dfb86a5cfe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5165731cc588681c960db5dfb86a5cfe">stealthMode</a> () const </td></tr>
<tr class="memdesc:a5165731cc588681c960db5dfb86a5cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of the stealth mode setting.  <a href="#a5165731cc588681c960db5dfb86a5cfe">More...</a><br /></td></tr>
<tr class="separator:a5165731cc588681c960db5dfb86a5cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6d31de9b2703f3f28451413b047cde"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1b6d31de9b2703f3f28451413b047cde">setStealthMode</a> (bool enabled)</td></tr>
<tr class="memdesc:a1b6d31de9b2703f3f28451413b047cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable stealth mode.  <a href="#a1b6d31de9b2703f3f28451413b047cde">More...</a><br /></td></tr>
<tr class="separator:a1b6d31de9b2703f3f28451413b047cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9a63a1bc2d1424df962f81bbcf8977bb">discardRetransmissions</a> (int64_t firstNewPacketId)</td></tr>
<tr class="memdesc:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell XDA and the device that any data from before <em>firstNewPacketId</em> may be lossy.  <a href="#a9a63a1bc2d1424df962f81bbcf8977bb">More...</a><br /></td></tr>
<tr class="separator:a9a63a1bc2d1424df962f81bbcf8977bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896f5a1cc4f6000801130ff6b11fd064"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a896f5a1cc4f6000801130ff6b11fd064">abortFlushing</a> ()</td></tr>
<tr class="memdesc:a896f5a1cc4f6000801130ff6b11fd064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the wireless flushing operation and finalize the recording.  <a href="#a896f5a1cc4f6000801130ff6b11fd064">More...</a><br /></td></tr>
<tr class="separator:a896f5a1cc4f6000801130ff6b11fd064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2fa1b5a95fc6cae2b3b661936dc79670">setDeviceAccepted</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="memdesc:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a device.  <a href="#a2fa1b5a95fc6cae2b3b661936dc79670">More...</a><br /></td></tr>
<tr class="separator:a2fa1b5a95fc6cae2b3b661936dc79670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cddf966e39a4abacb0bc279e31ffdf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a16cddf966e39a4abacb0bc279e31ffdf">setDeviceRejected</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="memdesc:a16cddf966e39a4abacb0bc279e31ffdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects a device.  <a href="#a16cddf966e39a4abacb0bc279e31ffdf">More...</a><br /></td></tr>
<tr class="separator:a16cddf966e39a4abacb0bc279e31ffdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf">setAccessControlMode</a> (<a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a> mode, const <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> &amp;initialList)</td></tr>
<tr class="memdesc:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the access control mode of the master device.  <a href="#ac620eb9326e9c98fdd82dd597cf39cbf">More...</a><br /></td></tr>
<tr class="separator:ac620eb9326e9c98fdd82dd597cf39cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06eb9a731cec918e7087af24ecf9d19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad06eb9a731cec918e7087af24ecf9d19">accessControlMode</a> () const </td></tr>
<tr class="memdesc:ad06eb9a731cec918e7087af24ecf9d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the access control mode of the master device.  <a href="#ad06eb9a731cec918e7087af24ecf9d19">More...</a><br /></td></tr>
<tr class="separator:ad06eb9a731cec918e7087af24ecf9d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fd097811cf459eec7855bfdd7447e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad0fd097811cf459eec7855bfdd7447e0">currentAccessControlList</a> () const </td></tr>
<tr class="memdesc:ad0fd097811cf459eec7855bfdd7447e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the access control list of the master device.  <a href="#ad0fd097811cf459eec7855bfdd7447e0">More...</a><br /></td></tr>
<tr class="separator:ad0fd097811cf459eec7855bfdd7447e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a21fea2a2341f73d15b641ddcaae827"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9a21fea2a2341f73d15b641ddcaae827">setDeviceParameter</a> (<a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> const &amp;parameter)</td></tr>
<tr class="memdesc:a9a21fea2a2341f73d15b641ddcaae827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given parameter for the device.  <a href="#a9a21fea2a2341f73d15b641ddcaae827">More...</a><br /></td></tr>
<tr class="separator:a9a21fea2a2341f73d15b641ddcaae827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a76cfeac115b80bd9e879838dbfd0ef6f">deviceParameter</a> (<a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;parameter) const </td></tr>
<tr class="memdesc:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the requested parameter's current value.  <a href="#a76cfeac115b80bd9e879838dbfd0ef6f">More...</a><br /></td></tr>
<tr class="separator:a76cfeac115b80bd9e879838dbfd0ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17e694dc4601b9afd44067a04d60c1d"><td class="memItemLeft" align="right" valign="top">virtual XsGnssPlatform&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae17e694dc4601b9afd44067a04d60c1d">gnssPlatform</a> () const </td></tr>
<tr class="memdesc:ae17e694dc4601b9afd44067a04d60c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device GNSS platform.  <a href="#ae17e694dc4601b9afd44067a04d60c1d">More...</a><br /></td></tr>
<tr class="separator:ae17e694dc4601b9afd44067a04d60c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220f5fa69008190200f3845dd464f9f9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a220f5fa69008190200f3845dd464f9f9">setGnssPlatform</a> (XsGnssPlatform <a class="el" href="struct_xs_device.html#ae17e694dc4601b9afd44067a04d60c1d">gnssPlatform</a>)</td></tr>
<tr class="memdesc:a220f5fa69008190200f3845dd464f9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device GNSS platform.  <a href="#a220f5fa69008190200f3845dd464f9f9">More...</a><br /></td></tr>
<tr class="separator:a220f5fa69008190200f3845dd464f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bb30f38df4659cb681b7b3a7b99067"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac7bb30f38df4659cb681b7b3a7b99067">acceptConnection</a> ()</td></tr>
<tr class="memdesc:ac7bb30f38df4659cb681b7b3a7b99067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connections from the device on the parent/master device.  <a href="#ac7bb30f38df4659cb681b7b3a7b99067">More...</a><br /></td></tr>
<tr class="separator:ac7bb30f38df4659cb681b7b3a7b99067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efc96f2ce70f18e2837a59da6a4c133"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7efc96f2ce70f18e2837a59da6a4c133">rejectConnection</a> ()</td></tr>
<tr class="memdesc:a7efc96f2ce70f18e2837a59da6a4c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject connections from the device on the parent/master device.  <a href="#a7efc96f2ce70f18e2837a59da6a4c133">More...</a><br /></td></tr>
<tr class="separator:a7efc96f2ce70f18e2837a59da6a4c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32cf140f5fdc2609d65397a04eb3358"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac32cf140f5fdc2609d65397a04eb3358">wirelessPriority</a> () const </td></tr>
<tr class="memdesc:ac32cf140f5fdc2609d65397a04eb3358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wireless priority of the device.  <a href="#ac32cf140f5fdc2609d65397a04eb3358">More...</a><br /></td></tr>
<tr class="separator:ac32cf140f5fdc2609d65397a04eb3358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5777d11869ea81ba031387a00eecc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2b5777d11869ea81ba031387a00eecc2">setWirelessPriority</a> (int priority)</td></tr>
<tr class="memdesc:a2b5777d11869ea81ba031387a00eecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wireless priority of the device.  <a href="#a2b5777d11869ea81ba031387a00eecc2">More...</a><br /></td></tr>
<tr class="separator:a2b5777d11869ea81ba031387a00eecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0030d17e28da4d440bdc47bdea7c42d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0030d17e28da4d440bdc47bdea7c42d0">rejectReason</a> () const </td></tr>
<tr class="memdesc:a0030d17e28da4d440bdc47bdea7c42d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason why a device's connection was rejected.  <a href="#a0030d17e28da4d440bdc47bdea7c42d0">More...</a><br /></td></tr>
<tr class="separator:a0030d17e28da4d440bdc47bdea7c42d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f8e3b9c96877dd7e77b06892fa486a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a79f8e3b9c96877dd7e77b06892fa486a">requestBatteryLevel</a> ()</td></tr>
<tr class="memdesc:a79f8e3b9c96877dd7e77b06892fa486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the battery level from the device.  <a href="#a79f8e3b9c96877dd7e77b06892fa486a">More...</a><br /></td></tr>
<tr class="separator:a79f8e3b9c96877dd7e77b06892fa486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1937de9f8e39f990f010ed9b2a56d5dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1937de9f8e39f990f010ed9b2a56d5dc">batteryLevelTime</a> ()</td></tr>
<tr class="memdesc:a1937de9f8e39f990f010ed9b2a56d5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the time the battery level was last updated.  <a href="#a1937de9f8e39f990f010ed9b2a56d5dc">More...</a><br /></td></tr>
<tr class="separator:a1937de9f8e39f990f010ed9b2a56d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01256f48cf926440c226c91fadc72ab8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a01256f48cf926440c226c91fadc72ab8">setTransportMode</a> (bool transportModeEnabled)</td></tr>
<tr class="memdesc:a01256f48cf926440c226c91fadc72ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the transport mode for the device.  <a href="#a01256f48cf926440c226c91fadc72ab8">More...</a><br /></td></tr>
<tr class="separator:a01256f48cf926440c226c91fadc72ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0314b50c08e60167cf8419a150e866d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0314b50c08e60167cf8419a150e866d0">transportMode</a> ()</td></tr>
<tr class="memdesc:a0314b50c08e60167cf8419a150e866d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of the transport mode feature.  <a href="#a0314b50c08e60167cf8419a150e866d0">More...</a><br /></td></tr>
<tr class="separator:a0314b50c08e60167cf8419a150e866d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99be0d4d89eec4ff406d0098aac937cf"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a99be0d4d89eec4ff406d0098aac937cf">lastKnownRssi</a> () const </td></tr>
<tr class="memdesc:a99be0d4d89eec4ff406d0098aac937cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last known RSSI value of the device.  <a href="#a99be0d4d89eec4ff406d0098aac937cf">More...</a><br /></td></tr>
<tr class="separator:a99be0d4d89eec4ff406d0098aac937cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a2685f15e5cb66082668af015aee43"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a19a2685f15e5cb66082668af015aee43">packetErrorRate</a> () const </td></tr>
<tr class="memdesc:a19a2685f15e5cb66082668af015aee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet error rate for the for the device.  <a href="#a19a2685f15e5cb66082668af015aee43">More...</a><br /></td></tr>
<tr class="separator:a19a2685f15e5cb66082668af015aee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3487b6bfd1e9b7e46862e152f894eb9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af3487b6bfd1e9b7e46862e152f894eb9">isBlueToothEnabled</a> () const </td></tr>
<tr class="memdesc:af3487b6bfd1e9b7e46862e152f894eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the device has its BlueTooth radio enabled.  <a href="#af3487b6bfd1e9b7e46862e152f894eb9">More...</a><br /></td></tr>
<tr class="separator:af3487b6bfd1e9b7e46862e152f894eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99583e7e3b8be3c0f70454ebbf885afd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a99583e7e3b8be3c0f70454ebbf885afd">setBlueToothEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a99583e7e3b8be3c0f70454ebbf885afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the BlueTooth radio of the device.  <a href="#a99583e7e3b8be3c0f70454ebbf885afd">More...</a><br /></td></tr>
<tr class="separator:a99583e7e3b8be3c0f70454ebbf885afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44e4219466145e162d01ed500ec702"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9b44e4219466145e162d01ed500ec702">isBusPowerEnabled</a> () const </td></tr>
<tr class="memdesc:a9b44e4219466145e162d01ed500ec702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the Xbus is powering its child devices or not.  <a href="#a9b44e4219466145e162d01ed500ec702">More...</a><br /></td></tr>
<tr class="separator:a9b44e4219466145e162d01ed500ec702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af6b8c2b18ad882c64b0ff3b7ad89655d">setBusPowerEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the Xbus to provide power to its child devices or not.  <a href="#af6b8c2b18ad882c64b0ff3b7ad89655d">More...</a><br /></td></tr>
<tr class="separator:af6b8c2b18ad882c64b0ff3b7ad89655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc75871294b0e2e6cf449268730cb1a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1dc75871294b0e2e6cf449268730cb1a">powerDown</a> ()</td></tr>
<tr class="memdesc:a1dc75871294b0e2e6cf449268730cb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the device to power down completely.  <a href="#a1dc75871294b0e2e6cf449268730cb1a">More...</a><br /></td></tr>
<tr class="separator:a1dc75871294b0e2e6cf449268730cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689e1d8c857703bdf8d60c51ef6db8e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa689e1d8c857703bdf8d60c51ef6db8e">errorMode</a> () const </td></tr>
<tr class="memdesc:aa689e1d8c857703bdf8d60c51ef6db8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error mode of the device.  <a href="#aa689e1d8c857703bdf8d60c51ef6db8e">More...</a><br /></td></tr>
<tr class="separator:aa689e1d8c857703bdf8d60c51ef6db8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a91f03a8e30b52e38cebb8bfc3e6a7573">setErrorMode</a> (<a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> errormode)</td></tr>
<tr class="memdesc:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error mode of the device.  <a href="#a91f03a8e30b52e38cebb8bfc3e6a7573">More...</a><br /></td></tr>
<tr class="separator:a91f03a8e30b52e38cebb8bfc3e6a7573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e374050eb6373033799b6a3acb9d61"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61">setHeadingOffset</a> (double offset)</td></tr>
<tr class="memdesc:a25e374050eb6373033799b6a3acb9d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'heading offset' setting of the device.  <a href="#a25e374050eb6373033799b6a3acb9d61">More...</a><br /></td></tr>
<tr class="separator:a25e374050eb6373033799b6a3acb9d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a3d27cd952dc87d660f18c884f542"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a717a3d27cd952dc87d660f18c884f542">headingOffset</a> () const </td></tr>
<tr class="memdesc:a717a3d27cd952dc87d660f18c884f542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the 'heading offset' setting of the device.  <a href="#a717a3d27cd952dc87d660f18c884f542">More...</a><br /></td></tr>
<tr class="separator:a717a3d27cd952dc87d660f18c884f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d6968b26addd3da277435a0fbec82a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a89d6968b26addd3da277435a0fbec82a">setLocationId</a> (int id)</td></tr>
<tr class="memdesc:a89d6968b26addd3da277435a0fbec82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location ID of the device.  <a href="#a89d6968b26addd3da277435a0fbec82a">More...</a><br /></td></tr>
<tr class="separator:a89d6968b26addd3da277435a0fbec82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25b4c19c9861f059510289fbf8e6eb3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad25b4c19c9861f059510289fbf8e6eb3">locationId</a> () const </td></tr>
<tr class="memdesc:ad25b4c19c9861f059510289fbf8e6eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location ID of the device.  <a href="#ad25b4c19c9861f059510289fbf8e6eb3">More...</a><br /></td></tr>
<tr class="separator:ad25b4c19c9861f059510289fbf8e6eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551c9cc98da43c7953f01d412ecb986"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3551c9cc98da43c7953f01d412ecb986">getDeviceFromLocationId</a> (uint16_t locId)</td></tr>
<tr class="memdesc:a3551c9cc98da43c7953f01d412ecb986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device given <em>locId</em>.  <a href="#a3551c9cc98da43c7953f01d412ecb986">More...</a><br /></td></tr>
<tr class="separator:a3551c9cc98da43c7953f01d412ecb986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d8cd66fecdff0276a890401e331996"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a68d8cd66fecdff0276a890401e331996">objectAlignment</a> () const </td></tr>
<tr class="memdesc:a68d8cd66fecdff0276a890401e331996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object alignment matrix of the device.  <a href="#a68d8cd66fecdff0276a890401e331996">More...</a><br /></td></tr>
<tr class="separator:a68d8cd66fecdff0276a890401e331996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3bbd3c53640d1f34d3990fe6349a4a40">setObjectAlignment</a> (const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the object alignment of the device to the given <em>matrix</em>.  <a href="#a3bbd3c53640d1f34d3990fe6349a4a40">More...</a><br /></td></tr>
<tr class="separator:a3bbd3c53640d1f34d3990fe6349a4a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e4d362fb66a5ccef8a458c2320f4fa"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a15e4d362fb66a5ccef8a458c2320f4fa">gravityMagnitude</a> () const </td></tr>
<tr class="memdesc:a15e4d362fb66a5ccef8a458c2320f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'Gravity Magnitude' of the device.  <a href="#a15e4d362fb66a5ccef8a458c2320f4fa">More...</a><br /></td></tr>
<tr class="separator:a15e4d362fb66a5ccef8a458c2320f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aecf0f050da7d709d73917ece872436"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436">setGravityMagnitude</a> (double mag)</td></tr>
<tr class="memdesc:a1aecf0f050da7d709d73917ece872436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>.  <a href="#a1aecf0f050da7d709d73917ece872436">More...</a><br /></td></tr>
<tr class="separator:a1aecf0f050da7d709d73917ece872436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cebe3dd7502b5d2e14659b770937b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_vector.html">XsVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a21cebe3dd7502b5d2e14659b770937b3">initialPositionLLA</a> () const </td></tr>
<tr class="memdesc:a21cebe3dd7502b5d2e14659b770937b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'Latitude Longitude Altitude' setting of the device.  <a href="#a21cebe3dd7502b5d2e14659b770937b3">More...</a><br /></td></tr>
<tr class="separator:a21cebe3dd7502b5d2e14659b770937b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de8e64303b89c2603f21f1040de71b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6">setInitialPositionLLA</a> (const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;lla)</td></tr>
<tr class="memdesc:a2de8e64303b89c2603f21f1040de71b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>.  <a href="#a2de8e64303b89c2603f21f1040de71b6">More...</a><br /></td></tr>
<tr class="separator:a2de8e64303b89c2603f21f1040de71b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ff33cc1b85f1c3d0fa3cc74416ad79"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_time_info.html">XsTimeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a09ff33cc1b85f1c3d0fa3cc74416ad79">utcTime</a> () const </td></tr>
<tr class="memdesc:a09ff33cc1b85f1c3d0fa3cc74416ad79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the 'UTC Time' setting of the device.  <a href="#a09ff33cc1b85f1c3d0fa3cc74416ad79">More...</a><br /></td></tr>
<tr class="separator:a09ff33cc1b85f1c3d0fa3cc74416ad79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96019db07120f4c50b7d50fda4201a0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af96019db07120f4c50b7d50fda4201a0">setUtcTime</a> (const <a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> &amp;time)</td></tr>
<tr class="memdesc:af96019db07120f4c50b7d50fda4201a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'UTC Time' setting of the device to the given <em>time</em>.  <a href="#af96019db07120f4c50b7d50fda4201a0">More...</a><br /></td></tr>
<tr class="separator:af96019db07120f4c50b7d50fda4201a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac561b31a844e7218acbe2de34ca49327"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac561b31a844e7218acbe2de34ca49327">reinitialize</a> ()</td></tr>
<tr class="memdesc:ac561b31a844e7218acbe2de34ca49327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>.  <a href="#ac561b31a844e7218acbe2de34ca49327">More...</a><br /></td></tr>
<tr class="separator:ac561b31a844e7218acbe2de34ca49327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c603076bee2eb69133b3b3f80cfb992"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8c603076bee2eb69133b3b3f80cfb992">xdaFilterProfile</a> () const </td></tr>
<tr class="memdesc:a8c603076bee2eb69133b3b3f80cfb992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use for computing orientations on the host PC.  <a href="#a8c603076bee2eb69133b3b3f80cfb992">More...</a><br /></td></tr>
<tr class="separator:a8c603076bee2eb69133b3b3f80cfb992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d32dca25c36ce8a6a65fa8767b8049"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049">setXdaFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:a89d32dca25c36ce8a6a65fa8767b8049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.  <a href="#a89d32dca25c36ce8a6a65fa8767b8049">More...</a><br /></td></tr>
<tr class="separator:a89d32dca25c36ce8a6a65fa8767b8049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af486a505331ac8558052492df27be229"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af486a505331ac8558052492df27be229">setXdaFilterProfile</a> (<a class="el" href="struct_xs_string.html">XsString</a> const &amp;profileType)</td></tr>
<tr class="memdesc:af486a505331ac8558052492df27be229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the host PC.  <a href="#af486a505331ac8558052492df27be229">More...</a><br /></td></tr>
<tr class="separator:af486a505331ac8558052492df27be229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aeb16cfa3b49bfe70a399e0cee27b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a96aeb16cfa3b49bfe70a399e0cee27b2">onboardFilterProfile</a> () const </td></tr>
<tr class="memdesc:a96aeb16cfa3b49bfe70a399e0cee27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the filter profile in use by the device for computing orientations.  <a href="#a96aeb16cfa3b49bfe70a399e0cee27b2">More...</a><br /></td></tr>
<tr class="separator:a96aeb16cfa3b49bfe70a399e0cee27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf">setOnboardFilterProfile</a> (int profileType)</td></tr>
<tr class="memdesc:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.  <a href="#a104c62ce2ddaaef1d82bb68fb8e83ddf">More...</a><br /></td></tr>
<tr class="separator:a104c62ce2ddaaef1d82bb68fb8e83ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f841c8f72d8db684efe0a877625311d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3f841c8f72d8db684efe0a877625311d">setOnboardFilterProfile</a> (<a class="el" href="struct_xs_string.html">XsString</a> const &amp;profileType)</td></tr>
<tr class="memdesc:a3f841c8f72d8db684efe0a877625311d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filter profile to use for computing orientations on the device.  <a href="#a3f841c8f72d8db684efe0a877625311d">More...</a><br /></td></tr>
<tr class="separator:a3f841c8f72d8db684efe0a877625311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a151cf5447c242dd8945b6b51e3b3cb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1a151cf5447c242dd8945b6b51e3b3cb">replaceFilterProfile</a> (<a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> const &amp;profileCurrent, <a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> const &amp;profileNew)</td></tr>
<tr class="memdesc:a1a151cf5447c242dd8945b6b51e3b3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces profileCurrent by profileNew in the device.  <a href="#a1a151cf5447c242dd8945b6b51e3b3cb">More...</a><br /></td></tr>
<tr class="separator:a1a151cf5447c242dd8945b6b51e3b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6493f27ff1ce3af653e2c61eec8c0bc3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3">availableOnboardFilterProfiles</a> () const </td></tr>
<tr class="memdesc:a6493f27ff1ce3af653e2c61eec8c0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the device.  <a href="#a6493f27ff1ce3af653e2c61eec8c0bc3">More...</a><br /></td></tr>
<tr class="separator:a6493f27ff1ce3af653e2c61eec8c0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb69ce9c16cd3167a5dfa41b4a26c74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74">availableXdaFilterProfiles</a> () const </td></tr>
<tr class="memdesc:a5eb69ce9c16cd3167a5dfa41b4a26c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of filter profiles available on the host PC.  <a href="#a5eb69ce9c16cd3167a5dfa41b4a26c74">More...</a><br /></td></tr>
<tr class="separator:a5eb69ce9c16cd3167a5dfa41b4a26c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57669117e40f883f3fb0c30b8aa0ef20"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a57669117e40f883f3fb0c30b8aa0ef20">accelerometerRange</a> () const </td></tr>
<tr class="memdesc:a57669117e40f883f3fb0c30b8aa0ef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the accelerometers in the device.  <a href="#a57669117e40f883f3fb0c30b8aa0ef20">More...</a><br /></td></tr>
<tr class="separator:a57669117e40f883f3fb0c30b8aa0ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c423ff06e9f63bc05cdc38e6ee3f50"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a38c423ff06e9f63bc05cdc38e6ee3f50">gyroscopeRange</a> () const </td></tr>
<tr class="memdesc:a38c423ff06e9f63bc05cdc38e6ee3f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum official value of the gyroscopes in the device.  <a href="#a38c423ff06e9f63bc05cdc38e6ee3f50">More...</a><br /></td></tr>
<tr class="separator:a38c423ff06e9f63bc05cdc38e6ee3f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3340a175cded1e16f4e5c87e7a6709"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709">setNoRotation</a> (uint16_t duration)</td></tr>
<tr class="memdesc:adf3340a175cded1e16f4e5c87e7a6709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the no rotation period to <em>duration</em>.  <a href="#adf3340a175cded1e16f4e5c87e7a6709">More...</a><br /></td></tr>
<tr class="separator:adf3340a175cded1e16f4e5c87e7a6709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce91e11ff069c678fe753242337d9a2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afce91e11ff069c678fe753242337d9a2">startRepresentativeMotion</a> ()</td></tr>
<tr class="memdesc:afce91e11ff069c678fe753242337d9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the user indicate that he is starting the representative motion for the In-Run Compass Calibration.  <a href="#afce91e11ff069c678fe753242337d9a2">More...</a><br /></td></tr>
<tr class="separator:afce91e11ff069c678fe753242337d9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9027bea531e3c9de9b539e0c4e17e038"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9027bea531e3c9de9b539e0c4e17e038">representativeMotionState</a> ()</td></tr>
<tr class="memdesc:a9027bea531e3c9de9b539e0c4e17e038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the active representative motion state for the In-Run Compass Calibration.  <a href="#a9027bea531e3c9de9b539e0c4e17e038">More...</a><br /></td></tr>
<tr class="separator:a9027bea531e3c9de9b539e0c4e17e038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ceb6c84eaffdbddb15eb8bf80a3e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_icc_rep_motion_result.html">XsIccRepMotionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a132ceb6c84eaffdbddb15eb8bf80a3e7">stopRepresentativeMotion</a> ()</td></tr>
<tr class="memdesc:a132ceb6c84eaffdbddb15eb8bf80a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let the user indicate that he stopped the representative motion.  <a href="#a132ceb6c84eaffdbddb15eb8bf80a3e7">More...</a><br /></td></tr>
<tr class="separator:a132ceb6c84eaffdbddb15eb8bf80a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94fd4b0efaead71ac1c8ab31869237b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad94fd4b0efaead71ac1c8ab31869237b">storeIccResults</a> ()</td></tr>
<tr class="memdesc:ad94fd4b0efaead71ac1c8ab31869237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the onboard ICC results for use by the device.  <a href="#ad94fd4b0efaead71ac1c8ab31869237b">More...</a><br /></td></tr>
<tr class="separator:ad94fd4b0efaead71ac1c8ab31869237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa892ee2ed423e6ef98e7a8854af07534"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa892ee2ed423e6ef98e7a8854af07534">rs485TransmissionDelay</a> () const </td></tr>
<tr class="memdesc:aa892ee2ed423e6ef98e7a8854af07534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transmission delay used for RS485 transmissions.  <a href="#aa892ee2ed423e6ef98e7a8854af07534">More...</a><br /></td></tr>
<tr class="separator:aa892ee2ed423e6ef98e7a8854af07534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba7004a5136186128bc156db997a359"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5ba7004a5136186128bc156db997a359">setRs485TransmissionDelay</a> (uint16_t delay)</td></tr>
<tr class="memdesc:a5ba7004a5136186128bc156db997a359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transmission delay used for RS485 transmissions.  <a href="#a5ba7004a5136186128bc156db997a359">More...</a><br /></td></tr>
<tr class="separator:a5ba7004a5136186128bc156db997a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9249cc91fbabf54d6424c151745c6f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af9249cc91fbabf54d6424c151745c6f6">runSelfTest</a> ()</td></tr>
<tr class="memdesc:af9249cc91fbabf54d6424c151745c6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the self test for the device.  <a href="#af9249cc91fbabf54d6424c151745c6f6">More...</a><br /></td></tr>
<tr class="separator:af9249cc91fbabf54d6424c151745c6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d00b7e36b3c792704795723af23fe9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae1d00b7e36b3c792704795723af23fe9">requestData</a> ()</td></tr>
<tr class="memdesc:ae1d00b7e36b3c792704795723af23fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request data when configured in legacy mode with infinite skip factor.  <a href="#ae1d00b7e36b3c792704795723af23fe9">More...</a><br /></td></tr>
<tr class="separator:ae1d00b7e36b3c792704795723af23fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12785a3723d2b6d3be3eb096da4fddae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a12785a3723d2b6d3be3eb096da4fddae">storeFilterState</a> ()</td></tr>
<tr class="memdesc:a12785a3723d2b6d3be3eb096da4fddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store orientation filter state in the device.  <a href="#a12785a3723d2b6d3be3eb096da4fddae">More...</a><br /></td></tr>
<tr class="separator:a12785a3723d2b6d3be3eb096da4fddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa17e702e833730b5bcbcb1b541d5f1c3">getDataPacketByIndex</a> (XsSize index) const </td></tr>
<tr class="memdesc:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cached data packet with <em>index</em>.  <a href="#aa17e702e833730b5bcbcb1b541d5f1c3">More...</a><br /></td></tr>
<tr class="separator:aa17e702e833730b5bcbcb1b541d5f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14ab746e9f11161276bed512b994132"><td class="memItemLeft" align="right" valign="top">XsSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae14ab746e9f11161276bed512b994132">getDataPacketCount</a> () const </td></tr>
<tr class="memdesc:ae14ab746e9f11161276bed512b994132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current size of the retained data packet cache.  <a href="#ae14ab746e9f11161276bed512b994132">More...</a><br /></td></tr>
<tr class="separator:ae14ab746e9f11161276bed512b994132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35579cec2bccb5b3d98886539759adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af35579cec2bccb5b3d98886539759adc">lastAvailableLiveData</a> () const </td></tr>
<tr class="memdesc:af35579cec2bccb5b3d98886539759adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last available live data.  <a href="#af35579cec2bccb5b3d98886539759adc">More...</a><br /></td></tr>
<tr class="separator:af35579cec2bccb5b3d98886539759adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15da55406b99b9ed395ea919db1c008b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a15da55406b99b9ed395ea919db1c008b">takeFirstDataPacketInQueue</a> ()</td></tr>
<tr class="memdesc:a15da55406b99b9ed395ea919db1c008b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first packet in the packet queue or an empty packet if the queue is empty.  <a href="#a15da55406b99b9ed395ea919db1c008b">More...</a><br /></td></tr>
<tr class="separator:a15da55406b99b9ed395ea919db1c008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee452722dcd4859fd9e9c241cf3af06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#abee452722dcd4859fd9e9c241cf3af06">isInitialBiasUpdateEnabled</a> () const </td></tr>
<tr class="memdesc:abee452722dcd4859fd9e9c241cf3af06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#abee452722dcd4859fd9e9c241cf3af06">More...</a><br /></td></tr>
<tr class="separator:abee452722dcd4859fd9e9c241cf3af06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c10338c003a5f69bb5968583809de96"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96">setInitialBiasUpdateEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a9c10338c003a5f69bb5968583809de96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the device does gyroscope bias estimation when switching to measurement mode.  <a href="#a9c10338c003a5f69bb5968583809de96">More...</a><br /></td></tr>
<tr class="separator:a9c10338c003a5f69bb5968583809de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6647738e04ad072e94a91cbe544990"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#afc6647738e04ad072e94a91cbe544990">isFixedGravityEnabled</a> () const </td></tr>
<tr class="memdesc:afc6647738e04ad072e94a91cbe544990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the fixed gravity value should be used or if it should be computed from the initialPositionLLA value.  <a href="#afc6647738e04ad072e94a91cbe544990">More...</a><br /></td></tr>
<tr class="separator:afc6647738e04ad072e94a91cbe544990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5b98429d0b592a3395fb853619e8a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0d5b98429d0b592a3395fb853619e8a7">setFixedGravityEnabled</a> (bool enable)</td></tr>
<tr class="memdesc:a0d5b98429d0b592a3395fb853619e8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the fixed gravity value should be used or if it should be computed from the initialPositionLLA value.  <a href="#a0d5b98429d0b592a3395fb853619e8a7">More...</a><br /></td></tr>
<tr class="separator:a0d5b98429d0b592a3395fb853619e8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aea7017d2579fee0b04243ad7a1a16"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac6aea7017d2579fee0b04243ad7a1a16">createConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:ac6aea7017d2579fee0b04243ad7a1a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the current device configuration in a config file(.xsa)  <a href="#ac6aea7017d2579fee0b04243ad7a1a16">More...</a><br /></td></tr>
<tr class="separator:ac6aea7017d2579fee0b04243ad7a1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a08ea246d7c10a63c5d6c4cebb32a4eb5">applyConfigFile</a> (const <a class="el" href="struct_xs_string.html">XsString</a> &amp;filename)</td></tr>
<tr class="memdesc:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a config file(.xsa) and configures the device accordingly.  <a href="#a08ea246d7c10a63c5d6c4cebb32a4eb5">More...</a><br /></td></tr>
<tr class="separator:a08ea246d7c10a63c5d6c4cebb32a4eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ae39415f88e591be84e34f659d887c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c">setAlignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;matrix)</td></tr>
<tr class="memdesc:aa5ae39415f88e591be84e34f659d887c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L' or S to the chosen frame S'.  <a href="#aa5ae39415f88e591be84e34f659d887c">More...</a><br /></td></tr>
<tr class="separator:aa5ae39415f88e591be84e34f659d887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_matrix.html">XsMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d">alignmentRotationMatrix</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation matrix to rotate S to the chosen frame S'.  <a href="#a32aefeb3bcf3a82a8e6c2e1281283a1d">More...</a><br /></td></tr>
<tr class="separator:a32aefeb3bcf3a82a8e6c2e1281283a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa">setAlignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame, const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;quat)</td></tr>
<tr class="memdesc:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L' or S to the chosen frame S'.  <a href="#a5c5ba2ab3c1a316f6142d2383c472daa">More...</a><br /></td></tr>
<tr class="separator:a5c5ba2ab3c1a316f6142d2383c472daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4159ae056441f563d06e4d94450f61e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e">alignmentRotationQuaternion</a> (<a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a> frame) const </td></tr>
<tr class="memdesc:ae4159ae056441f563d06e4d94450f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the alignment rotation quaternion.  <a href="#ae4159ae056441f563d06e4d94450f61e">More...</a><br /></td></tr>
<tr class="separator:ae4159ae056441f563d06e4d94450f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b1499a3e5db22d0bac40cc5daf25ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxsens_1_1_guarded_mutex.html">xsens::GuardedMutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a95b1499a3e5db22d0bac40cc5daf25ef">mutex</a> () const </td></tr>
<tr class="separator:a95b1499a3e5db22d0bac40cc5daf25ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a7a98d741d407f20d71e43ea87ba86"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a80a7a98d741d407f20d71e43ea87ba86">deviceIsDocked</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) const </td></tr>
<tr class="memdesc:a80a7a98d741d407f20d71e43ea87ba86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the device is docked.  <a href="#a80a7a98d741d407f20d71e43ea87ba86">More...</a><br /></td></tr>
<tr class="separator:a80a7a98d741d407f20d71e43ea87ba86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cee213873a1d513d14e795a7ce178b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a62cee213873a1d513d14e795a7ce178b">isLoadLogFileInProgress</a> () const </td></tr>
<tr class="memdesc:a62cee213873a1d513d14e795a7ce178b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file operation started by loadLogFile is still in progress.  <a href="#a62cee213873a1d513d14e795a7ce178b">More...</a><br /></td></tr>
<tr class="separator:a62cee213873a1d513d14e795a7ce178b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6d9626773e736aa2b0224859baa3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aff6d9626773e736aa2b0224859baa3ce">waitForLoadLogFileDone</a> () const </td></tr>
<tr class="memdesc:aff6d9626773e736aa2b0224859baa3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the file operation started by loadLogFile to complete.  <a href="#aff6d9626773e736aa2b0224859baa3ce">More...</a><br /></td></tr>
<tr class="separator:aff6d9626773e736aa2b0224859baa3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf49569bea925b19ca034ce7771567"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af0bf49569bea925b19ca034ce7771567">supportedStatusFlags</a> () const </td></tr>
<tr class="memdesc:af0bf49569bea925b19ca034ce7771567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask with all the status flags supported by this device.  <a href="#af0bf49569bea925b19ca034ce7771567">More...</a><br /></td></tr>
<tr class="separator:af0bf49569bea925b19ca034ce7771567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_callback_manager_xda"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_callback_manager_xda')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a></td></tr>
<tr class="memitem:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1409c965b88efc664a2ef7d36e5490f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a1409c965b88efc664a2ef7d36e5490f4">onDeviceStateChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState) override</td></tr>
<tr class="memdesc:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga24d179eecbcde2ca2f3206cb6f7c05f0" title="Called when a device&#39;s state has changed (ie config mode, measurement mode, recording mode) ...">XsCallback::onDeviceStateChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a1409c965b88efc664a2ef7d36e5490f4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebd995bd1dc83e69822f874eabb0c4fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aebd995bd1dc83e69822f874eabb0c4fa">onLiveDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet) override</td></tr>
<tr class="memdesc:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaf94a5a76c3a443255fc53f7a2bf9e076" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:aebd995bd1dc83e69822f874eabb0c4fa inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e64d70ce299958605b6149049e045ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5e64d70ce299958605b6149049e045ef">onAllLiveDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga4e7bf7c16f2f8bf70da7150f8a68ac95" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllLiveDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5e64d70ce299958605b6149049e045ef inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79ae15c19c791af165c842441993660c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a79ae15c19c791af165c842441993660c">onMissedPackets</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last) override</td></tr>
<tr class="memdesc:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga32f20ce601f007ba4e571e40a4f8f71e" title="Called when XDA detects that packets have been missed. ">XsCallback::onMissedPackets()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a79ae15c19c791af165c842441993660c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7738059783802ad5e1278108a467ccc2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7738059783802ad5e1278108a467ccc2">onDataUnavailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId) override</td></tr>
<tr class="memdesc:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga89d308afd509c0325b4cdb622fd9e645" title="Called when XDA detects that data is forever unavailable. ">XsCallback::onDataUnavailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7738059783802ad5e1278108a467ccc2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7471f499ee52bb189ef4e3917a20e5d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a7471f499ee52bb189ef4e3917a20e5d0">onWakeupReceived</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev) override</td></tr>
<tr class="memdesc:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gac8d7f94d6cb77f5fe56effaa36752e4a" title="Called when a wakeup message has been received from a device. This indicates that the device has just...">XsCallback::onWakeupReceived()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a7471f499ee52bb189ef4e3917a20e5d0 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840ce749572d8997e33ee8f860db97c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7">onProgressUpdated</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const <a class="el" href="struct_xs_string.html">XsString</a> *identifier) override</td></tr>
<tr class="memdesc:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga70ff4796b9bb5e3d79eac2c7cd870e59" title="Called when a long-duration operation has made some progress or has completed. Examples include loadL...">XsCallback::onProgressUpdated()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a840ce749572d8997e33ee8f860db97c7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad510877b529df7a85fbc5d601c2fad76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad510877b529df7a85fbc5d601c2fad76">onWriteMessageToLogFile</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> *message) override</td></tr>
<tr class="memdesc:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga5d34298b034dda9f344f3eb9fc132290" title="Called when XDA has a message that could be written to a log file. ">XsCallback::onWriteMessageToLogFile()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad510877b529df7a85fbc5d601c2fad76 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c8eb08edd64025b3e9405415b38834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad4c8eb08edd64025b3e9405415b38834">onBufferedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga397146fde21cd36a801206e9b73d8399" title="Called when XDA has a data packet that could be written to a log file. ">XsCallback::onBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:ad4c8eb08edd64025b3e9405415b38834 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2827956387a56712723e9200882179c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2827956387a56712723e9200882179c">onAllBufferedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga270ee8957dac53bdf04aee0ba40b3c03" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllBufferedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:af2827956387a56712723e9200882179c inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312575546ab44f788dd3961477ba0e7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a312575546ab44f788dd3961477ba0e7f">onConnectivityChanged</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState) override</td></tr>
<tr class="memdesc:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gacad6280b5dc0c8e458b22e26a50bad40" title="Called when XDA has detected a change in the connectivity state of a device. ">XsCallback::onConnectivityChanged()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a312575546ab44f788dd3961477ba0e7f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01afaba0ea9f47b5c4f490ee7dba7364"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364">onInfoResponse</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request) override</td></tr>
<tr class="memdesc:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga224586f8f7e0e9f0b57091b7d9a24bc5" title="Called when an information request has resulted in a response. ">XsCallback::onInfoResponse()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a01afaba0ea9f47b5c4f490ee7dba7364 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a65ae9866cb7a9e8ab11dcfeca1572f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3a65ae9866cb7a9e8ab11dcfeca1572f">onError</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error) override</td></tr>
<tr class="memdesc:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onError() callback forwarding function. <br /></td></tr>
<tr class="separator:a3a65ae9866cb7a9e8ab11dcfeca1572f inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdeff1e1697266d82f232642aef0cae9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#afdeff1e1697266d82f232642aef0cae9">onNonDataMessage</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onNonDataMessage() callback forwarding function. <br /></td></tr>
<tr class="separator:afdeff1e1697266d82f232642aef0cae9 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af81b39fa94f8086d9682df2e53ea5e1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af81b39fa94f8086d9682df2e53ea5e1e">onMessageDetected</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage) override</td></tr>
<tr class="memdesc:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:af81b39fa94f8086d9682df2e53ea5e1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a760e93d7f7142fd22c7e134c4cea5f72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a760e93d7f7142fd22c7e134c4cea5f72">onMessageReceivedFromDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageReceivedFromDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a760e93d7f7142fd22c7e134c4cea5f72 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ec10bd8e7cf2df6b4136ad0ac9701e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a73ec10bd8e7cf2df6b4136ad0ac9701e">onMessageSentToDevice</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="struct_xs_message.html">XsMessage</a> const *message) override</td></tr>
<tr class="memdesc:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onMessageSentToDevice() callback forwarding function. <br /></td></tr>
<tr class="separator:a73ec10bd8e7cf2df6b4136ad0ac9701e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc815adc25af17f24207573afa9c94da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acc815adc25af17f24207573afa9c94da">onDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga9a65730e9aa35fe9c52c92807741f088" title="Called when new data has been received from a device or read from a file. When processing on PC is en...">XsCallback::onDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:acc815adc25af17f24207573afa9c94da inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f103ff688afdeef381eedd6100331d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5f103ff688afdeef381eedd6100331d2">onAllDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#gaeb4e17817075f23aa461ecf92bb997ba" title="Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output. ">XsCallback::onAllDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5f103ff688afdeef381eedd6100331d2 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6beccc0e4760b652b7be01e859e465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5b6beccc0e4760b652b7be01e859e465">onRecordedDataAvailable</a> (<a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *data) override</td></tr>
<tr class="memdesc:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga882b4ffadbc4ac28c78a9763de623c14" title="Called when new data has been received from a device in a recording state or read from a file...">XsCallback::onRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a5b6beccc0e4760b652b7be01e859e465 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c0aa7e3be74595cef490b98d1520d1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a4c0aa7e3be74595cef490b98d1520d1e">onAllRecordedDataAvailable</a> (<a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets) override</td></tr>
<tr class="memdesc:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___callbacks.html#ga6c054ebc03662aa3bc88d36916d8d3f6" title="Called when new data has been received for devices connected to the same main device in a recording s...">XsCallback::onAllRecordedDataAvailable()</a> callback forwarding function. <br /></td></tr>
<tr class="separator:a4c0aa7e3be74595cef490b98d1520d1e inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a503e4e781f975b8591f344c14dc6b764">onTransmissionRequest</a> (int channelId, const <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data) override</td></tr>
<tr class="memdesc:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="#a503e4e781f975b8591f344c14dc6b764">More...</a><br /></td></tr>
<tr class="separator:a503e4e781f975b8591f344c14dc6b764 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91bb23b63beb62d085182044abb30a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af91bb23b63beb62d085182044abb30a7">onRestoreCommunication</a> (const <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result) override</td></tr>
<tr class="memdesc:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Xscallback::onRestoreCommunication callback forwarding function. <br /></td></tr>
<tr class="separator:af91bb23b63beb62d085182044abb30a7 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae286810bd0b4d20678987b354fa13d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ae286810bd0b4d20678987b354fa13d29">CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initializes the callback list. <br /></td></tr>
<tr class="separator:ae286810bd0b4d20678987b354fa13d29 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5910d161433653494a59986643233cf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a5910d161433653494a59986643233cf6">~CallbackManagerXda</a> ()</td></tr>
<tr class="memdesc:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, clears the callback list. <br /></td></tr>
<tr class="separator:a5910d161433653494a59986643233cf6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ac213910a49d4e0ccb2f64d3e25f7e1d4">clearCallbackHandlers</a> (bool chain=true)</td></tr>
<tr class="memdesc:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the callback list.  <a href="#ac213910a49d4e0ccb2f64d3e25f7e1d4">More...</a><br /></td></tr>
<tr class="separator:ac213910a49d4e0ccb2f64d3e25f7e1d4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#af2bc14879f1dad8db57a3cf9e2f61940">addCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a handler to the list.  <a href="#af2bc14879f1dad8db57a3cf9e2f61940">More...</a><br /></td></tr>
<tr class="separator:af2bc14879f1dad8db57a3cf9e2f61940 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#adeb706dafbcbd6a92f2a475814d18d89">removeCallbackHandler</a> (<a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *cb, bool chain=true)</td></tr>
<tr class="memdesc:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a handler from the list.  <a href="#adeb706dafbcbd6a92f2a475814d18d89">More...</a><br /></td></tr>
<tr class="separator:adeb706dafbcbd6a92f2a475814d18d89 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7c60244a13f84ca7cc06efa50d9685"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#acb7c60244a13f84ca7cc06efa50d9685">clearChainedManagers</a> ()</td></tr>
<tr class="memdesc:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the chained manager list. <br /></td></tr>
<tr class="separator:acb7c60244a13f84ca7cc06efa50d9685 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#ad333b769cce921ccc725f1f9a6151ef6">addChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a chained manager to the list.  <a href="#ad333b769cce921ccc725f1f9a6151ef6">More...</a><br /></td></tr>
<tr class="separator:ad333b769cce921ccc725f1f9a6151ef6 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a41d22397b46a96de6b3a6a131fd296ed">removeChainedManager</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm)</td></tr>
<tr class="memdesc:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove achained manager from the list.  <a href="#a41d22397b46a96de6b3a6a131fd296ed">More...</a><br /></td></tr>
<tr class="separator:a41d22397b46a96de6b3a6a131fd296ed inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a790347a9b6b752b9d0945ba1d956bbc1">copyCallbackHandlersTo</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from this manager into <em>cm</em>.  <a href="#a790347a9b6b752b9d0945ba1d956bbc1">More...</a><br /></td></tr>
<tr class="separator:a790347a9b6b752b9d0945ba1d956bbc1 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#aaa87742f16fbdb230eaf79cc5ade5bb4">copyCallbackHandlersFrom</a> (<a class="el" href="class_callback_manager_xda.html">CallbackManagerXda</a> *cm, bool chain=true)</td></tr>
<tr class="memdesc:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all handlers from <em>cm</em> into this manager.  <a href="#aaa87742f16fbdb230eaf79cc5ade5bb4">More...</a><br /></td></tr>
<tr class="separator:aaa87742f16fbdb230eaf79cc5ade5bb4 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3649aca54d1c3e0879b6ccf5dfd5d554 inherit pub_methods_class_callback_manager_xda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_callback_manager_xda.html#a3649aca54d1c3e0879b6ccf5dfd5d554">haveCallback</a> (size_t functionOffset) const </td></tr>
<tr class="separator:a3649aca54d1c3e0879b6ccf5dfd5d554 inherit pub_methods_class_callback_manager_xda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_xs_callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_xs_callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_xs_callback.html">XsCallback</a></td></tr>
<tr class="memitem:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a491695016a32d02a31e2f4bda826ef47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a491695016a32d02a31e2f4bda826ef47">XsCallback</a> ()</td></tr>
<tr class="memdesc:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a491695016a32d02a31e2f4bda826ef47 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_xs_callback.html#a5c30ab32ed0e8ffc398672117afdd758">~XsCallback</a> ()</td></tr>
<tr class="memdesc:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5c30ab32ed0e8ffc398672117afdd758">More...</a><br /></td></tr>
<tr class="separator:a5c30ab32ed0e8ffc398672117afdd758 inherit pub_methods_class_xs_callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a09f36dfad04f941d4d4b8801bec0a8d8">supportsSyncSettings</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="memdesc:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the device specified by <em>deviceId</em> supports sync settings.  <a href="#a09f36dfad04f941d4d4b8801bec0a8d8">More...</a><br /></td></tr>
<tr class="separator:a09f36dfad04f941d4d4b8801bec0a8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b9c768227f0520112b8b30d189bda3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a95b9c768227f0520112b8b30d189bda3">isCompatibleSyncSetting</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>, <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> const &amp;setting1, <a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> const &amp;setting2)</td></tr>
<tr class="memdesc:a95b9c768227f0520112b8b30d189bda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em>.  <a href="#a95b9c768227f0520112b8b30d189bda3">More...</a><br /></td></tr>
<tr class="separator:a95b9c768227f0520112b8b30d189bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fc99f3e32921b758ead95141ccff1"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a179fc99f3e32921b758ead95141ccff1">syncSettingsTimeResolutionInMicroSeconds</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="separator:a179fc99f3e32921b758ead95141ccff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234b88d2f9cb339be3afcc22547d6ec8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a234b88d2f9cb339be3afcc22547d6ec8">supportedSyncSettings</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> <a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="memdesc:a234b88d2f9cb339be3afcc22547d6ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the supported synchronization settings for a specified <em>deviceId</em> or deviceId mask.  <a href="#a234b88d2f9cb339be3afcc22547d6ec8">More...</a><br /></td></tr>
<tr class="separator:a234b88d2f9cb339be3afcc22547d6ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a88f36d6851314d95124b1f9f02616368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f36d6851314d95124b1f9f02616368"></a>
virtual <a class="el" href="struct_xs_device.html">XsDevice</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a88f36d6851314d95124b1f9f02616368">firstChild</a> () const </td></tr>
<tr class="memdesc:a88f36d6851314d95124b1f9f02616368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child device (if any) of the master. If there are no children, it will return the master device itself. <br /></td></tr>
<tr class="separator:a88f36d6851314d95124b1f9f02616368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7616f6a4da026213f1d9f2207042a1c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7616f6a4da026213f1d9f2207042a1c6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7616f6a4da026213f1d9f2207042a1c6">setRecordingStartFrame</a> (uint16_t startFrame)</td></tr>
<tr class="memdesc:a7616f6a4da026213f1d9f2207042a1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frame at which the recording is actually started. <br /></td></tr>
<tr class="separator:a7616f6a4da026213f1d9f2207042a1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac411e47711b9ae04133c78d2ed87b7a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac411e47711b9ae04133c78d2ed87b7a4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac411e47711b9ae04133c78d2ed87b7a4">setRecordingStopFrame</a> (uint16_t stopFrame)</td></tr>
<tr class="memdesc:ac411e47711b9ae04133c78d2ed87b7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frame at which the recording is actually stopped. <br /></td></tr>
<tr class="separator:ac411e47711b9ae04133c78d2ed87b7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bde49e47b8e17dd2532503c7389923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a55bde49e47b8e17dd2532503c7389923">useLogInterface</a> (<a class="el" href="class_data_logger.html">DataLogger</a> *logger)</td></tr>
<tr class="memdesc:a55bde49e47b8e17dd2532503c7389923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses log interface for a given data logger.  <a href="#a55bde49e47b8e17dd2532503c7389923">More...</a><br /></td></tr>
<tr class="separator:a55bde49e47b8e17dd2532503c7389923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18207ff8660ea00f1ec85911904e0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac18207ff8660ea00f1ec85911904e0ed">setCommunicator</a> (<a class="el" href="struct_communicator.html">Communicator</a> *comm)</td></tr>
<tr class="memdesc:ac18207ff8660ea00f1ec85911904e0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a communicator for a device.  <a href="#ac18207ff8660ea00f1ec85911904e0ed">More...</a><br /></td></tr>
<tr class="separator:ac18207ff8660ea00f1ec85911904e0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295f6552ad3f15015a7a056e427f9d64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a295f6552ad3f15015a7a056e427f9d64">skipEmtsReadOnInit</a> () const </td></tr>
<tr class="separator:a295f6552ad3f15015a7a056e427f9d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8027cf8feb3ee2700b305cd5c02f8220"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8027cf8feb3ee2700b305cd5c02f8220">shouldDataMsgBeRecorded</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;msg) const </td></tr>
<tr class="separator:a8027cf8feb3ee2700b305cd5c02f8220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e861282110139d7bfd31b5873bf77f3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1e861282110139d7bfd31b5873bf77f3">shouldDoRecordedCallback</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;packet) const </td></tr>
<tr class="memdesc:a1e861282110139d7bfd31b5873bf77f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if it should do a recorded callback for a given <em>data</em> packet.  <a href="#a1e861282110139d7bfd31b5873bf77f3">More...</a><br /></td></tr>
<tr class="separator:a1e861282110139d7bfd31b5873bf77f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2533e270f6b6002f581847e15391da11"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2533e270f6b6002f581847e15391da11">interpolateMissingData</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;pack, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;prev, std::function&lt; void(<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)&gt; packetHandler)</td></tr>
<tr class="memdesc:a2533e270f6b6002f581847e15391da11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell XDA to interpolate missing items from <em>prev</em> to <em>pack</em>.  <a href="#a2533e270f6b6002f581847e15391da11">More...</a><br /></td></tr>
<tr class="separator:a2533e270f6b6002f581847e15391da11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34908acc4ab3813fa5499254b20ff28a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34908acc4ab3813fa5499254b20ff28a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a34908acc4ab3813fa5499254b20ff28a">clearExternalPacketCaches</a> ()</td></tr>
<tr class="memdesc:a34908acc4ab3813fa5499254b20ff28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the external packet cache. <br /></td></tr>
<tr class="separator:a34908acc4ab3813fa5499254b20ff28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e4fc647c7d85b14349c3b968b5266c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31e4fc647c7d85b14349c3b968b5266c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a31e4fc647c7d85b14349c3b968b5266c">updateLastAvailableLiveDataCache</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;pack)</td></tr>
<tr class="memdesc:a31e4fc647c7d85b14349c3b968b5266c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the supplied <em>pack</em> into m_lastAvailableLiveDataCache so its data is now available when calling <a class="el" href="struct_xs_device.html#af35579cec2bccb5b3d98886539759adc" title="Return the last available live data. ">lastAvailableLiveData()</a> <br /></td></tr>
<tr class="separator:a31e4fc647c7d85b14349c3b968b5266c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd27816a059d133198d710f3e590956"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9fd27816a059d133198d710f3e590956">retainPacket</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;pack)</td></tr>
<tr class="memdesc:a9fd27816a059d133198d710f3e590956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the supplied <em>pack</em> to the linear packet cache.  <a href="#a9fd27816a059d133198d710f3e590956">More...</a><br /></td></tr>
<tr class="separator:a9fd27816a059d133198d710f3e590956"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad09b51d500d1a383b01c22d85470baf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad09b51d500d1a383b01c22d85470baf7"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad09b51d500d1a383b01c22d85470baf7">checkDataEnabled</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType, <a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> const &amp;configurations)</td></tr>
<tr class="memdesc:ad09b51d500d1a383b01c22d85470baf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the supplied <em>configurations</em> contains <em>dataType</em>. <br /></td></tr>
<tr class="separator:ad09b51d500d1a383b01c22d85470baf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff18a7a7d8077ff17dc8404fd49ec6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ff18a7a7d8077ff17dc8404fd49ec6"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a41ff18a7a7d8077ff17dc8404fd49ec6">packetContainsRetransmission</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;pack)</td></tr>
<tr class="memdesc:a41ff18a7a7d8077ff17dc8404fd49ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the packet contains a retransmission or not. <br /></td></tr>
<tr class="separator:a41ff18a7a7d8077ff17dc8404fd49ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae724caa64e0e062380168a4cea03cd5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae724caa64e0e062380168a4cea03cd5a"></a>
<a class="el" href="classxsens_1_1_guarded_mutex.html">xsens::GuardedMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae724caa64e0e062380168a4cea03cd5a">m_deviceMutex</a></td></tr>
<tr class="memdesc:ae724caa64e0e062380168a4cea03cd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device mutex. <br /></td></tr>
<tr class="separator:ae724caa64e0e062380168a4cea03cd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45771b99d8c56d9f05b962354672175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab45771b99d8c56d9f05b962354672175"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab45771b99d8c56d9f05b962354672175">m_latestLivePacket</a></td></tr>
<tr class="memdesc:ab45771b99d8c56d9f05b962354672175"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of the latest ready live packet. This is the packet with the highest 64-bit sample counter so far. Use latestLivePacket() to access. <br /></td></tr>
<tr class="separator:ab45771b99d8c56d9f05b962354672175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae627e8e3d64e6f82444f96ab6fa10bcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae627e8e3d64e6f82444f96ab6fa10bcd"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae627e8e3d64e6f82444f96ab6fa10bcd">m_latestBufferedPacket</a></td></tr>
<tr class="memdesc:ae627e8e3d64e6f82444f96ab6fa10bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy of the latest ready recording packet. This is the last packet that was popped off the front of m_dataCache. Use latestBufferedPacket() to access. <br /></td></tr>
<tr class="separator:ae627e8e3d64e6f82444f96ab6fa10bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790becb416c07092c3c2e93fa0ac27b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1790becb416c07092c3c2e93fa0ac27b"></a>
<a class="el" href="class_data_packet_cache.html">DataPacketCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1790becb416c07092c3c2e93fa0ac27b">m_dataCache</a></td></tr>
<tr class="memdesc:a1790becb416c07092c3c2e93fa0ac27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data cache. <br /></td></tr>
<tr class="separator:a1790becb416c07092c3c2e93fa0ac27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624222d0f067bc0d8bf72de78c597408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a624222d0f067bc0d8bf72de78c597408"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a624222d0f067bc0d8bf72de78c597408">m_unavailableDataBoundary</a></td></tr>
<tr class="memdesc:a624222d0f067bc0d8bf72de78c597408"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet ID of the last sample we know to be unavailable. <br /></td></tr>
<tr class="separator:a624222d0f067bc0d8bf72de78c597408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea070e398c7b54ae1e6a28457ec7d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea070e398c7b54ae1e6a28457ec7d45"></a>
<a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a2ea070e398c7b54ae1e6a28457ec7d45">m_deviceId</a></td></tr>
<tr class="memdesc:a2ea070e398c7b54ae1e6a28457ec7d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ID of the device. <br /></td></tr>
<tr class="separator:a2ea070e398c7b54ae1e6a28457ec7d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45e8bcddcf960c7a47a9565c5a1151d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad45e8bcddcf960c7a47a9565c5a1151d"></a>
<a class="el" href="class_last_result_manager.html">LastResultManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad45e8bcddcf960c7a47a9565c5a1151d">m_lastResult</a></td></tr>
<tr class="memdesc:ad45e8bcddcf960c7a47a9565c5a1151d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last result of an operation. <br /></td></tr>
<tr class="separator:ad45e8bcddcf960c7a47a9565c5a1151d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d14ec228467543c7b6aed5fc05c3f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d14ec228467543c7b6aed5fc05c3f5"></a>
<a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a90d14ec228467543c7b6aed5fc05c3f5">m_state</a></td></tr>
<tr class="memdesc:a90d14ec228467543c7b6aed5fc05c3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A current device state. <br /></td></tr>
<tr class="separator:a90d14ec228467543c7b6aed5fc05c3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff1ae6c51b5b600eff3d24da6fa8b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ff1ae6c51b5b600eff3d24da6fa8b18"></a>
<a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a6ff1ae6c51b5b600eff3d24da6fa8b18">m_connectivity</a></td></tr>
<tr class="memdesc:a6ff1ae6c51b5b600eff3d24da6fa8b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">A current device connectivity state. <br /></td></tr>
<tr class="separator:a6ff1ae6c51b5b600eff3d24da6fa8b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10edfd42c6751f5798dbddcee45344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c10edfd42c6751f5798dbddcee45344"></a>
<a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0c10edfd42c6751f5798dbddcee45344">m_lastDataOkStamp</a></td></tr>
<tr class="memdesc:a0c10edfd42c6751f5798dbddcee45344"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time stamp for an OK last data. <br /></td></tr>
<tr class="separator:a0c10edfd42c6751f5798dbddcee45344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee24212ba33a0b0693c3c65f27eb8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adee24212ba33a0b0693c3c65f27eb8a0"></a>
<a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#adee24212ba33a0b0693c3c65f27eb8a0">m_config</a></td></tr>
<tr class="memdesc:adee24212ba33a0b0693c3c65f27eb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device configuration. <br /></td></tr>
<tr class="separator:adee24212ba33a0b0693c3c65f27eb8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab622a5af0f900c674b2ef494152c56d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab622a5af0f900c674b2ef494152c56d5"></a>
<a class="el" href="struct_xs_version.html">XsVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab622a5af0f900c674b2ef494152c56d5">m_firmwareVersion</a></td></tr>
<tr class="memdesc:ab622a5af0f900c674b2ef494152c56d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A firmware version. <br /></td></tr>
<tr class="separator:ab622a5af0f900c674b2ef494152c56d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08953e0289a913214412edb33b767739"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08953e0289a913214412edb33b767739"></a>
<a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a08953e0289a913214412edb33b767739">m_communicator</a></td></tr>
<tr class="memdesc:a08953e0289a913214412edb33b767739"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communicator. <br /></td></tr>
<tr class="separator:a08953e0289a913214412edb33b767739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551e8bba9e9bdca8c9cd381c3026e2fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a551e8bba9e9bdca8c9cd381c3026e2fb"></a>
<a class="el" href="class_data_logger.html">DataLogger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a551e8bba9e9bdca8c9cd381c3026e2fb">m_logFileInterface</a></td></tr>
<tr class="memdesc:a551e8bba9e9bdca8c9cd381c3026e2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data logger for a file interface. <br /></td></tr>
<tr class="separator:a551e8bba9e9bdca8c9cd381c3026e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49f0e2a3b6511ae5b30dab68077d853"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af49f0e2a3b6511ae5b30dab68077d853"></a>
<a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af49f0e2a3b6511ae5b30dab68077d853">m_master</a></td></tr>
<tr class="memdesc:af49f0e2a3b6511ae5b30dab68077d853"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device object. <br /></td></tr>
<tr class="separator:af49f0e2a3b6511ae5b30dab68077d853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3520465483155760672211418199fbff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3520465483155760672211418199fbff"></a>
volatile std::atomic_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3520465483155760672211418199fbff">m_refCounter</a></td></tr>
<tr class="memdesc:a3520465483155760672211418199fbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference counter. <br /></td></tr>
<tr class="separator:a3520465483155760672211418199fbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3a8480941852bad6587c71fb92452e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3a8480941852bad6587c71fb92452e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9d3a8480941852bad6587c71fb92452e">m_writeToFile</a></td></tr>
<tr class="memdesc:a9d3a8480941852bad6587c71fb92452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to file boolean variable. <br /></td></tr>
<tr class="separator:a9d3a8480941852bad6587c71fb92452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ee991b256611236c97121e841ac08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c2ee991b256611236c97121e841ac08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0c2ee991b256611236c97121e841ac08">m_isInitialized</a></td></tr>
<tr class="memdesc:a0c2ee991b256611236c97121e841ac08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is intialized boolean variable. <br /></td></tr>
<tr class="separator:a0c2ee991b256611236c97121e841ac08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436ff5acf205c80244d123a26c160445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a436ff5acf205c80244d123a26c160445"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a436ff5acf205c80244d123a26c160445">m_terminationPrepared</a></td></tr>
<tr class="memdesc:a436ff5acf205c80244d123a26c160445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Termination prepared boolean variable. <br /></td></tr>
<tr class="separator:a436ff5acf205c80244d123a26c160445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b528b8eebd52c7bf2e1ff2fedaf318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74b528b8eebd52c7bf2e1ff2fedaf318"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a74b528b8eebd52c7bf2e1ff2fedaf318">m_gotoConfigOnClose</a></td></tr>
<tr class="memdesc:a74b528b8eebd52c7bf2e1ff2fedaf318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go to confing on close boolean variable. <br /></td></tr>
<tr class="separator:a74b528b8eebd52c7bf2e1ff2fedaf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008271d6dd1730c63a5ef36289f5752c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008271d6dd1730c63a5ef36289f5752c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a008271d6dd1730c63a5ef36289f5752c">m_justWriteSetting</a></td></tr>
<tr class="memdesc:a008271d6dd1730c63a5ef36289f5752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just write setting boolean variable. <br /></td></tr>
<tr class="separator:a008271d6dd1730c63a5ef36289f5752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11620ad9af947d461879376add486a5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a11620ad9af947d461879376add486a5e">m_skipEmtsReadOnInit</a></td></tr>
<tr class="memdesc:a11620ad9af947d461879376add486a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip EMTS read on init boolean variable.  <a href="#a11620ad9af947d461879376add486a5e">More...</a><br /></td></tr>
<tr class="separator:a11620ad9af947d461879376add486a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f16d4a3938e0367035dd93dcd87cbd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f16d4a3938e0367035dd93dcd87cbd5"></a>
<a class="el" href="class_packet_stamper.html">PacketStamper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7f16d4a3938e0367035dd93dcd87cbd5">m_packetStamper</a></td></tr>
<tr class="memdesc:a7f16d4a3938e0367035dd93dcd87cbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet stamper. <br /></td></tr>
<tr class="separator:a7f16d4a3938e0367035dd93dcd87cbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee908301c63d37563e28450a79e38ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee908301c63d37563e28450a79e38ccf"></a>
<a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aee908301c63d37563e28450a79e38ccf">m_options</a></td></tr>
<tr class="memdesc:aee908301c63d37563e28450a79e38ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The options. <br /></td></tr>
<tr class="separator:aee908301c63d37563e28450a79e38ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252474853375985a7928f5368711d597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_xs_message.html">XsMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a252474853375985a7928f5368711d597">m_emtsBlob</a></td></tr>
<tr class="memdesc:a252474853375985a7928f5368711d597"><td class="mdescLeft">&#160;</td><td class="mdescRight">An EMTS blob from device.  <a href="#a252474853375985a7928f5368711d597">More...</a><br /></td></tr>
<tr class="separator:a252474853375985a7928f5368711d597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b20e598114a417b80a5f4acd1f2628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72b20e598114a417b80a5f4acd1f2628"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a72b20e598114a417b80a5f4acd1f2628">m_startRecordingPacketId</a></td></tr>
<tr class="memdesc:a72b20e598114a417b80a5f4acd1f2628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the first packet that should be / was recorded. <br /></td></tr>
<tr class="separator:a72b20e598114a417b80a5f4acd1f2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5e4be5f1cdd83977e07a668fbf39eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5e4be5f1cdd83977e07a668fbf39eb"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a7c5e4be5f1cdd83977e07a668fbf39eb">m_stopRecordingPacketId</a></td></tr>
<tr class="memdesc:a7c5e4be5f1cdd83977e07a668fbf39eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the last packet that should be / was recorded. Only valid in Recording/Flushing states. <br /></td></tr>
<tr class="separator:a7c5e4be5f1cdd83977e07a668fbf39eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c97cde412c42c2d43acab7327c99e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15c97cde412c42c2d43acab7327c99e"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa15c97cde412c42c2d43acab7327c99e">m_stoppedRecordingPacketId</a></td></tr>
<tr class="memdesc:aa15c97cde412c42c2d43acab7327c99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the last packet that was recorded. Remains valid after Flushing has ended, until a new recording is started. <br /></td></tr>
<tr class="separator:aa15c97cde412c42c2d43acab7327c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd614829b552769a4939627a26a582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7fd614829b552769a4939627a26a582"></a>
std::deque&lt; <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa7fd614829b552769a4939627a26a582">m_linearPacketCache</a></td></tr>
<tr class="memdesc:aa7fd614829b552769a4939627a26a582"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear data packet cache. <br /></td></tr>
<tr class="separator:aa7fd614829b552769a4939627a26a582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b9fb6221ee64a61d38102b4670a539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b9fb6221ee64a61d38102b4670a539"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a46b9fb6221ee64a61d38102b4670a539">m_lastAvailableLiveDataCache</a></td></tr>
<tr class="memdesc:a46b9fb6221ee64a61d38102b4670a539"><td class="mdescLeft">&#160;</td><td class="mdescRight">A last available live data cache. <br /></td></tr>
<tr class="separator:a46b9fb6221ee64a61d38102b4670a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ecadbae478a18b68d631f20411c2ad"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a81ecadbae478a18b68d631f20411c2ad">m_toaDumpFile</a></td></tr>
<tr class="memdesc:a81ecadbae478a18b68d631f20411c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">To a dump file.  <a href="#a81ecadbae478a18b68d631f20411c2ad">More...</a><br /></td></tr>
<tr class="separator:a81ecadbae478a18b68d631f20411c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a73aed4cdd1623582ab46672fc7011dbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73aed4cdd1623582ab46672fc7011dbb"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>XsDeviceEx</b></td></tr>
<tr class="separator:a73aed4cdd1623582ab46672fc7011dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dd75bdef68bf230219a51c823bc87e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92dd75bdef68bf230219a51c823bc87e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MtContainer</b></td></tr>
<tr class="separator:a92dd75bdef68bf230219a51c823bc87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0f60e6c3fea423b1fa2792816fab6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1a0f60e6c3fea423b1fa2792816fab6e">extractFirmwareVersion</a> (<a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;message)</td></tr>
<tr class="memdesc:a1a0f60e6c3fea423b1fa2792816fab6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the firmware version of the device.  <a href="#a1a0f60e6c3fea423b1fa2792816fab6e">More...</a><br /></td></tr>
<tr class="separator:a1a0f60e6c3fea423b1fa2792816fab6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4377d0013707a07acf5fdbeeee9a2b16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4377d0013707a07acf5fdbeeee9a2b16">setDeviceState</a> (<a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> state)</td></tr>
<tr class="memdesc:a4377d0013707a07acf5fdbeeee9a2b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device state for this device (triggering callbacks) and relay it to all children.  <a href="#a4377d0013707a07acf5fdbeeee9a2b16">More...</a><br /></td></tr>
<tr class="separator:a4377d0013707a07acf5fdbeeee9a2b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7762f2f17b301a3ceba7d342aef66f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a3e7762f2f17b301a3ceba7d342aef66f">updateDeviceState</a> (<a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> state)</td></tr>
<tr class="memdesc:a3e7762f2f17b301a3ceba7d342aef66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the device state immediately.  <a href="#a3e7762f2f17b301a3ceba7d342aef66f">More...</a><br /></td></tr>
<tr class="separator:a3e7762f2f17b301a3ceba7d342aef66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ae8f99640d46a6254d192d6b156b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ae8f99640d46a6254d192d6b156b79"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a03ae8f99640d46a6254d192d6b156b79">removeIfNoRefs</a> ()</td></tr>
<tr class="memdesc:a03ae8f99640d46a6254d192d6b156b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete itself when all references and child references are zero. <br /></td></tr>
<tr class="separator:a03ae8f99640d46a6254d192d6b156b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27681f5f546379457f07f8ff4b05dbb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a27681f5f546379457f07f8ff4b05dbb7">scheduleOrientationReset</a> (<a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a> method)</td></tr>
<tr class="memdesc:a27681f5f546379457f07f8ff4b05dbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the orientation reset.  <a href="#a27681f5f546379457f07f8ff4b05dbb7">More...</a><br /></td></tr>
<tr class="separator:a27681f5f546379457f07f8ff4b05dbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a1328bb55a80f57c70e8b54fe7628"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a451a1328bb55a80f57c70e8b54fe7628">XsDevice</a> (<a class="el" href="struct_xs_device_id.html">XsDeviceId</a> id)</td></tr>
<tr class="memdesc:a451a1328bb55a80f57c70e8b54fe7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty device with device id <em>id</em>.  <a href="#a451a1328bb55a80f57c70e8b54fe7628">More...</a><br /></td></tr>
<tr class="separator:a451a1328bb55a80f57c70e8b54fe7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fc0c07a5eeeb6dad0c8f5cf0e0d813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab6fc0c07a5eeeb6dad0c8f5cf0e0d813">XsDevice</a> (<a class="el" href="struct_communicator.html">Communicator</a> *comm)</td></tr>
<tr class="memdesc:ab6fc0c07a5eeeb6dad0c8f5cf0e0d813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device using <em>inf</em> for communication.  <a href="#ab6fc0c07a5eeeb6dad0c8f5cf0e0d813">More...</a><br /></td></tr>
<tr class="separator:ab6fc0c07a5eeeb6dad0c8f5cf0e0d813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f7e7e4070483dcbb5c792a045bace4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ac2f7e7e4070483dcbb5c792a045bace4">XsDevice</a> (MtContainer *<a class="el" href="struct_xs_device.html#add6706c445acd02d690ce8e4058d81bb">master</a>, const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;childDeviceId)</td></tr>
<tr class="memdesc:ac2f7e7e4070483dcbb5c792a045bace4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device with device id <em>childDeviceId</em> for master <em>masterDevice</em>.  <a href="#ac2f7e7e4070483dcbb5c792a045bace4">More...</a><br /></td></tr>
<tr class="separator:ac2f7e7e4070483dcbb5c792a045bace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7a55453e2fb37075bb6cae2922a88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd7a55453e2fb37075bb6cae2922a88"></a>
const <a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>deviceConfig</b> () const </td></tr>
<tr class="separator:addd7a55453e2fb37075bb6cae2922a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae908cc6aeb13077ddde16e61eb8cd153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae908cc6aeb13077ddde16e61eb8cd153"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae908cc6aeb13077ddde16e61eb8cd153">setDeviceId</a> (const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;<a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7">deviceId</a>)</td></tr>
<tr class="memdesc:ae908cc6aeb13077ddde16e61eb8cd153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device id of this device. <br /></td></tr>
<tr class="separator:ae908cc6aeb13077ddde16e61eb8cd153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82cd96eb88e28a1a89ed78133f13338"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af82cd96eb88e28a1a89ed78133f13338"></a>
<a class="el" href="struct_xs_output_configuration.html">XsOutputConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af82cd96eb88e28a1a89ed78133f13338">findConfiguration</a> (<a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a> dataType) const </td></tr>
<tr class="memdesc:af82cd96eb88e28a1a89ed78133f13338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the output configuration for <em>dataType</em>. <br /></td></tr>
<tr class="separator:af82cd96eb88e28a1a89ed78133f13338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a06379983378b09bfe4ef3a0a783f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57a06379983378b09bfe4ef3a0a783f0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a57a06379983378b09bfe4ef3a0a783f0">writeMessageToLogFile</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message)</td></tr>
<tr class="memdesc:a57a06379983378b09bfe4ef3a0a783f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a message in the log file if a log file is open. <br /></td></tr>
<tr class="separator:a57a06379983378b09bfe4ef3a0a783f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172ce5c8b3cd234614b00c161cd9113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0172ce5c8b3cd234614b00c161cd9113"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a0172ce5c8b3cd234614b00c161cd9113">writeFilterStateToFile</a> ()</td></tr>
<tr class="memdesc:a0172ce5c8b3cd234614b00c161cd9113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write filter states to file. <br /></td></tr>
<tr class="separator:a0172ce5c8b3cd234614b00c161cd9113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ea509bc854a2f112c1c0702e6f1be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4ea509bc854a2f112c1c0702e6f1be"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a9d4ea509bc854a2f112c1c0702e6f1be">processLivePacket</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> &amp;pack)</td></tr>
<tr class="memdesc:a9d4ea509bc854a2f112c1c0702e6f1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> (calibrate and filter) and put the results in the appropriate cache. <br /></td></tr>
<tr class="separator:a9d4ea509bc854a2f112c1c0702e6f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3d46d550b289143e111b42656e776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affb3d46d550b289143e111b42656e776"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#affb3d46d550b289143e111b42656e776">processBufferedPacket</a> (<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> &amp;pack)</td></tr>
<tr class="memdesc:affb3d46d550b289143e111b42656e776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> (calibrate and filter) and put the results in the appropriate cache. <br /></td></tr>
<tr class="separator:affb3d46d550b289143e111b42656e776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36395d8bb7d7c34a74c473511f375b0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a36395d8bb7d7c34a74c473511f375b0a">readDeviceConfiguration</a> ()</td></tr>
<tr class="memdesc:a36395d8bb7d7c34a74c473511f375b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the device configuration.  <a href="#a36395d8bb7d7c34a74c473511f375b0a">More...</a><br /></td></tr>
<tr class="separator:a36395d8bb7d7c34a74c473511f375b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b0a469a0ad1c75e9b962adbdda25d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6b0a469a0ad1c75e9b962adbdda25d2"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>latestLivePacket</b> ()</td></tr>
<tr class="separator:aa6b0a469a0ad1c75e9b962adbdda25d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4711cd19b77fb1866b5b461e31620ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4711cd19b77fb1866b5b461e31620ee"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>latestBufferedPacket</b> ()</td></tr>
<tr class="separator:ab4711cd19b77fb1866b5b461e31620ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da626b95933c1eb723d2a1c42bd4078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4da626b95933c1eb723d2a1c42bd4078"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>latestLivePacketConst</b> () const </td></tr>
<tr class="separator:a4da626b95933c1eb723d2a1c42bd4078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb8f7b3f12d2f2fd242108b229eebe7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb8f7b3f12d2f2fd242108b229eebe7"></a>
<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>latestBufferedPacketConst</b> () const </td></tr>
<tr class="separator:abdb8f7b3f12d2f2fd242108b229eebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a694abc89805f47de3a384789272c86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a694abc89805f47de3a384789272c86"></a>
virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>latestLivePacketId</b> () const </td></tr>
<tr class="separator:a0a694abc89805f47de3a384789272c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3283e7676efba3a7ccaa897d2b71e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e3283e7676efba3a7ccaa897d2b71e5"></a>
virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>latestBufferedPacketId</b> () const </td></tr>
<tr class="separator:a4e3283e7676efba3a7ccaa897d2b71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d72dca92f64270cc5337406f55f7c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a58d72dca92f64270cc5337406f55f7c1">resetPacketStamping</a> ()</td></tr>
<tr class="memdesc:a58d72dca92f64270cc5337406f55f7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset packet stamping by re-initializing the highestpacket.  <a href="#a58d72dca92f64270cc5337406f55f7c1">More...</a><br /></td></tr>
<tr class="separator:a58d72dca92f64270cc5337406f55f7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5fe48604bc6a6a2cb0b35e57e00e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ace5fe48604bc6a6a2cb0b35e57e00e28">updateConnectivityState</a> (<a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ace5fe48604bc6a6a2cb0b35e57e00e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the connectivity state to <em>newState</em> if different than the old state.  <a href="#ace5fe48604bc6a6a2cb0b35e57e00e28">More...</a><br /></td></tr>
<tr class="separator:ace5fe48604bc6a6a2cb0b35e57e00e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fc4806e4b832ed25ff6ee33e5a3149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7fc4806e4b832ed25ff6ee33e5a3149"></a>
virtual <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ae7fc4806e4b832ed25ff6ee33e5a3149">defaultChildConnectivityState</a> () const </td></tr>
<tr class="memdesc:ae7fc4806e4b832ed25ff6ee33e5a3149"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default connectivity state for newly created devices. <br /></td></tr>
<tr class="separator:ae7fc4806e4b832ed25ff6ee33e5a3149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152b72680e5dfeb6510c13aa0b413c26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a152b72680e5dfeb6510c13aa0b413c26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setInitialized</b> (bool initialized)</td></tr>
<tr class="separator:a152b72680e5dfeb6510c13aa0b413c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bf4bbc3ed02a49b6830c807471f448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28bf4bbc3ed02a49b6830c807471f448"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTerminationPrepared</b> (bool prepared)</td></tr>
<tr class="separator:a28bf4bbc3ed02a49b6830c807471f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa277b375d73ec3e27d9a5da15f51e9b6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa277b375d73ec3e27d9a5da15f51e9b6">shouldWriteMessageToLogFile</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;msg) const </td></tr>
<tr class="separator:aa277b375d73ec3e27d9a5da15f51e9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d33fe54b1c8a312ce83faec1cc91bee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a8d33fe54b1c8a312ce83faec1cc91bee">shouldWriteMessageToLogFile</a> (const <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;message) const </td></tr>
<tr class="separator:a8d33fe54b1c8a312ce83faec1cc91bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c0a6e82423d18b133b15ba7bc73bae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a52c0a6e82423d18b133b15ba7bc73bae">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;snd) const </td></tr>
<tr class="memdesc:a52c0a6e82423d18b133b15ba7bc73bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message and wait for its reply.  <a href="#a52c0a6e82423d18b133b15ba7bc73bae">More...</a><br /></td></tr>
<tr class="separator:a52c0a6e82423d18b133b15ba7bc73bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570cc7d5f81c0f6eafff42843ad40ac2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a570cc7d5f81c0f6eafff42843ad40ac2">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;snd, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv) const </td></tr>
<tr class="memdesc:a570cc7d5f81c0f6eafff42843ad40ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message and wait for its reply.  <a href="#a570cc7d5f81c0f6eafff42843ad40ac2">More...</a><br /></td></tr>
<tr class="separator:a570cc7d5f81c0f6eafff42843ad40ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0954215587c3ab54ccc286f3dc9f45c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#aa0954215587c3ab54ccc286f3dc9f45c">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;snd, <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;rcv, uint32_t timeout) const </td></tr>
<tr class="memdesc:aa0954215587c3ab54ccc286f3dc9f45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message and wait for its reply.  <a href="#aa0954215587c3ab54ccc286f3dc9f45c">More...</a><br /></td></tr>
<tr class="separator:aa0954215587c3ab54ccc286f3dc9f45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a37b64b79deecc5b698018e8f1872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ad40a37b64b79deecc5b698018e8f1872">doTransaction</a> (const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;snd, uint32_t timeout) const </td></tr>
<tr class="memdesc:ad40a37b64b79deecc5b698018e8f1872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message and wait for its reply.  <a href="#ad40a37b64b79deecc5b698018e8f1872">More...</a><br /></td></tr>
<tr class="separator:ad40a37b64b79deecc5b698018e8f1872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1af9dbd88ca9992801f305672942d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa1af9dbd88ca9992801f305672942d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>justWriteSetting</b> () const </td></tr>
<tr class="separator:afa1af9dbd88ca9992801f305672942d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded9cf76caba4d7c8d6f6844c6eae347"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aded9cf76caba4d7c8d6f6844c6eae347"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clearProcessors</b> ()</td></tr>
<tr class="separator:aded9cf76caba4d7c8d6f6844c6eae347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee35aec75e2ee9fe7072aa6487b595e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee35aec75e2ee9fe7072aa6487b595e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a4ee35aec75e2ee9fe7072aa6487b595e">clearDataCache</a> ()</td></tr>
<tr class="memdesc:a4ee35aec75e2ee9fe7072aa6487b595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the data cache. <br /></td></tr>
<tr class="separator:a4ee35aec75e2ee9fe7072aa6487b595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a93d9a43818a13dd3feb05c8730b75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a75a93d9a43818a13dd3feb05c8730b75">insertIntoDataCache</a> (int64_t pid, <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *pack)</td></tr>
<tr class="memdesc:a75a93d9a43818a13dd3feb05c8730b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the packet ID and data packet into the data cache.  <a href="#a75a93d9a43818a13dd3feb05c8730b75">More...</a><br /></td></tr>
<tr class="separator:a75a93d9a43818a13dd3feb05c8730b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff275aff19d23b32dd07a0e419b68b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff275aff19d23b32dd07a0e419b68b6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reinitializeProcessors</b> ()</td></tr>
<tr class="separator:a9ff275aff19d23b32dd07a0e419b68b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f4146a98db9b094c88ada1f474e5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a348f4146a98db9b094c88ada1f474e5c">expectingRetransmissionForPacket</a> (int64_t packetId) const </td></tr>
<tr class="memdesc:a348f4146a98db9b094c88ada1f474e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function indicates if the device supports retransmissions (at all)  <a href="#a348f4146a98db9b094c88ada1f474e5c">More...</a><br /></td></tr>
<tr class="separator:a348f4146a98db9b094c88ada1f474e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d326da7273f832fe67b950caa5970a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af2d326da7273f832fe67b950caa5970a">resetRemovesPort</a> () const </td></tr>
<tr class="memdesc:af2d326da7273f832fe67b950caa5970a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a device reset will remove the COM port connection.  <a href="#af2d326da7273f832fe67b950caa5970a">More...</a><br /></td></tr>
<tr class="separator:af2d326da7273f832fe67b950caa5970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa870ada99540e854ecc2733baaab74ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa870ada99540e854ecc2733baaab74ec"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSoftwareFilteringEnabled</b> () const </td></tr>
<tr class="separator:aa870ada99540e854ecc2733baaab74ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f79101d195b9210ec137658bc0583f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8f79101d195b9210ec137658bc0583f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSoftwareCalibrationEnabled</b> () const </td></tr>
<tr class="separator:af8f79101d195b9210ec137658bc0583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63c77821ac836f479a8f86aef0693e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#af63c77821ac836f479a8f86aef0693e4">setStartRecordingPacketId</a> (int64_t startFrame)</td></tr>
<tr class="memdesc:af63c77821ac836f479a8f86aef0693e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets start recording packet id.  <a href="#af63c77821ac836f479a8f86aef0693e4">More...</a><br /></td></tr>
<tr class="separator:af63c77821ac836f479a8f86aef0693e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b2ce8a779b77f79bbbb84d85c209b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#ab9b2ce8a779b77f79bbbb84d85c209b0">setStopRecordingPacketId</a> (int64_t stopFrame)</td></tr>
<tr class="memdesc:ab9b2ce8a779b77f79bbbb84d85c209b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets stop recording packet id.  <a href="#ab9b2ce8a779b77f79bbbb84d85c209b0">More...</a><br /></td></tr>
<tr class="separator:ab9b2ce8a779b77f79bbbb84d85c209b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4ece84f49ed92e0a1ed602e5055c49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f4ece84f49ed92e0a1ed602e5055c49"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a1f4ece84f49ed92e0a1ed602e5055c49">endRecordingStream</a> ()</td></tr>
<tr class="memdesc:a1f4ece84f49ed92e0a1ed602e5055c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the end of the recording stream. <br /></td></tr>
<tr class="separator:a1f4ece84f49ed92e0a1ed602e5055c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c3619092bc764613281c4881492eee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c3619092bc764613281c4881492eee"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_xs_device.html#a41c3619092bc764613281c4881492eee">clearCacheToRecordingStart</a> ()</td></tr>
<tr class="memdesc:a41c3619092bc764613281c4881492eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the data cache up till the packet indicated by the start recording frame. <br /></td></tr>
<tr class="separator:a41c3619092bc764613281c4881492eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_struct_xs_callback_plain_c"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct_xs_callback_plain_c')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a></td></tr>
<tr class="memitem:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">m_onDeviceStateChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> newState, <a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> oldState)</td></tr>
<tr class="memdesc:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a device's state has changed (ie config mode, measurement mode, recording mode)  <a href="group___callbacks.html#ga8246e1d43087d9a1d559b4015cc5a828">More...</a><br /></td></tr>
<tr class="separator:ga8246e1d43087d9a1d559b4015cc5a828 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">m_onLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga4e69823b97ba679d3937ddc140bbc15c">More...</a><br /></td></tr>
<tr class="separator:ga4e69823b97ba679d3937ddc140bbc15c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">m_onMissedPackets</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int count, int first, int last)</td></tr>
<tr class="memdesc:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that packets have been missed.  <a href="group___callbacks.html#ga406bc7b8493223ddd47c439d0a5b50f8">More...</a><br /></td></tr>
<tr class="separator:ga406bc7b8493223ddd47c439d0a5b50f8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">m_onWakeupReceived</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev)</td></tr>
<tr class="memdesc:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a wakeup message has been received from a device. This indicates that the device has just been reset or plugged in.  <a href="group___callbacks.html#ga9f14d44ea1773133b68b01ae53af8ab8">More...</a><br /></td></tr>
<tr class="separator:ga9f14d44ea1773133b68b01ae53af8ab8 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">m_onProgressUpdated</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int current, int total, const struct <a class="el" href="struct_xs_string.html">XsString</a> *identifier)</td></tr>
<tr class="memdesc:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a long-duration operation has made some progress or has completed. Examples include loadLogFile and flushing of retransmissions (Awinda). When <em>current</em> == <em>total</em> the operation has completed.  <a href="group___callbacks.html#ga0131fcde042d419e07dd2144b5d2d36e">More...</a><br /></td></tr>
<tr class="separator:ga0131fcde042d419e07dd2144b5d2d36e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">m_onWriteMessageToLogFile</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_message.html">XsMessage</a> *message)</td></tr>
<tr class="memdesc:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a message that could be written to a log file.  <a href="group___callbacks.html#gacc866d3a718e0351a9d23a2d1ec2586a">More...</a><br /></td></tr>
<tr class="separator:gacc866d3a718e0351a9d23a2d1ec2586a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">m_onBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has a data packet that could be written to a log file.  <a href="group___callbacks.html#gae186ea85d702212393fc4da478088a05">More...</a><br /></td></tr>
<tr class="separator:gae186ea85d702212393fc4da478088a05 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">m_onConnectivityChanged</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> newState)</td></tr>
<tr class="memdesc:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA has detected a change in the connectivity state of a device.  <a href="group___callbacks.html#ga7a2d3d70d8db257a5e97887576eed19b">More...</a><br /></td></tr>
<tr class="separator:ga7a2d3d70d8db257a5e97887576eed19b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">m_onInfoResponse</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#gafc251752e68beaf61a5fd95627b344ba">XsInfoRequest</a> request)</td></tr>
<tr class="memdesc:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an information request has resulted in a response.  <a href="group___callbacks.html#ga91d8b003d9966a2e3ad3a46d0732a97c">More...</a><br /></td></tr>
<tr class="separator:ga91d8b003d9966a2e3ad3a46d0732a97c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">m_onError</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> error)</td></tr>
<tr class="memdesc:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when an error has occurred while handling incoming data.  <a href="group___callbacks.html#ga0e6a9805f05f1d3128064be4bc08413b">More...</a><br /></td></tr>
<tr class="separator:ga0e6a9805f05f1d3128064be4bc08413b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga829650872a3b6d36a5e31a2eec5d2e2c">m_onNonDataMessage</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a non data, non reply message has been received.  <a href="group___callbacks.html#ga829650872a3b6d36a5e31a2eec5d2e2c">More...</a><br /></td></tr>
<tr class="separator:ga829650872a3b6d36a5e31a2eec5d2e2c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf0613e7c8f4082ab408fd75f97828eb7">m_onMessageDetected</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, <a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a> type, struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> const *rawMessage)</td></tr>
<tr class="memdesc:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is detected in raw data from the device.  <a href="group___callbacks.html#gaf0613e7c8f4082ab408fd75f97828eb7">More...</a><br /></td></tr>
<tr class="separator:gaf0613e7c8f4082ab408fd75f97828eb7 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga394de49100504b50d64fd2b46ed344ab">m_onMessageReceivedFromDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a valid message (after parsing) is received from the device.  <a href="group___callbacks.html#ga394de49100504b50d64fd2b46ed344ab">More...</a><br /></td></tr>
<tr class="separator:ga394de49100504b50d64fd2b46ed344ab inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga68c5f0ea480527fb420607449fc21ae2">m_onMessageSentToDevice</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, struct <a class="el" href="struct_xs_message.html">XsMessage</a> const *message)</td></tr>
<tr class="memdesc:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just after a message is sent to the device.  <a href="group___callbacks.html#ga68c5f0ea480527fb420607449fc21ae2">More...</a><br /></td></tr>
<tr class="separator:ga68c5f0ea480527fb420607449fc21ae2 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">m_onAllLiveDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga3c2a40680bf18c67190bf81439c4e19d">More...</a><br /></td></tr>
<tr class="separator:ga3c2a40680bf18c67190bf81439c4e19d inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">m_onAllBufferedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga530314b978cfc8e67a428ef5977e387c">More...</a><br /></td></tr>
<tr class="separator:ga530314b978cfc8e67a428ef5977e387c inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">m_onDataUnavailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, int64_t packetId)</td></tr>
<tr class="memdesc:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA detects that data is forever unavailable.  <a href="group___callbacks.html#ga422f718cc9c4af42b868b998d106eb7a">More...</a><br /></td></tr>
<tr class="separator:ga422f718cc9c4af42b868b998d106eb7a inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">m_onDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf35dbb77b7b08bc8b8e23e6b64c5e87e">More...</a><br /></td></tr>
<tr class="separator:gaf35dbb77b7b08bc8b8e23e6b64c5e87e inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">m_onAllDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaf2ecd8acc66bddf7d1ee079836e0ce36">More...</a><br /></td></tr>
<tr class="separator:gaf2ecd8acc66bddf7d1ee079836e0ce36 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">m_onRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device.html">XsDevice</a> *dev, const struct <a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *packet)</td></tr>
<tr class="memdesc:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received from a device in a recording state or read from a file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#ga8b8c139d2c3c55805d73511457956005">More...</a><br /></td></tr>
<tr class="separator:ga8b8c139d2c3c55805d73511457956005 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">m_onAllRecordedDataAvailable</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, struct <a class="el" href="struct_xs_device_ptr_array.html">XsDevicePtrArray</a> *devs, const struct <a class="el" href="struct_xs_data_packet_ptr_array.html">XsDataPacketPtrArray</a> *packets)</td></tr>
<tr class="memdesc:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new data has been received for devices connected to the same main device in a recording state or read from file. When processing on PC is enabled, this callback occurs after processing has been done and so the packet will contain the processing output.  <a href="group___callbacks.html#gaccdcbea991503b517e4f84f39ee116a4">More...</a><br /></td></tr>
<tr class="separator:gaccdcbea991503b517e4f84f39ee116a4 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">m_onTransmissionRequest</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, int channelId, const struct <a class="el" href="struct_xs_byte_array.html">XsByteArray</a> *data)</td></tr>
<tr class="memdesc:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when XDA needs to send raw data to a device connected using a custom communication channel.  <a href="group___callbacks.html#gaa5d90a461c21f3e14756360027e6658b">More...</a><br /></td></tr>
<tr class="separator:gaa5d90a461c21f3e14756360027e6658b inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">m_onRestoreCommunication</a> )(struct <a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *, const struct <a class="el" href="struct_xs_string.html">XsString</a> *portName, <a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> result)</td></tr>
<tr class="memdesc:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when restore communication is completed, stopped or an error occured.  <a href="group___callbacks.html#ga140e7bfb9bfadef2a1f22671f936ff14">More...</a><br /></td></tr>
<tr class="separator:ga140e7bfb9bfadef2a1f22671f936ff14 inherit pub_attribs_struct_xs_callback_plain_c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A pointer to an <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> object. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a451a1328bb55a80f57c70e8b54fe7628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::XsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty device with device id <em>id</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The device ID to construct with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6fc0c07a5eeeb6dad0c8f5cf0e0d813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::XsDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a device using <em>inf</em> for communication. </p>
<p>Using this constructor implies that this device is a master device (<a class="el" href="struct_xs_device.html#add6706c445acd02d690ce8e4058d81bb" title="Return the master device of this device. ">master()</a> returns this). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The <a class="el" href="struct_communicator.html" title="A base struct for a communication interface. ">Communicator</a> to use for this device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2f7e7e4070483dcbb5c792a045bace4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::XsDevice </td>
          <td>(</td>
          <td class="paramtype">MtContainer *&#160;</td>
          <td class="paramname"><em>masterDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>childDeviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a device with device id <em>childDeviceId</em> for master <em>masterDevice</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">masterDevice</td><td>The master device ID to construct for </td></tr>
    <tr><td class="paramname">childDeviceId</td><td>The child device ID to construct with</td></tr>
  </table>
  </dd>
</dl>
<p>Communication uses <em>masterDevice's</em> channel </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a896f5a1cc4f6000801130ff6b11fd064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::abortFlushing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the wireless flushing operation and finalize the recording. </p>
<dl class="section return"><dt>Returns</dt><dd>true if no flushing is in progress when the function exits </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a5b0efda5cfa8ee7757e49c5aee686e68">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a5d8759ef4e201718a78333b39f26e0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::abortLoadLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts loading a logfile. </p>
<dl class="section return"><dt>Returns</dt><dd>true if loading is aborted successfully </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if no file was currently loading returns false </dd></dl>

</div>
</div>
<a class="anchor" id="a57669117e40f883f3fb0c30b8aa0ef20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::accelerometerRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the accelerometers in the device. </p>
<p>The actual official range is -accelerometerRange() .. <a class="el" href="struct_xs_device.html#a57669117e40f883f3fb0c30b8aa0ef20" title="Returns the maximum official value of the accelerometers in the device. ">accelerometerRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p><dl class="section return"><dt>Returns</dt><dd>The maximum value of the accelerometers in m/s^2 </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a691bc5830ad0aca32eb843bba42c19f4">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac7bb30f38df4659cb681b7b3a7b99067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::acceptConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept connections from the device on the parent/master device. </p>
<p>This function can be used to accept connections from a device that has been rejected. Call this function from within the onConnectivityChanged callback. </p><dl class="section return"><dt>Returns</dt><dd>true if the device will be accepted next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw rejected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="ad06eb9a731cec918e7087af24ecf9d19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a> XsDevicePtr::accessControlMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the access control mode of the master device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured access control mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf" title="Set the access control mode of the master device. ">setAccessControlMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ad0fd097811cf459eec7855bfdd7447e0" title="Request the access control list of the master device. ">currentAccessControlList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affecdda0f378e2193c75a3e01055eecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::addCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a callback handler to the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to add to the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NULL and duplicate handlers are ignored, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bf7faf0b7d3bb756df0b6a6cce5417c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_reply_object.html">ReplyObject</a> &gt; XsDevicePtr::addReplyObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gacc13dabe6a88b53c675679d40414ba9a">XsXbusMessageId</a>&#160;</td>
          <td class="paramname"><em>messageId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a reply object to the communicator to wait for a specific message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageId</td><td>The message Id to wait for. </td></tr>
    <tr><td class="paramname">data</td><td>The data to check for in the first data byte location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a32aefeb3bcf3a82a8e6c2e1281283a1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevicePtr::alignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation matrix to rotate S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a2da0a4301028d1f0ac3dcd090a7cbdbb">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae4159ae056441f563d06e4d94450f61e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> XsDevicePtr::alignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the alignment rotation quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame of which to return the alignment rotation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The alignment rotation </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a03512a7a268e4e9ebb9b28ef1ed2bc8b">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a08ea246d7c10a63c5d6c4cebb32a4eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::applyConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a config file(.xsa) and configures the device accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8c443be103003479799fa888ada5216e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::areOptionsEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when all the specified processing options are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The options to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the options are enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6493f27ff1ce3af653e2c61eec8c0bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> XsDevicePtr::availableOnboardFilterProfiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a96aeb16cfa3b49bfe70a399e0cee27b2" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a641be2171073c15aa29d61056fa32472">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a5eb69ce9c16cd3167a5dfa41b4a26c74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile_array.html">XsFilterProfileArray</a> XsDevicePtr::availableXdaFilterProfiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of filter profiles available on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of filter profiles available for computing orientations on the host PC </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c603076bee2eb69133b3b3f80cfb992" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a12837e1d6d6e4016206023905a920457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::batteryLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the remaining capacity as a percentage. Due to battery characteristics, this is not directly the remaining time, but just a rough indication. </p>
<p>Bodypack: The amount of time remaining for measurement given any battery level greatly depends on the type of batteries used, the number of sensors attached to the Bodypack and the used output options. Mtw: The last known battery level for this motion tracker. First call </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a79f8e3b9c96877dd7e77b06892fa486a" title="Request the battery level from the device. ">requestBatteryLevel</a> to have a battery level available. The callback </dd>
<dd>
<a class="el" href="class_callback_manager_xda.html#a01afaba0ea9f47b5c4f490ee7dba7364" title="The XsCallback::onInfoResponse() callback forwarding function. ">onInfoResponse</a> with ID <a class="el" href="group__enums.html#ggafc251752e68beaf61a5fd95627b344baadedf85741d51224bcc9b24a8ae08532f" title="Request battery level. ">XIR_BatteryLevel</a> will indicate when the requested battery level is available. This function is available in both config and measurement mode. For devices in wired mode this function can be called without calling </dd>
<dd>
<a class="el" href="struct_xs_device.html#a79f8e3b9c96877dd7e77b06892fa486a" title="Request the battery level from the device. ">requestBatteryLevel</a> first </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The battery level in the range 0-100 </dd></dl>

</div>
</div>
<a class="anchor" id="a1937de9f8e39f990f010ed9b2a56d5dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_time_stamp.html">XsTimeStamp</a> XsDevicePtr::batteryLevelTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the time the battery level was last updated. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="struct_xs_time_stamp.html" title="This class contains method to set, retrieve and compare timestamps. ">XsTimeStamp</a> the battery level was last set </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#ad30bc37be7126fbef61886edda0736cf">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae42156bdd1fa0f8b62ba9ae90cf41ddb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> XsDevicePtr::baudRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the baud rate (communication speed) of the serial port on which the given <em>deviceId</em> is connected. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#ae2e9fcca145bf4d9adf719c131dbf669" title="The baud rate configured for cabled connection. ">serialBaudRate()</a> function in that it will only return the baud rate of the current connection, whereas the <a class="el" href="struct_xs_device.html#ae2e9fcca145bf4d9adf719c131dbf669" title="The baud rate configured for cabled connection. ">serialBaudRate()</a> function will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly). </p><dl class="section return"><dt>Returns</dt><dd>The baud rate of the serial connection or XBR_Invalid </dd></dl>

</div>
</div>
<a class="anchor" id="a9f1b990350dc62b2c39bf6cb9a829810"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::busId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bus ID for this device. </p>
<dl class="section return"><dt>Returns</dt><dd>The bus ID of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a044139a7a86a5f132ecc261cf2f0c0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::cacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of items currently in the slow data cache for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The actual number of items in the cache, which may contain huge gaps in packet ids </dd></dl>

</div>
</div>
<a class="anchor" id="ace981af9fb801acc89d459ac405eee42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::canConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured CAN configuration of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The can configuration of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#acd999d65e1e4baab808c2dae357efa5e">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="a43f5de72dcccb8a595dca2a7babf20cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> XsDevicePtr::canOutputConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured CAN output of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The can output configuration of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#a1808eb2570de98677eade18ffb9d1415">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="a00be5c50cfcd3f79a90ed281bb739b1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::childCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of child-devices this device has. For standalone devices this is always 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of child devices of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a4a0a4f4c47e120d7a93738acadf2d305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_xs_device.html">XsDevice</a> * &gt; XsDevicePtr::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a managed array containing the child-devices this device has. For standalone devices this is always an empty array. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of pointers to the child devices of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#abc58ca5f260739dd54a8573449b7e3e4">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a208157faba015c166f2878e070cfad94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::clearCallbackHandlers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the callback handler list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chain</td><td>Whether to clear the callback handlers of all child devices as well (true, default) or just the callback handlers of this XsDevice object (false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bfa1a413439dfce3ebb21a29af9aab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::closeLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the log file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the log file was successfully closed or never open </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a8b4364730cc961205805d234714268d4">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a8270c2ec0fe8edc9663209c91c564680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a> XsDevicePtr::connectivityState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the connectivity state of the device. </p>
<p>The connectivity describes how and if the device is connected to XDA. </p><dl class="section return"><dt>Returns</dt><dd>The current connectivity of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c" title="XsDevice connectivity state identifiers. ">XsConnectivityState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6aea7017d2579fee0b04243ad7a1a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::createConfigFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the current device configuration in a config file(.xsa) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The desired path and filename of the config file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8afe4b27a5df14e02c8a1c6a7dfcb3c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::createLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_string.html">XsString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a log file for logging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The desired path and filename of the log file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or failure </dd></dl>

</div>
</div>
<a class="anchor" id="ad0fd097811cf459eec7855bfdd7447e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> XsDevicePtr::currentAccessControlList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the access control list of the master device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured access control list. This can be either a blacklist or a whitelist. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ac620eb9326e9c98fdd82dd597cf39cbf" title="Set the access control mode of the master device. ">setAccessControlMode</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ad06eb9a731cec918e7087af24ecf9d19" title="Request the access control mode of the master device. ">accessControlMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca70e4aa0cddfde706708f5037baa6df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::dataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the data in the legacy MTData packets that the device will send in measurement mode. </p>
<p>This function will only return a value when the device is configured for legacy output, otherwise it will return 0. </p><dl class="section return"><dt>Returns</dt><dd>The data size of the MTData packets that will be sent by the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setDeviceMode </dd>
<dd>
deviceMode </dd></dl>

</div>
</div>
<a class="anchor" id="af5252f1f85a52eeef4ac2c5af789c24e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::deviceAtBusId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aac6d6e422d8ccf6316a33f29be3259ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::deviceAtBusIdConst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>busid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device with bus ID <em>busid</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">busid</td><td>The busid to serach for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The const <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> corresponding to the supplied <em>busid</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a614d1be1baed8fd5041d4ce2768478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::deviceBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the size of the interal buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Buffer size in number of frames </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec9a12b9eeae25242483bb6e7eb734a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_configuration.html">XsDeviceConfiguration</a> XsDevicePtr::deviceConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the device configuration. </p>
<p>The device configuration contains a summary of the devices connected to the same port. The function will always return the configuration for the port's main device. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the device configuration of the port </dd></dl>

</div>
</div>
<a class="anchor" id="a4816ad6761de87cb49a96ce1807864f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a> XsDevicePtr::deviceId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the device ID of the device. </p>
<p>Each Xsens device has a unique ID. The ID identifies the device as well as the product family it belongs to. </p><dl class="section return"><dt>Returns</dt><dd>The device ID </dd></dl>

</div>
</div>
<a class="anchor" id="a80a7a98d741d407f20d71e43ea87ba86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::deviceIsDocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the device is docked. </p>
<p>Checks if device <em>dev</em> is docked in this device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is docked in this device </dd></dl>

</div>
</div>
<a class="anchor" id="ae3c5dbf8351d4d05c7dc0868a4ac7464"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a> XsDevicePtr::deviceOptionFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device option flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The current configured device option flags </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a3a7b9f5f175ef8de43cb0f649c81cf0e">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a76cfeac115b80bd9e879838dbfd0ef6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::deviceParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the requested parameter's current value. </p>
<p>Retrieving device parameters is only valid after initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>a parameter object, corresponding to a row in the table listed under <em>XsDevice::setParameter</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or unsupported with current or current firmware version (XRV_UNSUPPORTED) </dd></dl>
<dl class="section see"><dt>See also</dt><dd>XsDevice::setParameter </dd></dl>

</div>
</div>
<a class="anchor" id="a7b46e5ef7a7b4fc81d6fac9664f6bf82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a> XsDevicePtr::deviceState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the state of this device. </p>
<p>The device state indiciates whether the device is in config mode, measuring, recording, etc </p><dl class="section return"><dt>Returns</dt><dd>The state of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a12cb16caa27b67d8c5e6b6f534acb5f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::disableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a communication protocol previously added by <a class="el" href="struct_xs_device.html#a026c49500ad437124d9d4f3d8734f6d9" title="Enable an additional communication protocol when reading messages. ">XsDevice::enableProtocol</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the removal was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="afd0bc12c41ea7ffc8f69a3cd619716f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::disableRadio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the radio for this station, resetting all children to disconnected state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a9a63a1bc2d1424df962f81bbcf8977bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::discardRetransmissions </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>firstNewPacketId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell XDA and the device that any data from before <em>firstNewPacketId</em> may be lossy. </p>
<p>Tell the device to not request retransmissions of missed data older than the supplied <em>firstNewPacketId</em>. If <em>firstNewPacketId</em> is beyond the end of the recording or beyond the highest received packet ID, the lower value is used instead. This means that you can't set this for future packets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstNewPacketId</td><td>The first packet that (if missing) <em>should</em> be retransmitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This applies to master devices that support retransmissions only: Awinda and Bodypack. </dd></dl>

</div>
</div>
<a class="anchor" id="a52c0a6e82423d18b133b15ba7bc73bae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>snd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message and wait for its reply. </p>
<p>The expected reply is always the Ack to <em>snd's</em> message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>the message to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was sent and acknowledged, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a570cc7d5f81c0f6eafff42843ad40ac2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message and wait for its reply. </p>
<p>The expected reply is always the Ack to <em>snd's</em> message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>the message to send </td></tr>
    <tr><td class="paramname">rcv</td><td>a pointer to a receive message. The contents are only valid if true was returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was sent and acknowledged, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa0954215587c3ab54ccc286f3dc9f45c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message and wait for its reply. </p>
<p>The expected reply is always the Ack to <em>snd's</em> message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>the message to send </td></tr>
    <tr><td class="paramname">rcv</td><td>a pointer to a receive message </td></tr>
    <tr><td class="paramname">timeout</td><td>the timeout to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was sent and acknowledged, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad40a37b64b79deecc5b698018e8f1872"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::doTransaction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>snd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message and wait for its reply. </p>
<p>The expected reply is always the Ack to <em>snd's</em> message </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snd</td><td>the message to send </td></tr>
    <tr><td class="paramname">timeout</td><td>the timeout to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was sent and acknowledged, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a026c49500ad437124d9d4f3d8734f6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::enableProtocol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable an additional communication protocol when reading messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>The type of protocol-support to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the addition was successful </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a per port or per file setting </dd></dl>

</div>
</div>
<a class="anchor" id="a24af0dcccddf838764795b169213a9af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::enableRadio </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the radio channel to use for wireless communication. </p>
<p>This function can be used to enable or disable the radio of an Awinda Station. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>A valid channel number in the range [11..25] or -1 to disable the radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the radio was successfully reconfigured </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="aa689e1d8c857703bdf8d60c51ef6db8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a> XsDevicePtr::errorMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error mode of the device. </p>
<p>The error mode tells the device what to do if a problem occurs. </p><dl class="section return"><dt>Returns</dt><dd>The currently configured error mode of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a91f03a8e30b52e38cebb8bfc3e6a7573" title="Sets the error mode of the device. ">setErrorMode</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#aec0e5964f580d4dba6ffcd5e15a56c61">MtDevice</a>, and <a class="el" href="class_mti_base_device.html#a9b4ca65345dc167b881d1bc775999bd2">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a348f4146a98db9b094c88ada1f474e5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::expectingRetransmissionForPacket </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>packetId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function indicates if the device supports retransmissions (at all) </p>
<p>This is required for the handleDataMessage to deal with missed data properly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetId</td><td>The ID of the packet that we want to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a retransmission is expected for the given packet </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Devices that return true are expected to handle their retransmissions properly themselves! </dd></dl>

</div>
</div>
<a class="anchor" id="a1a0f60e6c3fea423b1fa2792816fab6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::extractFirmwareVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> const &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the firmware version of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>XMID_FirmwareRevision message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad6fe5d2f33fbf8ba32a299cd47e56b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::findDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>. </p>
<p>This function returns the child device of the current device that matches the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>

</div>
</div>
<a class="anchor" id="a3327b3ab9c38e6d7146268cbb5f5074f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> const * XsDevicePtr::findDeviceConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the child device with <em>deviceid</em>. </p>
<p>This function returns the child device of the current device that matches the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceid</td><td>The device ID to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the found XsDevice or 0 if the device could not be found </dd></dl>

</div>
</div>
<a class="anchor" id="acf4711198a842b98d6b80ab6070241ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevicePtr::firmwareVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the firmware version. </p>
<dl class="section return"><dt>Returns</dt><dd>The firmware version of the live device </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The firmware version is not stored in mtb files, so when reading from file this function will return an empty XsVersion object </dd></dl>

</div>
</div>
<a class="anchor" id="aa17e702e833730b5bcbcb1b541d5f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::getDataPacketByIndex </td>
          <td>(</td>
          <td class="paramtype">XsSize&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cached data packet with <em>index</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The requested index, this does not have to be the same as the packet counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested packet or an empty packet if <em>index</em> is out of range </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only works if XSO_RetainLiveData or XSO_RetainBufferedData was set before the data was read </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae14ab746e9f11161276bed512b994132" title="Return the current size of the retained data packet cache. ">getDataPacketCount</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae14ab746e9f11161276bed512b994132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsDevicePtr::getDataPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current size of the retained data packet cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The current size of the cache </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae14ab746e9f11161276bed512b994132" title="Return the current size of the retained data packet cache. ">getDataPacketCount</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3551c9cc98da43c7953f01d412ecb986"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::getDeviceFromLocationId </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>locId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device given <em>locId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locId</td><td>the location ID of the device we're looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the device if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8de4e4d771a85d93c00a4685f1e2b910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a> XsDevicePtr::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the currently enabled options. </p>
<dl class="section return"><dt>Returns</dt><dd>The options that are enabled for this device and its child devices (if any) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e" title="Returns true when all the specified processing options are enabled. ">areOptionsEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6f45c09c173508322dc87769c153ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsDevicePtr::getStartRecordingPacketId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ID of the first packet that should be recorded. </p>
<p>This is only valid in Recording or Flushing states </p><dl class="section return"><dt>Returns</dt><dd>The ID of the first packet that should be recorded </dd></dl>

</div>
</div>
<a class="anchor" id="ace56912ce6c8ce53fd030ab126ab6f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t XsDevicePtr::getStopRecordingPacketId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the ID of the last packet that should be recorded. </p>
<p>This is only valid in Recording or Flushing states or in Measurement after a recording has finished </p><dl class="section return"><dt>Returns</dt><dd>The ID of the last packet that should be / was recorded </dd></dl>

</div>
</div>
<a class="anchor" id="ae17e694dc4601b9afd44067a04d60c1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsGnssPlatform XsDevicePtr::gnssPlatform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device GNSS platform. </p>
<dl class="section return"><dt>Returns</dt><dd>The current device GNSS platform </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#af1738c7d85d6628e3e608a98f7dcd04a">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a64a1fd038c9b569596e2ff48aaad39be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::gotoConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the device in config mode. </p>
<p>Device settings can only be changed in config mode, since changing anything during measurement would mess up the sample timing. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in config mode or was already in config mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a4877bf929d1f0e44b7f82db60bbdb1da" title="Put this device in measurement mode. ">gotoMeasurement</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#ae255e83c0dd8ed9ffce9d6230767b297">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a4877bf929d1f0e44b7f82db60bbdb1da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::gotoMeasurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put this device in measurement mode. </p>
<p>Measurement mode is where the device is sampling data and producing inertial and orientation output. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in measurement mode or was already in measurement mode </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a64a1fd038c9b569596e2ff48aaad39be" title="Put the device in config mode. ">gotoConfig</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#ab9de21939d7456f2b776c41432a987cd">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a15e4d362fb66a5ccef8a458c2320f4fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::gravityMagnitude </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 'Gravity Magnitude' of the device. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p><dl class="section return"><dt>Returns</dt><dd>The current 'Gravity Magnitude' setting of the device. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag. ">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a21cebe3dd7502b5d2e14659b770937b3" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38c423ff06e9f63bc05cdc38e6ee3f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::gyroscopeRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum official value of the gyroscopes in the device. </p>
<p>The actual official range is -gyroscopeRange() .. <a class="el" href="struct_xs_device.html#a38c423ff06e9f63bc05cdc38e6ee3f50" title="Returns the maximum official value of the gyroscopes in the device. ">gyroscopeRange()</a>. The device may send out higher values than this for extreme movements, but then the data quality can not be guaranteed. </p><dl class="section return"><dt>Returns</dt><dd>The maximum value of the gyroscopes in degrees/s </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ac695abd22d533139d3072a18c4f84e10">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a511fc02227c6b58ef282cf9a3518badf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_version.html">XsVersion</a> XsDevicePtr::hardwareVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hardware version of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The hardware version of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ac35e72c11db9a4a6ea6d179cf933532c">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#a9bb688961de0a6c18d7e62215e03a0c7">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aee24c84fbcf4691c7c31b76dc276c275"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::hasDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a407e30aab29f1033873cce8d411fae83" title="Returns the currently configured output of the device. ">outputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a76d8f53878808179a778b98e229e8242" title="Returns if the currently configured output contains dataType after processing on the host...">hasProcessedDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76d8f53878808179a778b98e229e8242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::hasProcessedDataEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the currently configured output contains <em>dataType</em> after processing on the host. </p>
<p>Where <a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275" title="Returns if the currently configured output contains dataType. ">hasDataEnabled()</a> only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to check the output for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dataType</em> is configured for output </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aee24c84fbcf4691c7c31b76dc276c275" title="Returns if the currently configured output contains dataType. ">hasDataEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9a2728ffa190332b465cae18f7d0497d" title="Return the full output configuration including post processing outputs. ">processedOutputConfiguration</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a717a3d27cd952dc87d660f18c884f542"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double XsDevicePtr::headingOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the 'heading offset' setting of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured heading offset in degrees </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#aed15e2d14dd5c4e6726fcf10f7e65611">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a21cebe3dd7502b5d2e14659b770937b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_vector.html">XsVector</a> XsDevicePtr::initialPositionLLA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'Latitude Longitude Altitude' setting of the device. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. Note: this XDA data type is the setting initialPositionLLA, which is set by setInitialPositionLLA. It's value is therefore static. Use LatitudeLongitude to retrieve the live position data from the MTi. </p><dl class="section return"><dt>Returns</dt><dd>lla The desired 'Latitude Longitude Altitude' setting for the device. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a15e4d362fb66a5ccef8a458c2320f4fa" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a831e34a80be9dc19a9dd4f27bb13a6f7">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a75a93d9a43818a13dd3feb05c8730b75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::insertIntoDataCache </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *&#160;</td>
          <td class="paramname"><em>pack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the packet ID and data packet into the data cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pid</td><td>The packet ID to instert </td></tr>
    <tr><td class="paramname">pack</td><td>The data packet to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2533e270f6b6002f581847e15391da11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::interpolateMissingData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> *)&gt;&#160;</td>
          <td class="paramname"><em>packetHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell XDA to interpolate missing items from <em>prev</em> to <em>pack</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>The latest received packet </td></tr>
    <tr><td class="paramname">prev</td><td>The previously received packet </td></tr>
    <tr><td class="paramname">packetHandler</td><td>The function to call with all newly created intermediate and the final packet. packetHandler is expected to take control of its argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interpolation was successful, false if it was not </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation does nothing </dd></dl>

</div>
</div>
<a class="anchor" id="af3487b6bfd1e9b7e46862e152f894eb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isBlueToothEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device has its BlueTooth radio enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has its BlueTooth radio enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a99583e7e3b8be3c0f70454ebbf885afd" title="Enable or disable the BlueTooth radio of the device. ">setBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b44e4219466145e162d01ed500ec702"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isBusPowerEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the Xbus is powering its child devices or not. </p>
<p>When the bus power is off, the child devices are disabled </p><dl class="section return"><dt>Returns</dt><dd>true If the Xbus is currently providing power to its child devices </dd></dl>

</div>
</div>
<a class="anchor" id="a95b9c768227f0520112b8b30d189bda3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isCompatibleSyncSetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> const &amp;&#160;</td>
          <td class="paramname"><em>setting1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_sync_setting.html">XsSyncSetting</a> const &amp;&#160;</td>
          <td class="paramname"><em>setting2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting1</td><td>Setting 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">setting2</td><td>Setting 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when <em>setting1</em> is compatible with <em>setting2</em> for deviceId <em>deviceId</em> </dd></dl>

</div>
</div>
<a class="anchor" id="adbaa56e797f84dcf7bdf3bd4a1461410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isContainerDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this device can have child devices. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a container device </dd></dl>

</div>
</div>
<a class="anchor" id="afc6647738e04ad072e94a91cbe544990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the fixed gravity value should be used or if it should be computed from the initialPositionLLA value. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a0d5b98429d0b592a3395fb853619e8a7" title="Sets whether the fixed gravity value should be used or if it should be computed from the initialPosit...">setFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a15e4d362fb66a5ccef8a458c2320f4fa" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a21cebe3dd7502b5d2e14659b770937b3" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abee452722dcd4859fd9e9c241cf3af06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p><dl class="section return"><dt>Returns</dt><dd>true if the option is enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709" title="Set the no rotation period to duration. ">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96" title="Set if the device does gyroscope bias estimation when switching to measurement mode. ">setInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a195a4440598a15ee45b9ab484559f593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the device is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been initialized </dd></dl>

</div>
</div>
<a class="anchor" id="a1a5a6a04ca9857d9b0433c5f3bb8bc95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInStringOutputMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the device is outputting data in string mode. </p>
<p>In string mode only NMEA packets are transmitted at the legacy update rate </p><dl class="section return"><dt>Returns</dt><dd>true if the device is configured for string mode output. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0184dcf9a8c03941b3232c5e15dfa2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isInSyncStationMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is in Sync Station mode (Awinda Station and Sync Station only) </dd></dl>

</div>
</div>
<a class="anchor" id="a62cee213873a1d513d14e795a7ce178b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isLoadLogFileInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the file operation started by loadLogFile is still in progress. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the file operation started by loadLogFile is still in progress </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8cb3d5926ba88aace3a6c7bc2317487d" title="Load a complete logfile. ">loadLogFile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aff6d9626773e736aa2b0224859baa3ce" title="Wait for the file operation started by loadLogFile to complete. ">waitForLoadLogFileDone</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a487254bfbbb279e8e63de5e9ac5164fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMasterDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this is the master device (not a child of another device) </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is the master device </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b63e3e26701545a3081140726492e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMeasuring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a measuring state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a measuring state </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#ad93194438c74cb8be329c2d538362ae3">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a281ee50e8e8bf46f27d705e609f99fa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isMotionTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a motion tracker. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a motion tracker or false if it is a master device such as an Awinda Station or a Bodypack </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ab6aaa3e81f09064df91ccbcdec0f37a5">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac3c3e71ff320ed86a7accc0db5891159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isOperational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when the device is operational </dd></dl>
<dl class="section see"><dt>See also</dt><dd>AwindaStationDevice::makeOperational() </dd></dl>

</div>
</div>
<a class="anchor" id="aeda57eca1b67c459bb0aa44f9c3130fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isProtocolEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga66e6aac0cf44474fe94d0060ad051887">XsProtocolType</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true when a protocol with type <em>type</em> has been added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>The protocol type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10d4ff180af0c4501cbe0a51c7d54ccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isRadioEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if the radio is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the radio is enabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e4585d1ac37b9575c68ee0d6c1b36c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isReadingFromFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is reading from a file. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is reading from a file </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#ad16a460a4d6c31b204a1b630141240a0">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a2ea0a1dfe75b07d0f45949058e8214b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the device is currently in a recording state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently in a recording state </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a1936e7e3c6fe5a33c7c97b77dac3d926">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aa2eff7868f2a6a3a27a0926cbc02ac6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isStandaloneDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this is a standalone device (not a child of another device and not a container device) </p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a standalone device, equivalent to !isContainerDevice() &amp;&amp; <a class="el" href="struct_xs_device.html#a487254bfbbb279e8e63de5e9ac5164fa" title="Returns true if this is the master device (not a child of another device) ">isMasterDevice()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a81ad82485ecd1d88316a1e7098d720c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isSyncMaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a master role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization master role </dd></dl>

</div>
</div>
<a class="anchor" id="a496b1aa7178a7059b4dc0788f594309a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::isSyncSlave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this device is in a slave role regarding the device synchronization </p>
<dl class="section return"><dt>Returns</dt><dd>true if the device has a synchronization slave role </dd></dl>

</div>
</div>
<a class="anchor" id="af35579cec2bccb5b3d98886539759adc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::lastAvailableLiveData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last available live data. </p>
<dl class="section return"><dt>Returns</dt><dd>A packet containing the latest available live data. This packet will contain the latest data of each appropriate type, so it may contain old data mixed with new data if different data comes in at different speeds. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only works if XSO_KeepLastLiveData is set </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99be0d4d89eec4ff406d0098aac937cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t XsDevicePtr::lastKnownRssi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last known RSSI value of the device. </p>
<p>RSSI values are only relevant for wireless devices. Since the value is measured passively, any time an RSSI value is received by XDA, the last known value is updated. </p><dl class="section return"><dt>Returns</dt><dd>The last known biased RSSI value or XS_RSSI_UNKNOWN if no RSSI value is available (yet) </dd></dl>

</div>
</div>
<a class="anchor" id="a8a34dbe6f9723875ff4889eef428b743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::lastResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result value of the last operation. </p>
<p>The result values are codes that describe a failure in more detail. </p><dl class="section return"><dt>Returns</dt><dd>the last known error code </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_xs_device.html#ad365d14f454d0a9490fc6e2345a0d369" title="Get the accompanying error text for the value returned by lastResult() It may provide situation-speci...">lastResultText()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad365d14f454d0a9490fc6e2345a0d369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::lastResultText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the accompanying error text for the value returned by <a class="el" href="struct_xs_device.html#a8a34dbe6f9723875ff4889eef428b743" title="Get the result value of the last operation. ">lastResult()</a> It may provide situation-specific information instead. </p>
<dl class="section return"><dt>Returns</dt><dd>a human readable error description </dd></dl>
<dl class="section see"><dt>See also</dt><dd>resultText(XsResultValue), <a class="el" href="struct_xs_device.html#a8a34dbe6f9723875ff4889eef428b743" title="Get the result value of the last operation. ">lastResult()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cb3d5926ba88aace3a6c7bc2317487d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::loadLogFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a complete logfile. </p>
<p>Load the opened log file completely. This function loads all data from the open logfile in a separate thread, generating onProgressUpdated callbacks. This function will return true if the reading was scheduled. </p><dl class="section return"><dt>Returns</dt><dd>true if the threaded loading was successfully started </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_callback_manager_xda.html#a840ce749572d8997e33ee8f860db97c7" title="The XsCallback::onProgressUpdated() callback forwarding function. ">onProgressUpdated</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a36252f3e608917c48c2bffdc36987882">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad25b4c19c9861f059510289fbf8e6eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::locationId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p><dl class="section return"><dt>Returns</dt><dd>The current location ID stord in the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a89d6968b26addd3da277435a0fbec82a" title="Set the location ID of the device. ">setLocationId</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a86ebb05b0ea3bd301b3c2638a6343381">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a92dd574076bb067b83bfd3dac5e3a969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::logFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the log file the device is reading from. </p>
<p>Returns an empty string when not in file mode. </p><dl class="section return"><dt>Returns</dt><dd>The name of the logfile </dd></dl>

</div>
</div>
<a class="anchor" id="acc48f3bd1691f9e6ac5d5d35ecf5d160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevicePtr::logFileReadPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current read position of the open log file. </p>
<p>If the function encounters an error the function returns -1. </p><dl class="section return"><dt>Returns</dt><dd>The current read position (in bytes) from the start of the file or -1 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a343de9131eeb1088d9f0df2f38321a29" title="Get the size of the log file the device is reading from. ">logFileSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a343de9131eeb1088d9f0df2f38321a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cinterface.html#gaee1db0cf1b8591c59afba7a3a0d13eb9">XsFilePos</a> XsDevicePtr::logFileSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the log file the device is reading from. </p>
<p>If the function encounters an error the function returns 0. </p><dl class="section return"><dt>Returns</dt><dd>The size of the log file or 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#acc48f3bd1691f9e6ac5d5d35ecf5d160" title="Get the current read position of the open log file. ">logFileReadPosition</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a25a5477b86747083efca644b80355ea8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::makeOperational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Awinda station to operational state. </p>
<dl class="section note"><dt>Note</dt><dd>this is considered an extension to the config state, not a new state. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true when the awindastation is put in operational mode. </dd></dl>

</div>
</div>
<a class="anchor" id="add6706c445acd02d690ce8e4058d81bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_device.html">XsDevice</a> * XsDevicePtr::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the master device of this device. </p>
<p>This function returns the master device of the current device. This may be the device itself </p><dl class="section return"><dt>Returns</dt><dd>The master device of the device </dd></dl>

</div>
</div>
<a class="anchor" id="adf962a05593c38b4c628fad4d406adb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::maximumUpdateRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum update rate for the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum update rate of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a617e87d8f8ccf472f4f622f2e872171d" title="Ask the device for its supported update rates for the given dataType. ">supportedUpdateRates</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95b1499a3e5db22d0bac40cc5daf25ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxsens_1_1_guarded_mutex.html">xsens::GuardedMutex</a>* XsDevicePtr::mutex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The device mutex. </dd></dl>

</div>
</div>
<a class="anchor" id="a68d8cd66fecdff0276a890401e331996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_matrix.html">XsMatrix</a> XsDevicePtr::objectAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object alignment matrix of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The current 'object alignment matrix' setting of the device. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use alignmentRotationQuaternion or alignmentRotationMatrix instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setObjectAlignmentMatrix() </dd>
<dd>
<a class="el" href="struct_xs_device.html#a717a3d27cd952dc87d660f18c884f542" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61" title="Set the &#39;heading offset&#39; setting of the device. ">setHeadingOffset()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96aeb16cfa3b49bfe70a399e0cee27b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevicePtr::onboardFilterProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use by the device for computing orientations. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c603076bee2eb69133b3b3f80cfb992" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ac0f920bf91c5186e1f8aa74067390372">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af1a26b4ee59a9235ce6b8c3bb23573ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XsOperationalMode XsDevicePtr::operationalMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operational mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The current operational mode of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a31c0e4998bdbeeaefdc959c225e5bb0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> &amp;&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare device ID with that of <em>dev</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Device to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dev</em> has a higher device ID </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7" title="Return the device ID of the device. ">deviceId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d698f3fa096130a504276a607f70c78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>devId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare device ID with <em>devId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devId</td><td>DeviceId to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>devId</em> is higher than the contained device ID </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7" title="Return the device ID of the device. ">deviceId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42a2266f0ccdac4d4bbd0f89d01eb461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> &amp;&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare device ID with that of <em>dev</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Device to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>dev</em> has the same device ID </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7" title="Return the device ID of the device. ">deviceId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f421f4262f4edb3c1d0f2ed5eff7076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>devId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare device ID with <em>devId</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devId</td><td>DeviceId to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>devId</em> is the same as the contained device ID </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a4816ad6761de87cb49a96ce1807864f7" title="Return the device ID of the device. ">deviceId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a407e30aab29f1033873cce8d411fae83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevicePtr::outputConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured output of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The output configuration of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a3cd1d634277c5594c3e99c052a0dfb87">MtDevice</a>, and <a class="el" href="class_mti_base_device.html#a832e1727036e63be30f74176a3c7d23e">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a19a2685f15e5cb66082668af015aee43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::packetErrorRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet error rate for the for the device. </p>
<p>The packet error rate indicates the proportion of data packets from the device that are lost or corrupted in some manner over some time window. Depending on the device the packet error rate may be updated actively or passively, and the time window may vary, so packet error rates cannot be compared directly between different types of device.</p>
<dl class="section note"><dt>Note</dt><dd>Not all devices support packet error rate estimation. Those that don't will always report a 0% packet error rate.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The packet error rate as a percentage. </dd></dl>

</div>
</div>
<a class="anchor" id="a298e2e614995a5bd65603152db701fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> XsDevicePtr::portConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current port configuration of a device. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Only Mti6x0 devices supported </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current port configurations of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae6e60613acdb412005dd3ec00baf6622" title="Change the port configuration of a device. ">setPortConfiguration</a>, XsBaudCode </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#a7cf6d36a7280ab716600ff705fdd562e">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="a9384e46ddc1c6c2ae4a3c17ec34dcd67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_port_info.html">XsPortInfo</a> XsDevicePtr::portInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port information of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The port information object containing the information of the communication port or an empty structure if not connected to a communication port </dd></dl>

</div>
</div>
<a class="anchor" id="ab990c3b52e6186d14d1112d0cf6459c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::portName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The port name of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the communication port or an empty string if not connected to a communication port </dd></dl>

</div>
</div>
<a class="anchor" id="aab4e406b650ee865f52bb08984f68b75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::portNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the port number of the connection. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number or 0 if no port is open that can be identified by a single number </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc75871294b0e2e6cf449268730cb1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::powerDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the device to power down completely. </p>
<p>This function can be used to tell the device to shut down completely, requiring a physical button press on the device to power up again. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully powered down </dd></dl>

</div>
</div>
<a class="anchor" id="a9a2728ffa190332b465cae18f7d0497d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> XsDevicePtr::processedOutputConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full output configuration including post processing outputs. </p>
<p>This function return the list returned by <a class="el" href="struct_xs_device.html#a407e30aab29f1033873cce8d411fae83" title="Returns the currently configured output of the device. ">outputConfiguration()</a> and adds outputs that become available during post-processing. </p><dl class="section return"><dt>Returns</dt><dd>The requested output configuration list </dd></dl>

</div>
</div>
<a class="anchor" id="a9fcc8623208ee515981bc32efbacd4d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string.html">XsString</a> XsDevicePtr::productCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product code of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The product code of the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a6eec1bece0e1186d436bb1ad8826cbe9">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#a8b9839c9d2309f1b58d93cbdfae458ad">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a93842091b4abc3a96c7e5b6a2a5d4ea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::radioChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radio channel used for wireless communication. </p>
<dl class="section return"><dt>Returns</dt><dd>The radio channel used for wireless communication or -1 if the radio is disabled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Awinda Sation only </dd></dl>

</div>
</div>
<a class="anchor" id="a36395d8bb7d7c34a74c473511f375b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::readDeviceConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the device configuration. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a927ffd1b2a769e7955573990fe6b75e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::recordingQueueLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of packets currently waiting in the slow data cache for the device based. </p>
<dl class="section return"><dt>Returns</dt><dd>The highest received packet ID minus the last reported packet id in the slow data callback </dd></dl>

</div>
</div>
<a class="anchor" id="acbaedf3418630bbee55eb952d87bebe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsSize XsDevicePtr::refCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current reference counter. </p>
<dl class="section return"><dt>Returns</dt><dd>The current reference count </dd></dl>

</div>
</div>
<a class="anchor" id="ac561b31a844e7218acbe2de34ca49327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reinitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize the <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a>. </p>
<p>This function will read all configuration details freshly from the device and will reinitialize all filters. Especially when you have made changes to the device configuration outside XDA or through <a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5" title="Send a custom message messageSend to the device and possibly wait for a result. ">sendCustomMessage()</a> it is advisable to call this function so XDA will show the correct state of the device. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reinitialized </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The device itself is not reset, but will be put in config mode while the settings are being updated. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ab0ef417e3ca2e3c04c26c3b5fb17514e">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a7efc96f2ce70f18e2837a59da6a4c133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::rejectConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reject connections from the device on the parent/master device. </p>
<p>This function can be used to reject connections from a device that has connected. This function can be called from within the onConnectivityChanged callback or at other times when a device is connected. </p><dl class="section return"><dt>Returns</dt><dd>true if the device will be rejected next time it tries to connect </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After the function returns, this <a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> should no longer be used. </dd>
<dd>
MTw connected to Awinda Station only </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a0030d17e28da4d440bdc47bdea7c42d0" title="Returns the reason why a device&#39;s connection was rejected. ">rejectReason</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0030d17e28da4d440bdc47bdea7c42d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga5122aa0cce0c58c3b3873e5e3624d56b">XsRejectReason</a> XsDevicePtr::rejectReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reason why a device's connection was rejected. </p>
<p>This function is typically called from within the onConnectivityChanged callback when the connectivity has changed to XCS_Rejected. </p><dl class="section return"><dt>Returns</dt><dd>The reason why the connection was rejected </dd></dl>

</div>
</div>
<a class="anchor" id="a3608b05b6a94c8ff3889a1976ea42ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XsDevicePtr::removeCallbackHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_callback_plain_c.html">XsCallbackPlainC</a> *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a handler from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The handler to remove from the list. </td></tr>
    <tr><td class="paramname">chain</td><td>When set to true (default) the callback is added to child devices as well </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>cb</em> is not found in the list or if <em>cb</em> is NULL, the list is not changed, but chaining is still done. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eb0839e2acab62b9cdc6e8c82896743"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::removeRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease this XsDevices reference counter with 1 Also decreases the reference count of each child with 1. </p>
<ul>
<li>If it is a child device, it will delete itself when the reference count reaches zero. It will also remove itself from its master's child list and ask the master if it can be deleted</li>
<li>If it is a master device, it will delete itself when the reference count reaches zero and the reference count of all children is zero. </li>
</ul>

</div>
</div>
<a class="anchor" id="a48d8c44453e80d1c9fa2efc30062cd79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reopenPort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gotoConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipDeviceIdCheck</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reopens a port Uses rescan method to redetect a device. Also if USB descriptor has changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfig</td><td>Set to true if the device should be put to config before port closure </td></tr>
    <tr><td class="paramname">skipDeviceIdCheck</td><td>Set to true if the rescan should not verify the device id (not recommended) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a1a151cf5447c242dd8945b6b51e3b3cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::replaceFilterProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> const &amp;&#160;</td>
          <td class="paramname"><em>profileCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> const &amp;&#160;</td>
          <td class="paramname"><em>profileNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces profileCurrent by profileNew in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileCurrent</td><td>The profile that should be replaced </td></tr>
    <tr><td class="paramname">profileNew</td><td>The new profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation does nothing as this feature requires the full XDA </dd></dl>

</div>
</div>
<a class="anchor" id="a9027bea531e3c9de9b539e0c4e17e038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::representativeMotionState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the active representative motion state for the In-Run Compass Calibration. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the reprensentation motion state is active, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a233f94c82c17e5131fbdbf7654db941a">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a79f8e3b9c96877dd7e77b06892fa486a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::requestBatteryLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the battery level from the device. </p>
<p>This is an asynchronous operation. The Awinda station or MTw sends the battery level when possible. For devices in wired mode the </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a12837e1d6d6e4016206023905a920457" title="Get the batterylevel of this device The battery level is a value between 0 and 100 that indicates the...">batteryLevel()</a> function can be called without calling this function first. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If the battery level request was successfully sent </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a297969701eaeb80663d3d205815d7e97">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae1d00b7e36b3c792704795723af23fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::requestData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request data when configured in legacy mode with infinite skip factor. </p>
<p>When configured in legacy mode and an output skip factor of 0xFFFF, the device will not send data by itself, but will instead send the latest data after receiving an explicit request. This function is that request. After the request, the normal callback mechanism will take over. </p><dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#aeb0366084f477133de965d3235d8dfcb">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a8d2cc69f91abac03f00f631cb530d9db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the device. </p>
<p>This function tells the device to reboot itself. </p><dl class="section return"><dt>Returns</dt><dd>true if the device was successfully reset </dd></dl>

</div>
</div>
<a class="anchor" id="a96eff95f19b7f77be17dbbb28478aa63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::resetLogFileReadPosition </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the read position of the open log file to the start of the file. </p>
<p>If software filtering is enabled, the appropriate filters will be restarted as if the file was just opened. </p><dl class="section return"><dt>Returns</dt><dd>true if the read position was successfully reset to the start of the file </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a low-level file operation. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a9ff9d1c05224d822a76c1f77b1e79935">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#aa2cedb65cf32b736cece1be003ee664f">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3aeafc3cb53243db1aaea7213002d42c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::resetOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a>&#160;</td>
          <td class="paramname"><em>resetmethod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an orientation reset on the device using the given <em>resetMethod</em>. </p>
<p>This function schedules an orientation reset command to be applied in the first available orientation filter update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetmethod</td><td>The requested orientation reset method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the orientation reset was successfully scheduled </dd></dl>
<dl class="section note"><dt>Note</dt><dd>XRM_StoreAlignmentMatrix can only be used in config mode, the others only in measurement mode </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a35086a9b98df42507a49cd661173ad14">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a58d72dca92f64270cc5337406f55f7c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::resetPacketStamping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset packet stamping by re-initializing the highestpacket. </p>
<p>Used after config-measurement cycling </p>

</div>
</div>
<a class="anchor" id="af2d326da7273f832fe67b950caa5970a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::resetRemovesPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether a device reset will remove the COM port connection. </p>
<dl class="section return"><dt>Returns</dt><dd>True or false </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When connected directly to USB, the device cannot reset without losing connection. Then a rescan should be done </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#ad2e87a7cfc42d0892e44290cf186b579">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c4968f733da476e3e80bb024f01e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::restoreFactoryDefaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the device to its factory default settings. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the settings have been successfully restored </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ad975e29e3e5f216c76dfe7510c109d2c">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#ac26cbc3331c7264fe8e6a710fbb36e15">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd27816a059d133198d710f3e590956"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::retainPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>pack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the supplied <em>pack</em> to the linear packet cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>The packet to retain in the packet cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa892ee2ed423e6ef98e7a8854af07534"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::rs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p><dl class="section return"><dt>Returns</dt><dd>The currently configured RS485 transmission delay </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ab165be511b249f40190f6faa1b8b46ef">MtDevice</a>, and <a class="el" href="class_mti_base_device.html#a18640e7eaf3bb29cc6f55d5312e4162a">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af9249cc91fbabf54d6424c151745c6f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_self_test_result.html">XsSelfTestResult</a> XsDevicePtr::runSelfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the self test for the device. </p>
<p>All Xsens devices have limited self-diagnostic functionality, which can be triggered by calling this function. The device automatically does some self tests during startup, but this function returns more information. </p><dl class="section return"><dt>Returns</dt><dd>Results of the test </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and can take a few 100 ms </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a46b633a05725d5e677c27209b7279d89">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a27681f5f546379457f07f8ff4b05dbb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::scheduleOrientationReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gad6b059065f6fb1f2bdcde437c4de5357">XsResetMethod</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the orientation reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The reset method to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a114712b026dd84065e7a817d344b0c46">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9656439549ad9d4a2572aea7afaa48d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::sendCustomMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>messageReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a custom message <em>messageSend</em> to the device and possibly wait for a result. </p>
<p>If <em>waitForResult</em> is true, the function will wait for a result and put it in the given <em>messageReceive</em>. Otherwise the contents of messageReceive will not be altered. If an error message is received or the wait times out, <em>messageReceive</em> will contain an error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSend</td><td>The message to send to the device </td></tr>
    <tr><td class="paramname">waitForResult</td><td>true if it is required that the function waits for the appropriate reply. A valid reply always has a message ID that is one higher than the sent message ID. </td></tr>
    <tr><td class="paramname">messageReceive</td><td>When <em>waitForResult</em> is true, the reply will be put in this object. </td></tr>
    <tr><td class="paramname">timeout</td><td>Optional timeout in ms. When 0 is supplied (the default), the default timeout is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent and when <em>waitForResult</em> is true the correct reply has been received </dd></dl>

</div>
</div>
<a class="anchor" id="ac68153cc14002d710e1c896b0ee6f1f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::sendRawMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message directly to the communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message that will be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message was successfully sent </dd></dl>

</div>
</div>
<a class="anchor" id="ae2e9fcca145bf4d9adf719c131dbf669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a> XsDevicePtr::serialBaudRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The baud rate configured for cabled connection. </p>
<p>This differs from the <a class="el" href="struct_xs_device.html#ae42156bdd1fa0f8b62ba9ae90cf41ddb" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function in that it will return the configured value for a serial connection even if the device is currently not configured for serial communication (ie when it is connected with a direct USB cable or wirelessly), whereas the <a class="el" href="struct_xs_device.html#ae42156bdd1fa0f8b62ba9ae90cf41ddb" title="Get the baud rate (communication speed) of the serial port on which the given deviceId is connected...">baudRate()</a> function will return the baud rate of the current connection. </p><dl class="section return"><dt>Returns</dt><dd>The configured baud rate </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ae3b62b673dfe5e700e0144faf596ad45">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ac620eb9326e9c98fdd82dd597cf39cbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAccessControlMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#gae5cff56e1aafd948078a5a5d3a72495a">XsAccessControlMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id_array.html">XsDeviceIdArray</a> &amp;&#160;</td>
          <td class="paramname"><em>initialList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the access control mode of the master device. </p>
<p>The access control mode determines which connections are allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The access control mode to use, the choice is between blacklist or whitelist </td></tr>
    <tr><td class="paramname">initialList</td><td>The initial list to use for the selected access control mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the access control mode was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad06eb9a731cec918e7087af24ecf9d19" title="Request the access control mode of the master device. ">accessControlMode()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ad0fd097811cf459eec7855bfdd7447e0" title="Request the access control list of the master device. ">currentAccessControlList</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ae39415f88e591be84e34f659d887c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAlignmentRotationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L' or S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">matrix</td><td>The desired alignment rotation setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a50159ad87c0eadfa306f235a0160cead">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a5c5ba2ab3c1a316f6142d2383c472daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setAlignmentRotationQuaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga971ae8d9195b58f6cb8f858f06c83bcb">XsAlignmentFrame</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_quaternion.html">XsQuaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L' or S to the chosen frame S'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame to rotate </td></tr>
    <tr><td class="paramname">quat</td><td>The desired alignment rotation setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the alignment rotation has been set successfully </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ae4159ae056441f563d06e4d94450f61e" title="Retrieve the alignment rotation quaternion. ">alignmentRotationQuaternion</a>, <a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a>, <a class="el" href="struct_xs_device.html#a32aefeb3bcf3a82a8e6c2e1281283a1d" title="Retrieve the alignment rotation matrix to rotate S to the chosen frame S&#39;. ">alignmentRotationMatrix</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a3bc52ea594d7cb1315a778933db93f3b">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a99583e7e3b8be3c0f70454ebbf885afd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setBlueToothEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the BlueTooth radio of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true to enable the BlueTooth radio </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af3487b6bfd1e9b7e46862e152f894eb9" title="Returns true if the device has its BlueTooth radio enabled. ">isBlueToothEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6b8c2b18ad882c64b0ff3b7ad89655d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setBusPowerEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell the Xbus to provide power to its child devices or not. </p>
<p>This function can be used to tell the Xbus to stop and start powering its child devices. By default when the Xbus starts up it will provide power to its child devices. Switching the power off can save a lot of energy, but powering the system up again will take some time, depending on the number of connected devices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable bus power, false to disable the bus power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the Xbus' bus power state was successfully updated. </dd></dl>

</div>
</div>
<a class="anchor" id="a48dbc784ace70b92caaefb7626d64887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setCanConfiguration </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CAN configuration for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Should consist of 8 bytes baudcode and 1 bit to enable CAN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the CAN output configuration was successfully updated </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#a2f9d808b1d3594fb913a2f1f534949df">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="a53cc34af532ebc3c86a948e99f3e307d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setCanOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_can_output_configuration_array.html">XsCanOutputConfigurationArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CAN output configuration for this device. </p>
<p>When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#acfccac895af92c64a37368a9f15a277c">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="ac18207ff8660ea00f1ec85911904e0ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setCommunicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_communicator.html">Communicator</a> *&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a communicator for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>a communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa1b5a95fc6cae2b3b661936dc79670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceAccepted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to accept </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been successfully accepted </dd></dl>

</div>
</div>
<a class="anchor" id="acbf52735776e76c08aeb22e24b7bf78d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the device to set it's internal buffer to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>buffer size in frames </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the setting was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="aef1033b2fd38c83d64db9390c5fb2368"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceOptionFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td>
          <td class="paramname"><em>setFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga9a83e4c677de60c54f3284078fe37575">XsDeviceOptionFlag</a>&#160;</td>
          <td class="paramname"><em>clearFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device option flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setFlags</td><td>The option flags that must be set. Set to XDOF_None if no flags need to be set </td></tr>
    <tr><td class="paramname">clearFlags</td><td>The option flags that must be cleared. Set to XDOF_None if no flags need to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device option flags were successfully altered </dd></dl>

</div>
</div>
<a class="anchor" id="a9a21fea2a2341f73d15b641ddcaae827"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga31f1629126181b5371b3f3aff1b3bb72">XsResultValue</a> XsDevicePtr::setDeviceParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_parameter.html">XsDeviceParameter</a> const &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given parameter for the device. </p>
<p>Settings device parameters is only valid after initialization and before switching the device to be operational. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>a parameter object, corresponding to a row in the table below. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result value indicating success (XRV_OK) or unsupported with current device or firmware version (XRV_UNSUPPORTED).</dd></dl>
<p>For Awinda stations this function needs to be called before enabling the radio (<em><a class="el" href="struct_xs_device.html#a24af0dcccddf838764795b169213a9af" title="Set the radio channel to use for wireless communication. ">XsDevice::enableRadio</a></em>).</p>
<table class="doxtable">
<tr>
<th rowspan="2">XsDeviceParameterIdentifier </th><th rowspan="2">Value type/range </th><th rowspan="2">Description </th><th colspan="6">Supported devices  </th></tr>
<tr>
<th>Awinda 2 (Station, Dongle) </th><th>BodyPack </th><th>MTmk4 </th><th>MTw2 </th><th>MTx2 </th><th>SyncStation  </th></tr>
<tr>
<td>XDPI_PacketErrorRate </td><td>boolean </td><td>Report packet error rate for each child device. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_SyncLossTimeout </td><td>uint16_t </td><td>Network timeout in seconds used by connected child devices.<br />
For Awinda2: this timeout is measured by connected MTw2 devices based on received data from the station. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_UplinkTimeout </td><td>uint16_t </td><td>Network timeout in seconds used by the master devices.<br />
For Awinda2: this timeout is measured based on received data from each connected MTw2 individually. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
<tr>
<td>XDPI_ExtendedBuffer </td><td>bool </td><td>If set, enables the extended buffer on connected MTw2 devices. </td><td>Y </td><td>- </td><td>- </td><td>- </td><td>- </td><td>-  </td></tr>
</table>

</div>
</div>
<a class="anchor" id="a16cddf966e39a4abacb0bc279e31ffdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setDeviceRejected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device_id.html">XsDeviceId</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rejects a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device to reject </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device has been successfully rejected </dd></dl>

</div>
</div>
<a class="anchor" id="a4377d0013707a07acf5fdbeeee9a2b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setDeviceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device state for this device (triggering callbacks) and relay it to all children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The device state to set</td></tr>
  </table>
  </dd>
</dl>
<p>To ensure proper switching, the switch is done threaded. To override functionality, use <a class="el" href="struct_xs_device.html#a3e7762f2f17b301a3ceba7d342aef66f" title="Update the device state immediately. ">updateDeviceState()</a> </p><dl class="section return"><dt>Returns</dt><dd>The id of the task that marks the state change completion when <em>waitForCompletion</em> is false </dd></dl>

</div>
</div>
<a class="anchor" id="a91f03a8e30b52e38cebb8bfc3e6a7573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setErrorMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga80f5709c7cb1164e22826fe9ce5515ea">XsErrorMode</a>&#160;</td>
          <td class="paramname"><em>errormode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the error mode of the device. </p>
<p>The error mode tells the device what to do if a problem occurs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errormode</td><td>The desired error mode of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#aa689e1d8c857703bdf8d60c51ef6db8e" title="Returns the error mode of the device. ">errorMode</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ae4b2e4630432c2ddcc17bab3e4a8c336">MtDevice</a>, and <a class="el" href="class_mti_base_device.html#aac300af27eb27e46ed72c62491ae522a">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a0d5b98429d0b592a3395fb853619e8a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setFixedGravityEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the fixed gravity value should be used or if it should be computed from the initialPositionLLA value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to use fixed gravity, false to compute from initialPositionLLA </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#afc6647738e04ad072e94a91cbe544990" title="Returns if the fixed gravity value should be used or if it should be computed from the initialPositio...">isFixedGravityEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a1aecf0f050da7d709d73917ece872436" title="Sets the &#39;Gravity Magnitude&#39; of the device to the given value mag. ">setGravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a220f5fa69008190200f3845dd464f9f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setGnssPlatform </td>
          <td>(</td>
          <td class="paramtype">XsGnssPlatform&#160;</td>
          <td class="paramname"><em>gnssPlatform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device GNSS platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gnssPlatform</td><td>The GNSS platform that must be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device GNSS platform was successfully set </dd></dl>

</div>
</div>
<a class="anchor" id="aac0ee16fe5af46d170902369671fa23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setGotoConfigOnClose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gotoConfigOnClose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On closePort the device will go to config by default, with this function it is possible to prevent that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gotoConfigOnClose</td><td>boolean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1aecf0f050da7d709d73917ece872436"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setGravityMagnitude </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Gravity Magnitude' of the device to the given value <em>mag</em>. </p>
<p>The Gravity Magnitude is the strength of the gravity where the measurements are done. Setting this value precisely allows for more accurate measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mag</td><td>The desired 'Gravity Magnitude' setting of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Gravity Magnitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default value is usually computed from the last known Lat Lon Alt value </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a15e4d362fb66a5ccef8a458c2320f4fa" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a2de8e64303b89c2603f21f1040de71b6" title="Sets the &#39;Latitude Longitude Altitude&#39; setting of the device to the given vector. ...">setInitialPositionLLA</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a21cebe3dd7502b5d2e14659b770937b3" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a4e55cc269f059c19537f408963b96bb0">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a25e374050eb6373033799b6a3acb9d61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setHeadingOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the 'heading offset' setting of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The desired heading offset of the device in degrees </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a717a3d27cd952dc87d660f18c884f542" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#abdb7d9ce68116c2304aeac87d26cb8b5">BroadcastDevice</a>, and <a class="el" href="class_mti_base_device.html#a1a6b954bf6242330eb52555cf2282b6a">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9c10338c003a5f69bb5968583809de96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setInitialBiasUpdateEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set if the device does gyroscope bias estimation when switching to measurement mode. </p>
<p>When this option is enabled, the device will automatically run the 'no rotation' algorithm every time it switches to measurement mode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to enable the option, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully update </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#adf3340a175cded1e16f4e5c87e7a6709" title="Set the no rotation period to duration. ">setNoRotation</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#abee452722dcd4859fd9e9c241cf3af06" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2de8e64303b89c2603f21f1040de71b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setInitialPositionLLA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_vector.html">XsVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lla</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'Latitude Longitude Altitude' setting of the device to the given <em>vector</em>. </p>
<p>The Latitude Longitude Altitude contains the location on earth where the measurements are done. Setting this value allows for more accurate measurements. The default gravity magnitude and earth magnetic field are computed form this value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>The desired 'Latitude Longitude Altitude' setting for the device. This should be a 3-element vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Latitude Longitude Altitude was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GNSS is available, this value is automatically updated with the last known position when the device is put in config mode after measurement. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a21cebe3dd7502b5d2e14659b770937b3" title="Gets the &#39;Latitude Longitude Altitude&#39; setting of the device. ">initialPositionLLA</a> </dd>
<dd>
labMagneticField </dd>
<dd>
<a class="el" href="struct_xs_device.html#a15e4d362fb66a5ccef8a458c2320f4fa" title="Returns the &#39;Gravity Magnitude&#39; of the device. ">gravityMagnitude</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a02ea089a1d06bfd79e6f217ef43af529">MtDevice</a>, <a class="el" href="class_broadcast_device.html#a49a09a8947271d80789c2e5c20ef9d03">BroadcastDevice</a>, and <a class="el" href="class_mti_base_device.html#a5328bfebb191ee88492ffe14b1a51c6c">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a89d6968b26addd3da277435a0fbec82a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setLocationId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the location ID of the device. </p>
<p>The location ID is a custom 16-bit ID that can be assigned to a device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The desired location ID for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the Location ID was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#ad25b4c19c9861f059510289fbf8e6eb3" title="Get the location ID of the device. ">locationId</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ac10990ef8f2c0c55239da726c5ddcc70">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#a72d28a959e79fd153b7cb5c4580c37bc">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="adf3340a175cded1e16f4e5c87e7a6709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setNoRotation </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the no rotation period to <em>duration</em>. </p>
<p>This function can be called in both config and measurement modes. In config mode it specifies the duration that the device is considered to be stationary as soon as it enters measurement mode. In measurement mode, it specifies the duration that the device is considered to be stationary, starting immediately.</p>
<p>During the stationary period, the gyroscope biases are measured, giving better performance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The desired stationary duration in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the no rotation command was accepted by the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#abee452722dcd4859fd9e9c241cf3af06" title="Returns if the device does gyroscope bias estimation when switching to measurement mode...">isInitialBiasUpdateEnabled</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9c10338c003a5f69bb5968583809de96" title="Set if the device does gyroscope bias estimation when switching to measurement mode. ">setInitialBiasUpdateEnabled</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a0d0b6b14dcea10722e9e815cfa367894">MtDevice</a>, <a class="el" href="class_broadcast_device.html#aadff7b9327bd50678f09c496fa2a8a90">BroadcastDevice</a>, and <a class="el" href="class_mti_base_device.html#a8b4fcc2ebd87447ec03e1674b46fa800">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3bbd3c53640d1f34d3990fe6349a4a40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setObjectAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_matrix.html">XsMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the object alignment of the device to the given <em>matrix</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The desired 'object alignment matrix' setting of the device. This should be an orthonormal 3x3 matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object alignment matrix was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is legacy functionality to support backwards compatibility with older devices. For MT Mk4 devices it is suggested to use setAlignmentRotationQuaternion or setAlignmentRotationMatrix instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>objectAlignmentMatrix </dd>
<dd>
<a class="el" href="struct_xs_device.html#a717a3d27cd952dc87d660f18c884f542" title="Return the &#39;heading offset&#39; setting of the device. ">headingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a25e374050eb6373033799b6a3acb9d61" title="Set the &#39;heading offset&#39; setting of the device. ">setHeadingOffset</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a5c5ba2ab3c1a316f6142d2383c472daa" title="Set an arbitrary alignment rotation quaternion. Use to rotate either L to the chosen frame L&#39; or S to...">setAlignmentRotationQuaternion</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#aa5ae39415f88e591be84e34f659d887c" title="Set an arbitrary alignment rotation matrix Use to rotate either L to the chosen frame L&#39; or S to the ...">setAlignmentRotationMatrix</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a546d7e71a1efd4d09c59c1b9d4e28dba">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a104c62ce2ddaaef1d82bb68fb8e83ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a96aeb16cfa3b49bfe70a399e0cee27b2" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a187472f554a4265a3e69bcdf6479cc67">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#aeba21ccc7c7cbc3bde66cedeb6ad01fb">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3f841c8f72d8db684efe0a877625311d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOnboardFilterProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the device. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a6493f27ff1ce3af653e2c61eec8c0bc3" title="Return the list of filter profiles available on the device. ">availableOnboardFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a96aeb16cfa3b49bfe70a399e0cee27b2" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#ac8d77008f6ae280c5d4f43ba6c009998">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#ae535cdea7994b1211d5f2723e756c7b9">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a1f3c5fb2d9a4b4f04ab99c7843fea294"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOperationalMode </td>
          <td>(</td>
          <td class="paramtype">XsOperationalMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device in the given operational mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Desired operional mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af14166aed1e4d0e30fb3e80aed55453e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga76e175ae236aa6c8badbf198f132b427">XsOption</a>&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable and disable processing options. </p>
<p>These options are used to specify whether XDA should compute certain kinds of data from available other data and what data-retention policy to use. On a system with limited resources it may be useful to limit the processing and data retention done by XDA. By default XDA will do all processing it can do, but retain as little data as possible. In case of conflict, <em>enable</em> supersedes <em>disable</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A logically OR'ed combination of XsOptions to enable </td></tr>
    <tr><td class="paramname">disable</td><td>A logically OR'ed combination of XsOptions to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8c443be103003479799fa888ada5216e" title="Returns true when all the specified processing options are enabled. ">areOptionsEnabled</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#af6c4026b057e0b06e48f8f59e5348570">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a41ba018ecf2f59b3e00e1471acf656ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setOutputConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_output_configuration_array.html">XsOutputConfigurationArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output configuration for this device. </p>
<p>When the function exits with a true value <em>config</em> will contain the actual configuration in the device after configuration. When it exits with false the contents of <em>config</em> are undefined.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>config</em> is updated to reflect frequency mismatches in desired configuration and actually possible configuration. As input, a frequency of 65535 (0xFFFF) may be supplied to indicate 'maximum output rate', but after configuration XDA will have put the actual maximum value in <em>config</em>. Similarly, some data types may not have a real update rate (ie. packet counter) and will return an update rate of 65535 (0xFFFF) when configured at any rate other than 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The desired output configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the output configuration was successfully updated </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a29c246f9ad7cc581fd73cbf8ac2e054d">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ae6e60613acdb412005dd3ec00baf6622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setPortConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_int_array.html">XsIntArray</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the port configuration of a device. </p>
<p>Configures the 2 ports of the 6x0 device The integers consist of:</p><ul>
<li>bits 0:7 XsBaudcode</li>
<li>bit 8 Enable flow control</li>
<li>bit 9 Use 2nd stop bit</li>
<li>bit 10 Use Parity bit</li>
<li>bit 11 Even/odd parity</li>
<li>bit 12:15 reserved</li>
<li>bits 16:19 bits XsProtocol <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>An array of elements containing a configuration for each port (UART and RS232) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only Mti6x0 devices supported </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port configuration was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a298e2e614995a5bd65603152db701fe1" title="Get the current port configuration of a device. ">portConfiguration</a>, XsBaudCode </dd></dl>
</li>
</ul>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#af3924744424b7614ec54e3fcc24f8458">Mti6X0Device</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba7004a5136186128bc156db997a359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setRs485TransmissionDelay </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transmission delay used for RS485 transmissions. </p>
<p>See the low level documentation for more information on this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>The desired delay </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a27013ae096f2ba96d68e3144fd417c9a">MtDevice</a>, and <a class="el" href="class_mti_base_device.html#a026d8f6446117c74e0f53f0ba07cd9ad">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3febab304a21f08d188698aec93a97e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSerialBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga2822b258045f067902cabca1a2f15eec">XsBaudRate</a>&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the serial baudrate to <em>baudrate</em>. </p>
<p>This function is only useful when using a serial communication channel, such as a serial-USB converter or a direct COM port. It is advised to make the baud rate as high as your platform allows, to minimize latency and problems with bandwidth.</p>
<p>After setting the baudrate and communicating over the same communication channel, it is required to reset the device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The desired serial baudrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the baud rate was successfully updated </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a329f028bbf9620c90c5e5892b9e8f60b">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af63c77821ac836f479a8f86aef0693e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setStartRecordingPacketId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>startFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets start recording packet id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startFrame</td><td>a start frame value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b6d31de9b2703f3f28451413b047cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setStealthMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable stealth mode. </p>
<p>In stealth mode, the MVN hardware will be silent and all LEDs will be dimmed or disabled. Some minimal user feedback will remain enabled. The change will be applied immediately to all detected systems, resetting the mocap data stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Set to true if you wish to enable stealth mode, false to disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the setting was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b2ce8a779b77f79bbbb84d85c209b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::setStopRecordingPacketId </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>stopFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets stop recording packet id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stopFrame</td><td>a stop frame value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd4f01736d0491a404eecd35cdfee3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setStringOutputMode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>skipFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the string output mode for this device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to set </td></tr>
    <tr><td class="paramname">period</td><td>The period to set </td></tr>
    <tr><td class="paramname">skipFactor</td><td>The skipFactor to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the device was successfully updated </dd></dl>

</div>
</div>
<a class="anchor" id="a027b516c49744d85c28129b9a95c4eaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSyncSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> &amp;&#160;</td>
          <td class="paramname"><em>settingList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the synchronization settings of the device. </p>
<p>This function can be used to set all the synchronization options of the device at once. It is translated into device-specific commands by XDA, since not all devices support the same synchronization functionality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settingList</td><td>The list of synchronization settings to set. An empty list will clear all synchronization settings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully updated </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a36a280a0b4593ad684e84edcbdac51e8" title="Get all the current synchronization settings of the device. ">syncSettings</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a4d7ef8573e61f8af6d924e7182541cc9">MtiBaseDevice</a>, and <a class="el" href="class_broadcast_device.html#a2cbd7d3cee81748d0aaaa1454415ae5f">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a43b42d6bab3640389ba5936cbd5aaa4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setSyncStationMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Sync Station mode of the Awinda Station device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable Sync Station mode, false to disable it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a01256f48cf926440c226c91fadc72ab8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setTransportMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transportModeEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the transport mode for the device. </p>
<p>The MTw has a "wake up by motion" feature that requires some power and can cause unnecessary wakeups when transporting the device. This function can be used to put the device in "transport mode", which effectively disables the motion wake up feature until the device is plugged into something or the transport mode is explicitly disabled by this function again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transportModeEnabled</td><td>true to enable transport mode (which disables the motion wakeup) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device was successfully put in transport mode (or taken out of it) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw only </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a1d61d5fb5d9637e810c5014092bbda33">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a43f1e4fe0a563c86f40a663e113b1bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setUpdateRate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the legacy update rate of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>The desired legacy update rate for the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the update rate was successfully set </dd></dl>
<dl class="section see"><dt>See also</dt><dd>deviceMode </dd>
<dd>
setDeviceMode </dd></dl>

</div>
</div>
<a class="anchor" id="af96019db07120f4c50b7d50fda4201a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setUtcTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'UTC Time' setting of the device to the given <em>time</em>. </p>
<p>Sets the UTC time in the device. Setting this value allows for more accurate measurements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The current time in UTC format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the UTC Time was successfully written </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When GNSS is available, this value is automatically updated with the last known UTC time when the device is put in config mode after measurement. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a24717f3e17c5c4a01792b92892297c8e">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a2b5777d11869ea81ba031387a00eecc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setWirelessPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wireless priority of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired wireless priority of the device in the range 0-255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the wireless priority has been successfully updated </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a89d32dca25c36ce8a6a65fa8767b8049"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a96eff95f19b7f77be17dbbb28478aa63" title="Set the read position of the open log file to the start of the file. ">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#a8cb3d5926ba88aace3a6c7bc2317487d" title="Load a complete logfile. ">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c603076bee2eb69133b3b3f80cfb992" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a005a47acf4c799479d552f5d2f925116">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af486a505331ac8558052492df27be229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::setXdaFilterProfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_string.html">XsString</a> const &amp;&#160;</td>
          <td class="paramname"><em>profileType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the filter profile to use for computing orientations on the host PC. </p>
<p>When computing orientation data, there is a choice of filter profiles. This function can be used to select the appropriate one. By default XDA will attempt to match the software filter profile to the configured hardware filter profile when detecting a new device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileType</td><td>The filter profile type to use. This can be chosen from the list returned by <a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the filter profile was successfully changed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When reading from a file, make sure to call <a class="el" href="struct_xs_device.html#a96eff95f19b7f77be17dbbb28478aa63" title="Set the read position of the open log file to the start of the file. ">resetLogFileReadPosition()</a> and possibly <a class="el" href="struct_xs_device.html#a8cb3d5926ba88aace3a6c7bc2317487d" title="Load a complete logfile. ">loadLogFile()</a> after changing the filter profile to make sure all cached data is recomputed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a5eb69ce9c16cd3167a5dfa41b4a26c74" title="Return the list of filter profiles available on the host PC. ">availableXdaFilterProfiles</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a8c603076bee2eb69133b3b3f80cfb992" title="Gets the filter profile in use for computing orientations on the host PC. ">xdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a104c62ce2ddaaef1d82bb68fb8e83ddf" title="Sets the filter profile to use for computing orientations on the device. ">setOnboardFilterProfile</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a2c13c724105fd8be3b6c22fb0238a1d9">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a8027cf8feb3ee2700b305cd5c02f8220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::shouldDataMsgBeRecorded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the supplied data message should be recorded to file </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to use</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be overridden on a master device so we can check its device-specific messages. The function is only supplied XMID_Data and XMID_Data2 messages. If this needs to change, make sure to update the existing implementations accordingly. </p>

</div>
</div>
<a class="anchor" id="a1e861282110139d7bfd31b5873bf77f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::shouldDoRecordedCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if it should do a recorded callback for a given <em>data</em> packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The reference to a data packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a class="anchor" id="aa277b375d73ec3e27d9a5da15f51e9b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::shouldWriteMessageToLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the message should be written to log file </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to write</td></tr>
  </table>
  </dd>
</dl>
<p>We have some cases where we don't want every child device to write its messages to log file (XM/AbmClockMaster) </p><dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a8d33fe54b1c8a312ce83faec1cc91bee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::shouldWriteMessageToLogFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_xs_device.html">XsDevice</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_xs_message.html">XsMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <em>child</em> should be writing to log file </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The child device </td></tr>
    <tr><td class="paramname">message</td><td>The message to write</td></tr>
  </table>
  </dd>
</dl>
<p>We have some cases where we don't want every child device to write its messages to log file (XM/AbmClockMaster) </p><dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a295f6552ad3f15015a7a056e427f9d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::skipEmtsReadOnInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if skip EMTS read on initialization is set to true </dd></dl>

</div>
</div>
<a class="anchor" id="ab803abd63d1355ed48f88782528e8772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::startRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording incoming data. </p>
<p>To record successfully, a log file should be created by calling <a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> before this function is called. startRecording(XsString, XsDeviceId) can be used to achieve the same result. </p><dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Starting recording for a single non-main device will start a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9dadcbf2a3d4748e464945d2c52030bd" title="Stop recording incoming data. ">stopRecording()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a570552d81d353f0043eaec2c32ee834b">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="afce91e11ff069c678fe753242337d9a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::startRepresentativeMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let the user indicate that he is starting the representative motion for the In-Run Compass Calibration. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the start indication was successfully sent to the device </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#afdeb877efd3f7aeb3850f1a90f884428">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a5165731cc588681c960db5dfb86a5cfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::stealthMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the state of the stealth mode setting. </p>
<dl class="section return"><dt>Returns</dt><dd>the state of the stealth mode setting. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a1b6d31de9b2703f3f28451413b047cde" title="Enable or disable stealth mode. ">setStealthMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9dadcbf2a3d4748e464945d2c52030bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::stopRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop recording incoming data. </p>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully stopped </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stopping recording for a single non-main device will stop a recording for the entire system. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab803abd63d1355ed48f88782528e8772" title="Start recording incoming data. ">startRecording()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a80c3ef6f5bb6e817a66c31132177beee">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a132ceb6c84eaffdbddb15eb8bf80a3e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_icc_rep_motion_result.html">XsIccRepMotionResult</a> XsDevicePtr::stopRepresentativeMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let the user indicate that he stopped the representative motion. </p>
<p>for the In-Run Compass Calibration </p><dl class="section return"><dt>Returns</dt><dd>A struct containing the results of the last In-Run Compass Calibration </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#aa26ae80727a27eb56fa4e194a3d2ea0c">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a12785a3723d2b6d3be3eb096da4fddae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::storeFilterState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store orientation filter state in the device. </p>
<p>Use this function when the filters for the device have stabilized to store the current biases in the device. The benefit is that on the next startup the filter will stabilize quicker. However, the stored biases depend on temperature and other external parameters, so the stored values will remain correct for only a short time. </p><dl class="section return"><dt>Returns</dt><dd>true if the filter state was saved, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a17c92c93ca57df9fbf317ddb593ef3d0">MtDevice</a>, and <a class="el" href="class_broadcast_device.html#ab6ab5f8c6be0d6346fa4aa0d936d0aab">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad94fd4b0efaead71ac1c8ab31869237b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::storeIccResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store the onboard ICC results for use by the device. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the store was successful </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#aa91dabf9dfa0b5292b2cb6c9145ddf69">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a54a9346db6249006090854b4a0d7abf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringOutputType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string output type. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'string output type' setting of the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setStringOutputType </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a5cd9a99b3e5547c7ca48e759b882da4a">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="abc3075a046f7402ba595692570e28786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringSamplePeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sample period for string output. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'sample period' setting of the device for string output </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a1701e70899742354814eb9b471444eb7">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ada8a74ecf8e68edc03225810b450ed4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t XsDevicePtr::stringSkipFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the skipfactor for string output. </p>
<dl class="section return"><dt>Returns</dt><dd>The 'output skip factor' setting of the device for string output </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a44ca416e2b95f3d07d5b433233966e95">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="af0bf49569bea925b19ca034ce7771567"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XsDevicePtr::supportedStatusFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a bitmask with all the status flags supported by this device. </p>
<p>Not all devices support all status flags. When receiving an <a class="el" href="struct_xs_data_packet.html" title="Contains an interpreted data message. The class provides easy access to the contained data through it...">XsDataPacket</a> with a status in it, this can affect how to interpret the flags. Especially with a flag like the self-test it's important not to conclude that a device is defective because it is not set when the device doesn't actually support this feature. </p><dl class="section return"><dt>Returns</dt><dd>The bitmask with all the status flags that this device supports </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a8a0c84c0e4bac9df7ed009cb84041a62">MtDevice</a>, <a class="el" href="class_mti_x_device.html#a49df4610e93df45b658e56917bbd5450">MtiXDevice</a>, <a class="el" href="class_mti6_x0_device.html#ad3fd2227314db99fd2eba921e04bd213">Mti6X0Device</a>, <a class="el" href="class_mti7_device.html#a891073bab6edd0c785645aaaa42dd195">Mti7Device</a>, <a class="el" href="class_mti_x00_device.html#ad030425af3f7b64da22276a5ce7c9d27">MtiX00Device</a>, <a class="el" href="class_mti_x0_device.html#ab54e2761ba137a32783502a3749ec276">MtiX0Device</a>, and <a class="el" href="class_mtig_device.html#aa4317a17c253df43f78c6efb5ab321d7">MtigDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ad6eefe6a5b872d1d460c80901bd8ef95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_string_output_type_array.html">XsStringOutputTypeArray</a> XsDevicePtr::supportedStringOutputTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the device for its supported string output types. </p>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported string output types. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti6_x0_device.html#aaa8d1dd754ea74d6de50a6873a8f033f">Mti6X0Device</a>, <a class="el" href="class_mti_x00_device.html#a441f40dc744295b334c5085b0d776c8e">MtiX00Device</a>, <a class="el" href="class_mti_x0_device.html#ac8cdbfb128c1cd1e18c6b23efa7be5d7">MtiX0Device</a>, and <a class="el" href="class_mtig_device.html#a39839f9a4e62b564d2500602e57a4e90">MtigDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a9c0e9feb7a03ef39bc8c1f4d706b3032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::supportedSyncSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all supported synchronization settings available on the device. </p>
<p>This function provides a list of the available synchronization settings of the device, since not all devices support the same synchronization functionality. Every <a class="el" href="struct_xs_sync_setting.html" title="A structure for storing all xsens sync settings. ">XsSyncSetting</a> element in the list defines one function and line setting, with supported parameters. If the same function support multiple settings (i.e. multiple lines), then the list will contains multiple items with the same function name, but with different line settings. For easier use, same functions must be listed next to eachother, so each function settings in the list will be grouped. Properties, others then m_function and m_line are set to 0 if not supported or 1 if supported by the device. </p><dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings supported by the device. Each settings grouped by functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a234b88d2f9cb339be3afcc22547d6ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::supportedSyncSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the supported synchronization settings for a specified <em>deviceId</em> or deviceId mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id to request the supported synchronization settings for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the supported synchronization settings for the specified deviceId </dd></dl>

</div>
</div>
<a class="anchor" id="a617e87d8f8ccf472f4f622f2e872171d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; XsDevicePtr::supportedUpdateRates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em> = <code><a class="el" href="group__enums.html#gga7f6c648c619f528344bfa0630c1f7252a0f6d9a98f741377d30c073548e64b97c">XDI_None</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the device for its supported update rates for the given <em>dataType</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the supported update rates for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list with the supported update rates or an empty list in case of an error </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a353538d5434bc14c593edfdc6f95b79d">MtiBaseDevice</a>, and <a class="el" href="class_broadcast_device.html#a02381bde64ae50d91c2707e87ce12792">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a09f36dfad04f941d4d4b8801bec0a8d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::supportsSyncSettings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the device specified by <em>deviceId</em> supports sync settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The device id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the device specified by <em>deviceId</em> supports sync settings </dd></dl>

</div>
</div>
<a class="anchor" id="a6148702cdd98e4085fe4f4ca399bdd10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga139cdca9409c47b0026f04e2b19edcd3">XsSyncRole</a> XsDevicePtr::syncRole </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the synchronization role of the device. </p>
<p>For synchronization purposes a device can be a master, a slave, both or neither. This function returns the way the device is currently configured. </p><dl class="section return"><dt>Returns</dt><dd>The synchronization role of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a36a280a0b4593ad684e84edcbdac51e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_sync_setting_array.html">XsSyncSettingArray</a> XsDevicePtr::syncSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the current synchronization settings of the device. </p>
<p>This function is a generic way of requesting the synchonization options of a device, since not all devices support the same synchronization functionality. </p><dl class="section return"><dt>Returns</dt><dd>The list of synchronization settings configured for the device </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a027b516c49744d85c28129b9a95c4eaa" title="Set the synchronization settings of the device. ">setSyncSettings</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a68b1da22767620a5adbf59f24ac7a2b8">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a179fc99f3e32921b758ead95141ccff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XsDevicePtr::syncSettingsTimeResolutionInMicroSeconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_xs_device_id.html">XsDeviceId</a>&#160;</td>
          <td class="paramname"><em>deviceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the time resolution in microseconds for a device with device id <em>deviceId</em> For example if the precision is 1 millisecond, 1000 is returned </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceId</td><td>The deviceId </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15da55406b99b9ed395ea919db1c008b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_data_packet.html">XsDataPacket</a> XsDevicePtr::takeFirstDataPacketInQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first packet in the packet queue or an empty packet if the queue is empty. </p>
<p>This function will only return a packet when XSO_RetainLiveData or XSO_RetainBufferedData is specified for the device. It will return the first packet in the queue and remove the packet from the queue. </p><dl class="section return"><dt>Returns</dt><dd>The first packet in the queue or an empty packet if the queue is empty </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#af14166aed1e4d0e30fb3e80aed55453e" title="Enable and disable processing options. ">setOptions</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0314b50c08e60167cf8419a150e866d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::transportMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current state of the transport mode feature. </p>
<dl class="section return"><dt>Returns</dt><dd>true if tranport mode is currently enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a01256f48cf926440c226c91fadc72ab8" title="Enable or disable the transport mode for the device. ">setTransportMode</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a999546432f1a4685acd2aab13795b7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::triggerStartRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording incoming data through generating a virtual input trigger. </p>
<dl class="section note"><dt>Note</dt><dd>On devices without support for a start recording input trigger this function will default to <a class="el" href="struct_xs_device.html#ab803abd63d1355ed48f88782528e8772" title="Start recording incoming data. ">XsDevice::startRecording</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if recording was successfully started </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8afe4b27a5df14e02c8a1c6a7dfcb3c4" title="Create a log file for logging. ">createLogFile()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a9dadcbf2a3d4748e464945d2c52030bd" title="Stop recording incoming data. ">stopRecording()</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#ab803abd63d1355ed48f88782528e8772" title="Start recording incoming data. ">startRecording</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3395680c39ebf615f62dc30a4cac5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::updateCachedDeviceInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the cached device information for all devices connected to this port. </p>
<p>This function can only be called in config mode. XDA caches all device information to prevent unnecessary communication with the device. When some configuration has changed without XDA knowing about it (through <a class="el" href="struct_xs_device.html#a9656439549ad9d4a2572aea7afaa48d5" title="Send a custom message messageSend to the device and possibly wait for a result. ">sendCustomMessage()</a> for example), it may be necessary to tell XDA to refresh its cached information by calling this function. </p><dl class="section return"><dt>Returns</dt><dd>true if the cached information was updated successfully </dd></dl>

<p>Reimplemented in <a class="el" href="class_broadcast_device.html#a3edaf0ae4cc6db8b33f31dd7111d44ba">BroadcastDevice</a>.</p>

</div>
</div>
<a class="anchor" id="ace5fe48604bc6a6a2cb0b35e57e00e28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::updateConnectivityState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga96db442082eb29c41c3500db7539120c">XsConnectivityState</a>&#160;</td>
          <td class="paramname"><em>newState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the connectivity state to <em>newState</em> if different than the old state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newState</td><td>the new state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e7762f2f17b301a3ceba7d342aef66f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::updateDeviceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga245890047aa9e98da97ffdec1f17d676">XsDeviceState</a>&#160;</td>
          <td class="paramname"><em>newState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the device state immediately. </p>
<p>The function marks the completion of a device state change. The callbacks that mark the end of a state transition should only be called from within this function or its overrides. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newState</td><td>The desired state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function can be overridden because some devices support different states </dd></dl>

</div>
</div>
<a class="anchor" id="a0414d3545864edc597331a861f8da04a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the legacy update rate of the device. </p>
<p>This function is only valid for devices in legacy mode. </p><dl class="section return"><dt>Returns</dt><dd>The legacy update rate of the device </dd></dl>

</div>
</div>
<a class="anchor" id="a81c7fbc6491350c79800b3dc20359fa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRateForDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. This function only checks the output configured in the device, not possible computed data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

<p>Reimplemented in <a class="el" href="class_mt_device.html#a8ce2d9c5a067cdc2943b10deaa878e78">MtDevice</a>.</p>

</div>
</div>
<a class="anchor" id="a3e588c33f4afdf18e6d4af7f4a2bcdb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::updateRateForProcessedDataIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga7f6c648c619f528344bfa0630c1f7252">XsDataIdentifier</a>&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently configured update rate for the supplied <em>dataType</em>. </p>
<p>This function checks if the configured output contains <em>dataType</em> and returns the associated update rate. In some cases 65535 (0xFFFF) will be returned, which means 'as fast as possible'. This applies to things like a packet counter, which is sent with every packet and can therefore have an unpredictable update rate. Where updateRateForDataIdentifier only checks the outputs configured in the device, this function also checks what can and will be computed from the data. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a81c7fbc6491350c79800b3dc20359fa3" title="Returns the currently configured update rate for the supplied dataType. ">updateRateForDataIdentifier</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The type of data to get the update rate for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested update rate or 0 if the type is not configured for output </dd></dl>

</div>
</div>
<a class="anchor" id="a55bde49e47b8e17dd2532503c7389923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::useLogInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_data_logger.html">DataLogger</a> *&#160;</td>
          <td class="paramname"><em>logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses log interface for a given data logger. </p>
<p>Override the log interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The data logger</td></tr>
  </table>
  </dd>
</dl>
<p>For testing purposes</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct_xs_device.html" title="A pointer to an XsDevice object. ">XsDevice</a> takes control of the supplied pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ae314c8eb8ae65b19b5eb82c24460c864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::usesLegacyDeviceMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the device uses legacy device mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the legacy period, outputmode, outputsettings or string reports are used </dd></dl>

</div>
</div>
<a class="anchor" id="a09ff33cc1b85f1c3d0fa3cc74416ad79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_time_info.html">XsTimeInfo</a> XsDevicePtr::utcTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the 'UTC Time' setting of the device. </p>
<p>Gets the UTC time in the device. </p><dl class="section return"><dt>Returns</dt><dd>The current UTC time of the sensor </dd></dl>

<p>Reimplemented in <a class="el" href="class_mti_base_device.html#a6d18e9c51080675849f0c237bfaeee3a">MtiBaseDevice</a>.</p>

</div>
</div>
<a class="anchor" id="aad9bfac62bee437be07164dac860049b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::waitForAllDevicesInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until are known devices are initialized. </p>
<p>Container devices such as Awinda Master and Bodypack can have (slightly) delayed initialization of child devices after they have been detected. This function can be used to wait for all currently detected trackers to have been properly initialized. </p>

</div>
</div>
<a class="anchor" id="aff6d9626773e736aa2b0224859baa3ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XsDevicePtr::waitForLoadLogFileDone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the file operation started by loadLogFile to complete. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a8cb3d5926ba88aace3a6c7bc2317487d" title="Load a complete logfile. ">loadLogFile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a62cee213873a1d513d14e795a7ce178b" title="Returns true if the file operation started by loadLogFile is still in progress. ">isLoadLogFileInProgress</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac32cf140f5fdc2609d65397a04eb3358"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int XsDevicePtr::wirelessPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wireless priority of the device. </p>
<dl class="section return"><dt>Returns</dt><dd>The wireless priority of the device or 0 if it has none. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>MTw connected to Awinda Station only </dd></dl>

</div>
</div>
<a class="anchor" id="a8c603076bee2eb69133b3b3f80cfb992"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_filter_profile.html">XsFilterProfile</a> XsDevicePtr::xdaFilterProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the filter profile in use for computing orientations on the host PC. </p>
<dl class="section return"><dt>Returns</dt><dd>The filter profile in use when computing orientations is done on the PC </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_xs_device.html#a89d32dca25c36ce8a6a65fa8767b8049" title="Sets the filter profile to use for computing orientations on the host PC. ">setXdaFilterProfile</a> </dd>
<dd>
<a class="el" href="struct_xs_device.html#a96aeb16cfa3b49bfe70a399e0cee27b2" title="Gets the filter profile in use by the device for computing orientations. ">onboardFilterProfile</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a252474853375985a7928f5368711d597"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_xs_message.html">XsMessage</a> XsDevicePtr::m_emtsBlob</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An EMTS blob from device. </p>
<dl class="section note"><dt>Note</dt><dd>Used in public source for storing EMTS for log file header. </dd></dl>

</div>
</div>
<a class="anchor" id="a11620ad9af947d461879376add486a5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XsDevicePtr::m_skipEmtsReadOnInit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip EMTS read on init boolean variable. </p>
<p>Required for the firmware updater to retain EMTS while rebooting devices </p>

</div>
</div>
<a class="anchor" id="a81ecadbae478a18b68d631f20411c2ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* XsDevicePtr::m_toaDumpFile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To a dump file. </p>
<p>For debugging purposes only, but doesn't do any harm to always be there. </p>

</div>
</div>
</div><!-- contents -->

<div class="tabs">&nbsp;</div>
<hr size="1" />
<address style="text-align: right;">
<small>Generated on Mon Sep 9 2019 for Xsens by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small>
</address>
</body>
</html>
